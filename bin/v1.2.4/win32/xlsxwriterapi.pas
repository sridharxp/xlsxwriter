unit xlsxwriterapi;
{ This unit is initially generated by Chet:
  https://github.com/neslib/Chet }
{$IFDEF fpc}
{$MODE Delphi}
{$ENDIF}

{$MINENUMSIZE 4}

interface

const
  {$IF Defined(WIN32)}
  bj = 'libxlsxwriter.dll';
  _PU = '';
  {$ELSEIF Defined(WIN64)}
  bj = 'libxlsxwriter.dll';
  _PU = '';
  {$ELSE}
    {$MESSAGE Error 'Unsupported platform'}
  {$IFEND}

const
  { TODO : Unable to convert function-like macro: }
  (* QMD_TRACE_ELEM ( elem ) *)
  { TODO : Unable to convert function-like macro: }
  (* QMD_TRACE_HEAD ( head ) *)
  { TODO : Unable to convert function-like macro: }
  (* QMD_SAVELINK ( name , link ) *)
  { TODO : Unable to convert function-like macro: }
  (* TRASHIT ( x ) *)
  { TODO : Unable to convert function-like macro: }
  (* SLIST_HEAD ( name , type ) struct name { struct type * slh_first ; /* first element */ \
} *)
  { TODO : Unable to convert function-like macro: }
  (* SLIST_HEAD_INITIALIZER ( head ) { NULL } *)
  { TODO : Unable to convert function-like macro: }
  (* SLIST_ENTRY ( type ) struct { struct type * sle_next ; /* next element */ \
} *)
  { TODO : Unable to convert function-like macro: }
  (* SLIST_EMPTY ( head ) ( ( head ) -> slh_first == NULL ) *)
  { TODO : Unable to convert function-like macro: }
  (* SLIST_FIRST ( head ) ( ( head ) -> slh_first ) *)
  { TODO : Unable to convert function-like macro: }
  (* SLIST_FOREACH ( var , head , field ) for ( ( var ) = SLIST_FIRST ( ( head ) ) ; ( var ) ; ( var ) = SLIST_NEXT ( ( var ) , field ) ) *)
  { TODO : Unable to convert function-like macro: }
  (* SLIST_FOREACH_FROM ( var , head , field ) for ( ( var ) = ( ( var ) ? ( var ) : SLIST_FIRST ( ( head ) ) ) ; ( var ) ; ( var ) = SLIST_NEXT ( ( var ) , field ) ) *)
  { TODO : Unable to convert function-like macro: }
  (* SLIST_FOREACH_SAFE ( var , head , field , tvar ) for ( ( var ) = SLIST_FIRST ( ( head ) ) ; ( var ) && ( ( tvar ) = SLIST_NEXT ( ( var ) , field ) , 1 ) ; ( var ) = ( tvar ) ) *)
  { TODO : Unable to convert function-like macro: }
  (* SLIST_FOREACH_FROM_SAFE ( var , head , field , tvar ) for ( ( var ) = ( ( var ) ? ( var ) : SLIST_FIRST ( ( head ) ) ) ; ( var ) && ( ( tvar ) = SLIST_NEXT ( ( var ) , field ) , 1 ) ; ( var ) = ( tvar ) ) *)
  { TODO : Unable to convert function-like macro: }
  (* SLIST_FOREACH_PREVPTR ( var , varp , head , field ) for ( ( varp ) = & SLIST_FIRST ( ( head ) ) ; ( ( var ) = * ( varp ) ) != NULL ; ( varp ) = & SLIST_NEXT ( ( var ) , field ) ) *)
  { TODO : Unable to convert function-like macro: }
  (* SLIST_INIT ( head ) do { SLIST_FIRST ( ( head ) ) = NULL ; \
} while ( 0 ) *)
  { TODO : Unable to convert function-like macro: }
  (* SLIST_INSERT_AFTER ( slistelm , elm , field ) do { SLIST_NEXT ( ( elm ) , field ) = SLIST_NEXT ( ( slistelm ) , field ) ; SLIST_NEXT ( ( slistelm ) , field ) = ( elm ) ; \
} while ( 0 ) *)
  { TODO : Unable to convert function-like macro: }
  (* SLIST_INSERT_HEAD ( head , elm , field ) do { SLIST_NEXT ( ( elm ) , field ) = SLIST_FIRST ( ( head ) ) ; SLIST_FIRST ( ( head ) ) = ( elm ) ; \
} while ( 0 ) *)
  { TODO : Unable to convert function-like macro: }
  (* SLIST_NEXT ( elm , field ) ( ( elm ) -> field . sle_next ) *)
  { TODO : Unable to convert function-like macro: }
  (* SLIST_REMOVE ( head , elm , type , field ) do { QMD_SAVELINK ( oldnext , ( elm ) -> field . sle_next ) ; if ( SLIST_FIRST ( ( head ) ) == ( elm ) ) { SLIST_REMOVE_HEAD ( ( head ) , field ) ; } else { struct type * curelm = SLIST_FIRST ( ( head ) ) ; while ( SLIST_NEXT ( curelm , field ) != ( elm ) ) curelm = SLIST_NEXT ( curelm , field ) ; SLIST_REMOVE_AFTER ( curelm , field ) ; } TRASHIT ( * oldnext ) ; \
} while ( 0 ) *)
  { TODO : Unable to convert function-like macro: }
  (* SLIST_REMOVE_AFTER ( elm , field ) do { SLIST_NEXT ( elm , field ) = SLIST_NEXT ( SLIST_NEXT ( elm , field ) , field ) ; \
} while ( 0 ) *)
  { TODO : Unable to convert function-like macro: }
  (* SLIST_REMOVE_HEAD ( head , field ) do { SLIST_FIRST ( ( head ) ) = SLIST_NEXT ( SLIST_FIRST ( ( head ) ) , field ) ; \
} while ( 0 ) *)
  { TODO : Unable to convert function-like macro: }
  (* SLIST_SWAP ( head1 , head2 , type ) do { struct type * swap_first = SLIST_FIRST ( head1 ) ; SLIST_FIRST ( head1 ) = SLIST_FIRST ( head2 ) ; SLIST_FIRST ( head2 ) = swap_first ; \
} while ( 0 ) *)
  { TODO : Unable to convert function-like macro: }
  (* STAILQ_HEAD ( name , type ) struct name { struct type * stqh_first ; /* first element */ struct type * * stqh_last ; /* addr of last next element */ \
} *)
  { TODO : Unable to convert function-like macro: }
  (* STAILQ_HEAD_INITIALIZER ( head ) { NULL , & ( head ) . stqh_first } *)
  { TODO : Unable to convert function-like macro: }
  (* STAILQ_ENTRY ( type ) struct { struct type * stqe_next ; /* next element */ \
} *)
  { TODO : Unable to convert function-like macro: }
  (* STAILQ_CONCAT ( head1 , head2 ) do { if ( ! STAILQ_EMPTY ( ( head2 ) ) ) { * ( head1 ) -> stqh_last = ( head2 ) -> stqh_first ; ( head1 ) -> stqh_last = ( head2 ) -> stqh_last ; STAILQ_INIT ( ( head2 ) ) ; } \
} while ( 0 ) *)
  { TODO : Unable to convert function-like macro: }
  (* STAILQ_EMPTY ( head ) ( ( head ) -> stqh_first == NULL ) *)
  { TODO : Unable to convert function-like macro: }
  (* STAILQ_FIRST ( head ) ( ( head ) -> stqh_first ) *)
  { TODO : Unable to convert function-like macro: }
  (* STAILQ_FOREACH ( var , head , field ) for ( ( var ) = STAILQ_FIRST ( ( head ) ) ; ( var ) ; ( var ) = STAILQ_NEXT ( ( var ) , field ) ) *)
  { TODO : Unable to convert function-like macro: }
  (* STAILQ_FOREACH_FROM ( var , head , field ) for ( ( var ) = ( ( var ) ? ( var ) : STAILQ_FIRST ( ( head ) ) ) ; ( var ) ; ( var ) = STAILQ_NEXT ( ( var ) , field ) ) *)
  { TODO : Unable to convert function-like macro: }
  (* STAILQ_FOREACH_SAFE ( var , head , field , tvar ) for ( ( var ) = STAILQ_FIRST ( ( head ) ) ; ( var ) && ( ( tvar ) = STAILQ_NEXT ( ( var ) , field ) , 1 ) ; ( var ) = ( tvar ) ) *)
  { TODO : Unable to convert function-like macro: }
  (* STAILQ_FOREACH_FROM_SAFE ( var , head , field , tvar ) for ( ( var ) = ( ( var ) ? ( var ) : STAILQ_FIRST ( ( head ) ) ) ; ( var ) && ( ( tvar ) = STAILQ_NEXT ( ( var ) , field ) , 1 ) ; ( var ) = ( tvar ) ) *)
  { TODO : Unable to convert function-like macro: }
  (* STAILQ_INIT ( head ) do { STAILQ_FIRST ( ( head ) ) = NULL ; ( head ) -> stqh_last = & STAILQ_FIRST ( ( head ) ) ; \
} while ( 0 ) *)
  { TODO : Unable to convert function-like macro: }
  (* STAILQ_INSERT_AFTER ( head , tqelm , elm , field ) do { if ( ( STAILQ_NEXT ( ( elm ) , field ) = STAILQ_NEXT ( ( tqelm ) , field ) ) == NULL ) ( head ) -> stqh_last = & STAILQ_NEXT ( ( elm ) , field ) ; STAILQ_NEXT ( ( tqelm ) , field ) = ( elm ) ; \
} while ( 0 ) *)
  { TODO : Unable to convert function-like macro: }
  (* STAILQ_INSERT_HEAD ( head , elm , field ) do { if ( ( STAILQ_NEXT ( ( elm ) , field ) = STAILQ_FIRST ( ( head ) ) ) == NULL ) ( head ) -> stqh_last = & STAILQ_NEXT ( ( elm ) , field ) ; STAILQ_FIRST ( ( head ) ) = ( elm ) ; \
} while ( 0 ) *)
  { TODO : Unable to convert function-like macro: }
  (* STAILQ_INSERT_TAIL ( head , elm , field ) do { STAILQ_NEXT ( ( elm ) , field ) = NULL ; * ( head ) -> stqh_last = ( elm ) ; ( head ) -> stqh_last = & STAILQ_NEXT ( ( elm ) , field ) ; \
} while ( 0 ) *)
  { TODO : Unable to convert function-like macro: }
  (* STAILQ_LAST ( head , type , field ) ( STAILQ_EMPTY ( ( head ) ) ? NULL : __containerof ( ( head ) -> stqh_last , struct type , field . stqe_next ) ) *)
  { TODO : Unable to convert function-like macro: }
  (* STAILQ_NEXT ( elm , field ) ( ( elm ) -> field . stqe_next ) *)
  { TODO : Unable to convert function-like macro: }
  (* STAILQ_REMOVE ( head , elm , type , field ) do { QMD_SAVELINK ( oldnext , ( elm ) -> field . stqe_next ) ; if ( STAILQ_FIRST ( ( head ) ) == ( elm ) ) { STAILQ_REMOVE_HEAD ( ( head ) , field ) ; } else { struct type * curelm = STAILQ_FIRST ( ( head ) ) ; while ( STAILQ_NEXT ( curelm , field ) != ( elm ) ) curelm = STAILQ_NEXT ( curelm , field ) ; STAILQ_REMOVE_AFTER ( head , curelm , field ) ; } TRASHIT ( * oldnext ) ; \
} while ( 0 ) *)
  { TODO : Unable to convert function-like macro: }
  (* STAILQ_REMOVE_AFTER ( head , elm , field ) do { if ( ( STAILQ_NEXT ( elm , field ) = STAILQ_NEXT ( STAILQ_NEXT ( elm , field ) , field ) ) == NULL ) ( head ) -> stqh_last = & STAILQ_NEXT ( ( elm ) , field ) ; \
} while ( 0 ) *)
  { TODO : Unable to convert function-like macro: }
  (* STAILQ_REMOVE_HEAD ( head , field ) do { if ( ( STAILQ_FIRST ( ( head ) ) = STAILQ_NEXT ( STAILQ_FIRST ( ( head ) ) , field ) ) == NULL ) ( head ) -> stqh_last = & STAILQ_FIRST ( ( head ) ) ; \
} while ( 0 ) *)
  { TODO : Unable to convert function-like macro: }
  (* STAILQ_SWAP ( head1 , head2 , type ) do { struct type * swap_first = STAILQ_FIRST ( head1 ) ; struct type * * swap_last = ( head1 ) -> stqh_last ; STAILQ_FIRST ( head1 ) = STAILQ_FIRST ( head2 ) ; ( head1 ) -> stqh_last = ( head2 ) -> stqh_last ; STAILQ_FIRST ( head2 ) = swap_first ; ( head2 ) -> stqh_last = swap_last ; if ( STAILQ_EMPTY ( head1 ) ) ( head1 ) -> stqh_last = & STAILQ_FIRST ( head1 ) ; if ( STAILQ_EMPTY ( head2 ) ) ( head2 ) -> stqh_last = & STAILQ_FIRST ( head2 ) ; \
} while ( 0 ) *)
  { TODO : Unable to convert function-like macro: }
  (* LIST_HEAD ( name , type ) struct name { struct type * lh_first ; /* first element */ \
} *)
  { TODO : Unable to convert function-like macro: }
  (* LIST_HEAD_INITIALIZER ( head ) { NULL } *)
  { TODO : Unable to convert function-like macro: }
  (* LIST_ENTRY ( type ) struct { struct type * le_next ; /* next element */ struct type * * le_prev ; /* address of previous next element */ \
} *)
  { TODO : Unable to convert function-like macro: }
  (* QMD_LIST_CHECK_HEAD ( head , field ) *)
  { TODO : Unable to convert function-like macro: }
  (* QMD_LIST_CHECK_NEXT ( elm , field ) *)
  { TODO : Unable to convert function-like macro: }
  (* QMD_LIST_CHECK_PREV ( elm , field ) *)
  { TODO : Unable to convert function-like macro: }
  (* LIST_EMPTY ( head ) ( ( head ) -> lh_first == NULL ) *)
  { TODO : Unable to convert function-like macro: }
  (* LIST_FIRST ( head ) ( ( head ) -> lh_first ) *)
  { TODO : Unable to convert function-like macro: }
  (* LIST_FOREACH ( var , head , field ) for ( ( var ) = LIST_FIRST ( ( head ) ) ; ( var ) ; ( var ) = LIST_NEXT ( ( var ) , field ) ) *)
  { TODO : Unable to convert function-like macro: }
  (* LIST_FOREACH_FROM ( var , head , field ) for ( ( var ) = ( ( var ) ? ( var ) : LIST_FIRST ( ( head ) ) ) ; ( var ) ; ( var ) = LIST_NEXT ( ( var ) , field ) ) *)
  { TODO : Unable to convert function-like macro: }
  (* LIST_FOREACH_SAFE ( var , head , field , tvar ) for ( ( var ) = LIST_FIRST ( ( head ) ) ; ( var ) && ( ( tvar ) = LIST_NEXT ( ( var ) , field ) , 1 ) ; ( var ) = ( tvar ) ) *)
  { TODO : Unable to convert function-like macro: }
  (* LIST_FOREACH_FROM_SAFE ( var , head , field , tvar ) for ( ( var ) = ( ( var ) ? ( var ) : LIST_FIRST ( ( head ) ) ) ; ( var ) && ( ( tvar ) = LIST_NEXT ( ( var ) , field ) , 1 ) ; ( var ) = ( tvar ) ) *)
  { TODO : Unable to convert function-like macro: }
  (* LIST_INIT ( head ) do { LIST_FIRST ( ( head ) ) = NULL ; \
} while ( 0 ) *)
  { TODO : Unable to convert function-like macro: }
  (* LIST_INSERT_AFTER ( listelm , elm , field ) do { QMD_LIST_CHECK_NEXT ( listelm , field ) ; if ( ( LIST_NEXT ( ( elm ) , field ) = LIST_NEXT ( ( listelm ) , field ) ) != NULL ) LIST_NEXT ( ( listelm ) , field ) -> field . le_prev = & LIST_NEXT ( ( elm ) , field ) ; LIST_NEXT ( ( listelm ) , field ) = ( elm ) ; ( elm ) -> field . le_prev = & LIST_NEXT ( ( listelm ) , field ) ; \
} while ( 0 ) *)
  { TODO : Unable to convert function-like macro: }
  (* LIST_INSERT_BEFORE ( listelm , elm , field ) do { QMD_LIST_CHECK_PREV ( listelm , field ) ; ( elm ) -> field . le_prev = ( listelm ) -> field . le_prev ; LIST_NEXT ( ( elm ) , field ) = ( listelm ) ; * ( listelm ) -> field . le_prev = ( elm ) ; ( listelm ) -> field . le_prev = & LIST_NEXT ( ( elm ) , field ) ; \
} while ( 0 ) *)
  { TODO : Unable to convert function-like macro: }
  (* LIST_INSERT_HEAD ( head , elm , field ) do { QMD_LIST_CHECK_HEAD ( ( head ) , field ) ; if ( ( LIST_NEXT ( ( elm ) , field ) = LIST_FIRST ( ( head ) ) ) != NULL ) LIST_FIRST ( ( head ) ) -> field . le_prev = & LIST_NEXT ( ( elm ) , field ) ; LIST_FIRST ( ( head ) ) = ( elm ) ; ( elm ) -> field . le_prev = & LIST_FIRST ( ( head ) ) ; \
} while ( 0 ) *)
  { TODO : Unable to convert function-like macro: }
  (* LIST_NEXT ( elm , field ) ( ( elm ) -> field . le_next ) *)
  { TODO : Unable to convert function-like macro: }
  (* LIST_PREV ( elm , head , type , field ) ( ( elm ) -> field . le_prev == & LIST_FIRST ( ( head ) ) ? NULL : __containerof ( ( elm ) -> field . le_prev , struct type , field . le_next ) ) *)
  { TODO : Unable to convert function-like macro: }
  (* LIST_REMOVE ( elm , field ) do { QMD_SAVELINK ( oldnext , ( elm ) -> field . le_next ) ; QMD_SAVELINK ( oldprev , ( elm ) -> field . le_prev ) ; QMD_LIST_CHECK_NEXT ( elm , field ) ; QMD_LIST_CHECK_PREV ( elm , field ) ; if ( LIST_NEXT ( ( elm ) , field ) != NULL ) LIST_NEXT ( ( elm ) , field ) -> field . le_prev = ( elm ) -> field . le_prev ; * ( elm ) -> field . le_prev = LIST_NEXT ( ( elm ) , field ) ; TRASHIT ( * oldnext ) ; TRASHIT ( * oldprev ) ; \
} while ( 0 ) *)
  { TODO : Unable to convert function-like macro: }
  (* LIST_SWAP ( head1 , head2 , type , field ) do { struct type * swap_tmp = LIST_FIRST ( ( head1 ) ) ; LIST_FIRST ( ( head1 ) ) = LIST_FIRST ( ( head2 ) ) ; LIST_FIRST ( ( head2 ) ) = swap_tmp ; if ( ( swap_tmp = LIST_FIRST ( ( head1 ) ) ) != NULL ) swap_tmp -> field . le_prev = & LIST_FIRST ( ( head1 ) ) ; if ( ( swap_tmp = LIST_FIRST ( ( head2 ) ) ) != NULL ) swap_tmp -> field . le_prev = & LIST_FIRST ( ( head2 ) ) ; \
} while ( 0 ) *)
  { TODO : Unable to convert function-like macro: }
  (* TAILQ_HEAD ( name , type ) struct name { struct type * tqh_first ; /* first element */ struct type * * tqh_last ; /* addr of last next element */ TRACEBUF \
} *)
  { TODO : Unable to convert function-like macro: }
  (* TAILQ_HEAD_INITIALIZER ( head ) { NULL , & ( head ) . tqh_first , TRACEBUF_INITIALIZER } *)
  { TODO : Unable to convert function-like macro: }
  (* TAILQ_ENTRY ( type ) struct { struct type * tqe_next ; /* next element */ struct type * * tqe_prev ; /* address of previous next element */ TRACEBUF \
} *)
  { TODO : Unable to convert function-like macro: }
  (* QMD_TAILQ_CHECK_HEAD ( head , field ) *)
  { TODO : Unable to convert function-like macro: }
  (* QMD_TAILQ_CHECK_TAIL ( head , headname ) *)
  { TODO : Unable to convert function-like macro: }
  (* QMD_TAILQ_CHECK_NEXT ( elm , field ) *)
  { TODO : Unable to convert function-like macro: }
  (* QMD_TAILQ_CHECK_PREV ( elm , field ) *)
  { TODO : Unable to convert function-like macro: }
  (* TAILQ_CONCAT ( head1 , head2 , field ) do { if ( ! TAILQ_EMPTY ( head2 ) ) { * ( head1 ) -> tqh_last = ( head2 ) -> tqh_first ; ( head2 ) -> tqh_first -> field . tqe_prev = ( head1 ) -> tqh_last ; ( head1 ) -> tqh_last = ( head2 ) -> tqh_last ; TAILQ_INIT ( ( head2 ) ) ; QMD_TRACE_HEAD ( head1 ) ; QMD_TRACE_HEAD ( head2 ) ; } \
} while ( 0 ) *)
  { TODO : Unable to convert function-like macro: }
  (* TAILQ_EMPTY ( head ) ( ( head ) -> tqh_first == NULL ) *)
  { TODO : Unable to convert function-like macro: }
  (* TAILQ_FIRST ( head ) ( ( head ) -> tqh_first ) *)
  { TODO : Unable to convert function-like macro: }
  (* TAILQ_FOREACH ( var , head , field ) for ( ( var ) = TAILQ_FIRST ( ( head ) ) ; ( var ) ; ( var ) = TAILQ_NEXT ( ( var ) , field ) ) *)
  { TODO : Unable to convert function-like macro: }
  (* TAILQ_FOREACH_FROM ( var , head , field ) for ( ( var ) = ( ( var ) ? ( var ) : TAILQ_FIRST ( ( head ) ) ) ; ( var ) ; ( var ) = TAILQ_NEXT ( ( var ) , field ) ) *)
  { TODO : Unable to convert function-like macro: }
  (* TAILQ_FOREACH_SAFE ( var , head , field , tvar ) for ( ( var ) = TAILQ_FIRST ( ( head ) ) ; ( var ) && ( ( tvar ) = TAILQ_NEXT ( ( var ) , field ) , 1 ) ; ( var ) = ( tvar ) ) *)
  { TODO : Unable to convert function-like macro: }
  (* TAILQ_FOREACH_FROM_SAFE ( var , head , field , tvar ) for ( ( var ) = ( ( var ) ? ( var ) : TAILQ_FIRST ( ( head ) ) ) ; ( var ) && ( ( tvar ) = TAILQ_NEXT ( ( var ) , field ) , 1 ) ; ( var ) = ( tvar ) ) *)
  { TODO : Unable to convert function-like macro: }
  (* TAILQ_FOREACH_REVERSE ( var , head , headname , field ) for ( ( var ) = TAILQ_LAST ( ( head ) , headname ) ; ( var ) ; ( var ) = TAILQ_PREV ( ( var ) , headname , field ) ) *)
  { TODO : Unable to convert function-like macro: }
  (* TAILQ_FOREACH_REVERSE_FROM ( var , head , headname , field ) for ( ( var ) = ( ( var ) ? ( var ) : TAILQ_LAST ( ( head ) , headname ) ) ; ( var ) ; ( var ) = TAILQ_PREV ( ( var ) , headname , field ) ) *)
  { TODO : Unable to convert function-like macro: }
  (* TAILQ_FOREACH_REVERSE_SAFE ( var , head , headname , field , tvar ) for ( ( var ) = TAILQ_LAST ( ( head ) , headname ) ; ( var ) && ( ( tvar ) = TAILQ_PREV ( ( var ) , headname , field ) , 1 ) ; ( var ) = ( tvar ) ) *)
  { TODO : Unable to convert function-like macro: }
  (* TAILQ_FOREACH_REVERSE_FROM_SAFE ( var , head , headname , field , tvar ) for ( ( var ) = ( ( var ) ? ( var ) : TAILQ_LAST ( ( head ) , headname ) ) ; ( var ) && ( ( tvar ) = TAILQ_PREV ( ( var ) , headname , field ) , 1 ) ; ( var ) = ( tvar ) ) *)
  { TODO : Unable to convert function-like macro: }
  (* TAILQ_INIT ( head ) do { TAILQ_FIRST ( ( head ) ) = NULL ; ( head ) -> tqh_last = & TAILQ_FIRST ( ( head ) ) ; QMD_TRACE_HEAD ( head ) ; \
} while ( 0 ) *)
  { TODO : Unable to convert function-like macro: }
  (* TAILQ_INSERT_AFTER ( head , listelm , elm , field ) do { QMD_TAILQ_CHECK_NEXT ( listelm , field ) ; if ( ( TAILQ_NEXT ( ( elm ) , field ) = TAILQ_NEXT ( ( listelm ) , field ) ) != NULL ) TAILQ_NEXT ( ( elm ) , field ) -> field . tqe_prev = & TAILQ_NEXT ( ( elm ) , field ) ; else { ( head ) -> tqh_last = & TAILQ_NEXT ( ( elm ) , field ) ; QMD_TRACE_HEAD ( head ) ; } TAILQ_NEXT ( ( listelm ) , field ) = ( elm ) ; ( elm ) -> field . tqe_prev = & TAILQ_NEXT ( ( listelm ) , field ) ; QMD_TRACE_ELEM ( & ( elm ) -> field ) ; QMD_TRACE_ELEM ( & listelm -> field ) ; \
} while ( 0 ) *)
  { TODO : Unable to convert function-like macro: }
  (* TAILQ_INSERT_BEFORE ( listelm , elm , field ) do { QMD_TAILQ_CHECK_PREV ( listelm , field ) ; ( elm ) -> field . tqe_prev = ( listelm ) -> field . tqe_prev ; TAILQ_NEXT ( ( elm ) , field ) = ( listelm ) ; * ( listelm ) -> field . tqe_prev = ( elm ) ; ( listelm ) -> field . tqe_prev = & TAILQ_NEXT ( ( elm ) , field ) ; QMD_TRACE_ELEM ( & ( elm ) -> field ) ; QMD_TRACE_ELEM ( & listelm -> field ) ; \
} while ( 0 ) *)
  { TODO : Unable to convert function-like macro: }
  (* TAILQ_INSERT_HEAD ( head , elm , field ) do { QMD_TAILQ_CHECK_HEAD ( head , field ) ; if ( ( TAILQ_NEXT ( ( elm ) , field ) = TAILQ_FIRST ( ( head ) ) ) != NULL ) TAILQ_FIRST ( ( head ) ) -> field . tqe_prev = & TAILQ_NEXT ( ( elm ) , field ) ; else ( head ) -> tqh_last = & TAILQ_NEXT ( ( elm ) , field ) ; TAILQ_FIRST ( ( head ) ) = ( elm ) ; ( elm ) -> field . tqe_prev = & TAILQ_FIRST ( ( head ) ) ; QMD_TRACE_HEAD ( head ) ; QMD_TRACE_ELEM ( & ( elm ) -> field ) ; \
} while ( 0 ) *)
  { TODO : Unable to convert function-like macro: }
  (* TAILQ_INSERT_TAIL ( head , elm , field ) do { QMD_TAILQ_CHECK_TAIL ( head , field ) ; TAILQ_NEXT ( ( elm ) , field ) = NULL ; ( elm ) -> field . tqe_prev = ( head ) -> tqh_last ; * ( head ) -> tqh_last = ( elm ) ; ( head ) -> tqh_last = & TAILQ_NEXT ( ( elm ) , field ) ; QMD_TRACE_HEAD ( head ) ; QMD_TRACE_ELEM ( & ( elm ) -> field ) ; \
} while ( 0 ) *)
  { TODO : Unable to convert function-like macro: }
  (* TAILQ_LAST ( head , headname ) ( * ( ( ( struct headname * ) ( ( head ) -> tqh_last ) ) -> tqh_last ) ) *)
  { TODO : Unable to convert function-like macro: }
  (* TAILQ_NEXT ( elm , field ) ( ( elm ) -> field . tqe_next ) *)
  { TODO : Unable to convert function-like macro: }
  (* TAILQ_PREV ( elm , headname , field ) ( * ( ( ( struct headname * ) ( ( elm ) -> field . tqe_prev ) ) -> tqh_last ) ) *)
  { TODO : Unable to convert function-like macro: }
  (* TAILQ_REMOVE ( head , elm , field ) do { QMD_SAVELINK ( oldnext , ( elm ) -> field . tqe_next ) ; QMD_SAVELINK ( oldprev , ( elm ) -> field . tqe_prev ) ; QMD_TAILQ_CHECK_NEXT ( elm , field ) ; QMD_TAILQ_CHECK_PREV ( elm , field ) ; if ( ( TAILQ_NEXT ( ( elm ) , field ) ) != NULL ) TAILQ_NEXT ( ( elm ) , field ) -> field . tqe_prev = ( elm ) -> field . tqe_prev ; else { ( head ) -> tqh_last = ( elm ) -> field . tqe_prev ; QMD_TRACE_HEAD ( head ) ; } * ( elm ) -> field . tqe_prev = TAILQ_NEXT ( ( elm ) , field ) ; TRASHIT ( * oldnext ) ; TRASHIT ( * oldprev ) ; QMD_TRACE_ELEM ( & ( elm ) -> field ) ; \
} while ( 0 ) *)
  { TODO : Unable to convert function-like macro: }
  (* TAILQ_SWAP ( head1 , head2 , type , field ) do { struct type * swap_first = ( head1 ) -> tqh_first ; struct type * * swap_last = ( head1 ) -> tqh_last ; ( head1 ) -> tqh_first = ( head2 ) -> tqh_first ; ( head1 ) -> tqh_last = ( head2 ) -> tqh_last ; ( head2 ) -> tqh_first = swap_first ; ( head2 ) -> tqh_last = swap_last ; if ( ( swap_first = ( head1 ) -> tqh_first ) != NULL ) swap_first -> field . tqe_prev = & ( head1 ) -> tqh_first ; else ( head1 ) -> tqh_last = & ( head1 ) -> tqh_first ; if ( ( swap_first = ( head2 ) -> tqh_first ) != NULL ) swap_first -> field . tqe_prev = & ( head2 ) -> tqh_first ; else ( head2 ) -> tqh_last = & ( head2 ) -> tqh_first ; \
} while ( 0 ) *)
  { TODO : Unable to convert function-like macro: }
  (* SPLAY_HEAD ( name , type ) struct name { struct type * sph_root ; /* root of the tree */ \
} *)
  { TODO : Unable to convert function-like macro: }
  (* SPLAY_INITIALIZER ( root ) { NULL } *)
  { TODO : Unable to convert function-like macro: }
  (* SPLAY_INIT ( root ) do { ( root ) -> sph_root = NULL ; \
} while ( /*CONSTCOND*/ 0 ) *)
  { TODO : Unable to convert function-like macro: }
  (* SPLAY_ENTRY ( type ) struct { struct type * spe_left ; /* left element */ struct type * spe_right ; /* right element */ \
} *)
  { TODO : Unable to convert function-like macro: }
  (* SPLAY_LEFT ( elm , field ) ( elm ) -> field . spe_left *)
  { TODO : Unable to convert function-like macro: }
  (* SPLAY_RIGHT ( elm , field ) ( elm ) -> field . spe_right *)
  { TODO : Unable to convert function-like macro: }
  (* SPLAY_ROOT ( head ) ( head ) -> sph_root *)
  { TODO : Unable to convert function-like macro: }
  (* SPLAY_EMPTY ( head ) ( SPLAY_ROOT ( head ) == NULL ) *)
  { TODO : Unable to convert function-like macro: }
  (* SPLAY_ROTATE_RIGHT ( head , tmp , field ) do { SPLAY_LEFT ( ( head ) -> sph_root , field ) = SPLAY_RIGHT ( tmp , field ) ; SPLAY_RIGHT ( tmp , field ) = ( head ) -> sph_root ; ( head ) -> sph_root = tmp ; \
} while ( /*CONSTCOND*/ 0 ) *)
  { TODO : Unable to convert function-like macro: }
  (* SPLAY_ROTATE_LEFT ( head , tmp , field ) do { SPLAY_RIGHT ( ( head ) -> sph_root , field ) = SPLAY_LEFT ( tmp , field ) ; SPLAY_LEFT ( tmp , field ) = ( head ) -> sph_root ; ( head ) -> sph_root = tmp ; \
} while ( /*CONSTCOND*/ 0 ) *)
  { TODO : Unable to convert function-like macro: }
  (* SPLAY_LINKLEFT ( head , tmp , field ) do { SPLAY_LEFT ( tmp , field ) = ( head ) -> sph_root ; tmp = ( head ) -> sph_root ; ( head ) -> sph_root = SPLAY_LEFT ( ( head ) -> sph_root , field ) ; \
} while ( /*CONSTCOND*/ 0 ) *)
  { TODO : Unable to convert function-like macro: }
  (* SPLAY_LINKRIGHT ( head , tmp , field ) do { SPLAY_RIGHT ( tmp , field ) = ( head ) -> sph_root ; tmp = ( head ) -> sph_root ; ( head ) -> sph_root = SPLAY_RIGHT ( ( head ) -> sph_root , field ) ; \
} while ( /*CONSTCOND*/ 0 ) *)
  { TODO : Unable to convert function-like macro: }
  (* SPLAY_ASSEMBLE ( head , node , left , right , field ) do { SPLAY_RIGHT ( left , field ) = SPLAY_LEFT ( ( head ) -> sph_root , field ) ; SPLAY_LEFT ( right , field ) = SPLAY_RIGHT ( ( head ) -> sph_root , field ) ; SPLAY_LEFT ( ( head ) -> sph_root , field ) = SPLAY_RIGHT ( node , field ) ; SPLAY_RIGHT ( ( head ) -> sph_root , field ) = SPLAY_LEFT ( node , field ) ; \
} while ( /*CONSTCOND*/ 0 ) *)
  { TODO : Unable to convert function-like macro: }
  (* SPLAY_PROTOTYPE ( name , type , field , cmp ) void name ## _SPLAY ( struct name * , struct type * ) ; void name ## _SPLAY_MINMAX ( struct name * , int ) ; struct type * name ## _SPLAY_INSERT ( struct name * , struct type * ) ; struct type * name ## _SPLAY_REMOVE ( struct name * , struct type * ) ; \
/* Finds the node with the same key as elm */ static __inline struct type * name ## _SPLAY_FIND ( struct name * head , struct type * elm ) \
{ if ( SPLAY_EMPTY ( head ) ) return ( NULL ) ; name ## _SPLAY ( head , elm ) ; if ( ( cmp ) ( elm , ( head ) -> sph_root ) == 0 ) return ( head -> sph_root ) ; return ( NULL ) ; \
} static __inline struct type * name ## _SPLAY_NEXT ( struct name * head , struct type * elm ) \
{ name ## _SPLAY ( head , elm ) ; if ( SPLAY_RIGHT ( elm , field ) != NULL ) { elm = SPLAY_RIGHT ( elm , field ) ; while ( SPLAY_LEFT ( elm , field ) != NULL ) { elm = SPLAY_LEFT ( elm , field ) ; } } else elm = NULL ; return ( elm ) ; \
} static __inline struct type * name ## _SPLAY_MIN_MAX ( struct name * head , int val ) \
{ name ## _SPLAY_MINMAX ( head , val ) ; return ( SPLAY_ROOT ( head ) ) ; \
} *)
  { TODO : Unable to convert function-like macro: }
  (* SPLAY_GENERATE ( name , type , field , cmp ) struct type * name ## _SPLAY_INSERT ( struct name * head , struct type * elm ) \
{ if ( SPLAY_EMPTY ( head ) ) { SPLAY_LEFT ( elm , field ) = SPLAY_RIGHT ( elm , field ) = NULL ; } else { int __comp ; name ## _SPLAY ( head , elm ) ; __comp = ( cmp ) ( elm , ( head ) -> sph_root ) ; if ( __comp < 0 ) { SPLAY_LEFT ( elm , field ) = SPLAY_LEFT ( ( head ) -> sph_root , field ) ; SPLAY_RIGHT ( elm , field ) = ( head ) -> sph_root ; SPLAY_LEFT ( ( head ) -> sph_root , field ) = NULL ; } else if ( __comp > 0 ) { SPLAY_RIGHT ( elm , field ) = SPLAY_RIGHT ( ( head ) -> sph_root , field ) ; SPLAY_LEFT ( elm , field ) = ( head ) -> sph_root ; SPLAY_RIGHT ( ( head ) -> sph_root , field ) = NULL ; } else return ( ( head ) -> sph_root ) ; } ( head ) -> sph_root = ( elm ) ; return ( NULL ) ; \
} struct type * name ## _SPLAY_REMOVE ( struct name * head , struct type * elm ) \
{ struct type * __tmp ; if ( SPLAY_EMPTY ( head ) ) return ( NULL ) ; name ## _SPLAY ( head , elm ) ; if ( ( cmp ) ( elm , ( head ) -> sph_root ) == 0 ) { if ( SPLAY_LEFT ( ( head ) -> sph_root , field ) == NULL ) { ( head ) -> sph_root = SPLAY_RIGHT ( ( head ) -> sph_root , field ) ; } else { __tmp = SPLAY_RIGHT ( ( head ) -> sph_root , field ) ; ( head ) -> sph_root = SPLAY_LEFT ( ( head ) -> sph_root , field ) ; name ## _SPLAY ( head , elm ) ; SPLAY_RIGHT ( ( head ) -> sph_root , field ) = __tmp ; } return ( elm ) ; } return ( NULL ) ; \
} void name ## _SPLAY ( struct name * head , struct type * elm ) \
{ struct type __node , * __left , * __right , * __tmp ; int __comp ; SPLAY_LEFT ( & __node , field ) = SPLAY_RIGHT ( & __node , field ) = NULL ; __left = __right = & __node ; while ( ( __comp = ( cmp ) ( elm , ( head ) -> sph_root ) ) != 0 ) { if ( __comp < 0 ) { __tmp = SPLAY_LEFT ( ( head ) -> sph_root , field ) ; if ( __tmp == NULL ) break ; if ( ( cmp ) ( elm , __tmp ) < 0 ) { SPLAY_ROTATE_RIGHT ( head , __tmp , field ) ; if ( SPLAY_LEFT ( ( head ) -> sph_root , field ) == NULL ) break ; } SPLAY_LINKLEFT ( head , __right , field ) ; } else if ( __comp > 0 ) { __tmp = SPLAY_RIGHT ( ( head ) -> sph_root , field ) ; if ( __tmp == NULL ) break ; if ( ( cmp ) ( elm , __tmp ) > 0 ) { SPLAY_ROTATE_LEFT ( head , __tmp , field ) ; if ( SPLAY_RIGHT ( ( head ) -> sph_root , field ) == NULL ) break ; } SPLAY_LINKRIGHT ( head , __left , field ) ; } } SPLAY_ASSEMBLE ( head , & __node , __left , __right , field ) ; \
} \
/* Splay with either the minimum or the maximum element			\
 * Used to find minimum or maximum element in tree.			\
 */ void name ## _SPLAY_MINMAX ( struct name * head , int __comp ) \
{ struct type __node , * __left , * __right , * __tmp ; SPLAY_LEFT ( & __node , field ) = SPLAY_RIGHT ( & __node , field ) = NULL ; __left = __right = & __node ; while ( 1 ) { if ( __comp < 0 ) { __tmp = SPLAY_LEFT ( ( head ) -> sph_root , field ) ; if ( __tmp == NULL ) break ; if ( __comp < 0 ) { SPLAY_ROTATE_RIGHT ( head , __tmp , field ) ; if ( SPLAY_LEFT ( ( head ) -> sph_root , field ) == NULL ) break ; } SPLAY_LINKLEFT ( head , __right , field ) ; } else if ( __comp > 0 ) { __tmp = SPLAY_RIGHT ( ( head ) -> sph_root , field ) ; if ( __tmp == NULL ) break ; if ( __comp > 0 ) { SPLAY_ROTATE_LEFT ( head , __tmp , field ) ; if ( SPLAY_RIGHT ( ( head ) -> sph_root , field ) == NULL ) break ; } SPLAY_LINKRIGHT ( head , __left , field ) ; } } SPLAY_ASSEMBLE ( head , & __node , __left , __right , field ) ; \
} *)
  SPLAY_NEGINF = -1;
  SPLAY_INF = 1;
  { TODO : Unable to convert function-like macro: }
  (* SPLAY_INSERT ( name , x , y ) name ## _SPLAY_INSERT ( x , y ) *)
  { TODO : Unable to convert function-like macro: }
  (* SPLAY_REMOVE ( name , x , y ) name ## _SPLAY_REMOVE ( x , y ) *)
  { TODO : Unable to convert function-like macro: }
  (* SPLAY_FIND ( name , x , y ) name ## _SPLAY_FIND ( x , y ) *)
  { TODO : Unable to convert function-like macro: }
  (* SPLAY_NEXT ( name , x , y ) name ## _SPLAY_NEXT ( x , y ) *)
  { TODO : Unable to convert function-like macro: }
  (* SPLAY_MIN ( name , x ) ( SPLAY_EMPTY ( x ) ? NULL : name ## _SPLAY_MIN_MAX ( x , SPLAY_NEGINF ) ) *)
  { TODO : Unable to convert function-like macro: }
  (* SPLAY_MAX ( name , x ) ( SPLAY_EMPTY ( x ) ? NULL : name ## _SPLAY_MIN_MAX ( x , SPLAY_INF ) ) *)
  { TODO : Unable to convert function-like macro: }
  (* SPLAY_FOREACH ( x , name , head ) for ( ( x ) = SPLAY_MIN ( name , head ) ; ( x ) != NULL ; ( x ) = SPLAY_NEXT ( name , head , x ) ) *)
  { TODO : Unable to convert function-like macro: }
  (* RB_HEAD ( name , type ) struct name { struct type * rbh_root ; /* root of the tree */ \
} *)
  { TODO : Unable to convert function-like macro: }
  (* RB_INITIALIZER ( root ) { NULL } *)
  { TODO : Unable to convert function-like macro: }
  (* RB_INIT ( root ) do { ( root ) -> rbh_root = NULL ; \
} while ( /*CONSTCOND*/ 0 ) *)
  RB_BLACK = 0;
  RB_RED = 1;
  { TODO : Unable to convert function-like macro: }
  (* RB_ENTRY ( type ) struct { struct type * rbe_left ; /* left element */ struct type * rbe_right ; /* right element */ struct type * rbe_parent ; /* parent element */ int rbe_color ; /* node color */ \
} *)
  { TODO : Unable to convert function-like macro: }
  (* RB_LEFT ( elm , field ) ( elm ) -> field . rbe_left *)
  { TODO : Unable to convert function-like macro: }
  (* RB_RIGHT ( elm , field ) ( elm ) -> field . rbe_right *)
  { TODO : Unable to convert function-like macro: }
  (* RB_PARENT ( elm , field ) ( elm ) -> field . rbe_parent *)
  { TODO : Unable to convert function-like macro: }
  (* RB_COLOR ( elm , field ) ( elm ) -> field . rbe_color *)
  { TODO : Unable to convert function-like macro: }
  (* RB_ROOT ( head ) ( head ) -> rbh_root *)
  { TODO : Unable to convert function-like macro: }
  (* RB_EMPTY ( head ) ( RB_ROOT ( head ) == NULL ) *)
  { TODO : Unable to convert function-like macro: }
  (* RB_SET ( elm , parent , field ) do { RB_PARENT ( elm , field ) = parent ; RB_LEFT ( elm , field ) = RB_RIGHT ( elm , field ) = NULL ; RB_COLOR ( elm , field ) = RB_RED ; \
} while ( /*CONSTCOND*/ 0 ) *)
  { TODO : Unable to convert function-like macro: }
  (* RB_SET_BLACKRED ( black , red , field ) do { RB_COLOR ( black , field ) = RB_BLACK ; RB_COLOR ( red , field ) = RB_RED ; \
} while ( /*CONSTCOND*/ 0 ) *)
  { TODO : Unable to convert function-like macro: }
  (* RB_AUGMENT ( x ) do { } while ( 0 ) *)
  { TODO : Unable to convert function-like macro: }
  (* RB_ROTATE_LEFT ( head , elm , tmp , field ) do { ( tmp ) = RB_RIGHT ( elm , field ) ; if ( ( RB_RIGHT ( elm , field ) = RB_LEFT ( tmp , field ) ) != NULL ) { RB_PARENT ( RB_LEFT ( tmp , field ) , field ) = ( elm ) ; } RB_AUGMENT ( elm ) ; if ( ( RB_PARENT ( tmp , field ) = RB_PARENT ( elm , field ) ) != NULL ) { if ( ( elm ) == RB_LEFT ( RB_PARENT ( elm , field ) , field ) ) RB_LEFT ( RB_PARENT ( elm , field ) , field ) = ( tmp ) ; else RB_RIGHT ( RB_PARENT ( elm , field ) , field ) = ( tmp ) ; } else ( head ) -> rbh_root = ( tmp ) ; RB_LEFT ( tmp , field ) = ( elm ) ; RB_PARENT ( elm , field ) = ( tmp ) ; RB_AUGMENT ( tmp ) ; if ( ( RB_PARENT ( tmp , field ) ) ) RB_AUGMENT ( RB_PARENT ( tmp , field ) ) ; \
} while ( /*CONSTCOND*/ 0 ) *)
  { TODO : Unable to convert function-like macro: }
  (* RB_ROTATE_RIGHT ( head , elm , tmp , field ) do { ( tmp ) = RB_LEFT ( elm , field ) ; if ( ( RB_LEFT ( elm , field ) = RB_RIGHT ( tmp , field ) ) != NULL ) { RB_PARENT ( RB_RIGHT ( tmp , field ) , field ) = ( elm ) ; } RB_AUGMENT ( elm ) ; if ( ( RB_PARENT ( tmp , field ) = RB_PARENT ( elm , field ) ) != NULL ) { if ( ( elm ) == RB_LEFT ( RB_PARENT ( elm , field ) , field ) ) RB_LEFT ( RB_PARENT ( elm , field ) , field ) = ( tmp ) ; else RB_RIGHT ( RB_PARENT ( elm , field ) , field ) = ( tmp ) ; } else ( head ) -> rbh_root = ( tmp ) ; RB_RIGHT ( tmp , field ) = ( elm ) ; RB_PARENT ( elm , field ) = ( tmp ) ; RB_AUGMENT ( tmp ) ; if ( ( RB_PARENT ( tmp , field ) ) ) RB_AUGMENT ( RB_PARENT ( tmp , field ) ) ; \
} while ( /*CONSTCOND*/ 0 ) *)
  { TODO : Unable to convert function-like macro: }
  (* RB_PROTOTYPE ( name , type , field , cmp ) RB_PROTOTYPE_INTERNAL ( name , type , field , cmp , ) *)
  { TODO : Unable to convert function-like macro: }
  (* RB_PROTOTYPE_STATIC ( name , type , field , cmp ) RB_PROTOTYPE_INTERNAL ( name , type , field , cmp , __unused static ) *)
  { TODO : Unable to convert function-like macro: }
  (* RB_PROTOTYPE_INTERNAL ( name , type , field , cmp , attr ) RB_PROTOTYPE_INSERT_COLOR ( name , type , attr ) ; RB_PROTOTYPE_REMOVE_COLOR ( name , type , attr ) ; RB_PROTOTYPE_INSERT ( name , type , attr ) ; RB_PROTOTYPE_REMOVE ( name , type , attr ) ; RB_PROTOTYPE_FIND ( name , type , attr ) ; RB_PROTOTYPE_NFIND ( name , type , attr ) ; RB_PROTOTYPE_NEXT ( name , type , attr ) ; RB_PROTOTYPE_PREV ( name , type , attr ) ; RB_PROTOTYPE_MINMAX ( name , type , attr ) ; *)
  { TODO : Unable to convert function-like macro: }
  (* RB_PROTOTYPE_INSERT_COLOR ( name , type , attr ) attr void name ## _RB_INSERT_COLOR ( struct name * , struct type * ) *)
  { TODO : Unable to convert function-like macro: }
  (* RB_PROTOTYPE_REMOVE_COLOR ( name , type , attr ) attr void name ## _RB_REMOVE_COLOR ( struct name * , struct type * , struct type * ) *)
  { TODO : Unable to convert function-like macro: }
  (* RB_PROTOTYPE_REMOVE ( name , type , attr ) attr struct type * name ## _RB_REMOVE ( struct name * , struct type * ) *)
  { TODO : Unable to convert function-like macro: }
  (* RB_PROTOTYPE_INSERT ( name , type , attr ) attr struct type * name ## _RB_INSERT ( struct name * , struct type * ) *)
  { TODO : Unable to convert function-like macro: }
  (* RB_PROTOTYPE_FIND ( name , type , attr ) attr struct type * name ## _RB_FIND ( struct name * , struct type * ) *)
  { TODO : Unable to convert function-like macro: }
  (* RB_PROTOTYPE_NFIND ( name , type , attr ) attr struct type * name ## _RB_NFIND ( struct name * , struct type * ) *)
  { TODO : Unable to convert function-like macro: }
  (* RB_PROTOTYPE_NEXT ( name , type , attr ) attr struct type * name ## _RB_NEXT ( struct type * ) *)
  { TODO : Unable to convert function-like macro: }
  (* RB_PROTOTYPE_PREV ( name , type , attr ) attr struct type * name ## _RB_PREV ( struct type * ) *)
  { TODO : Unable to convert function-like macro: }
  (* RB_PROTOTYPE_MINMAX ( name , type , attr ) attr struct type * name ## _RB_MINMAX ( struct name * , int ) *)
  { TODO : Unable to convert function-like macro: }
  (* RB_GENERATE ( name , type , field , cmp ) RB_GENERATE_INTERNAL ( name , type , field , cmp , ) *)
  { TODO : Unable to convert function-like macro: }
  (* RB_GENERATE_STATIC ( name , type , field , cmp ) RB_GENERATE_INTERNAL ( name , type , field , cmp , __unused static ) *)
  { TODO : Unable to convert function-like macro: }
  (* RB_GENERATE_INTERNAL ( name , type , field , cmp , attr ) RB_GENERATE_INSERT_COLOR ( name , type , field , attr ) RB_GENERATE_REMOVE_COLOR ( name , type , field , attr ) RB_GENERATE_INSERT ( name , type , field , cmp , attr ) RB_GENERATE_REMOVE ( name , type , field , attr ) RB_GENERATE_FIND ( name , type , field , cmp , attr ) RB_GENERATE_NFIND ( name , type , field , cmp , attr ) RB_GENERATE_NEXT ( name , type , field , attr ) RB_GENERATE_PREV ( name , type , field , attr ) RB_GENERATE_MINMAX ( name , type , field , attr ) *)
  { TODO : Unable to convert function-like macro: }
  (* RB_GENERATE_INSERT_COLOR ( name , type , field , attr ) attr void name ## _RB_INSERT_COLOR ( struct name * head , struct type * elm ) \
{ struct type * parent , * gparent , * tmp ; while ( ( parent = RB_PARENT ( elm , field ) ) != NULL && RB_COLOR ( parent , field ) == RB_RED ) { gparent = RB_PARENT ( parent , field ) ; if ( parent == RB_LEFT ( gparent , field ) ) { tmp = RB_RIGHT ( gparent , field ) ; if ( tmp && RB_COLOR ( tmp , field ) == RB_RED ) { RB_COLOR ( tmp , field ) = RB_BLACK ; RB_SET_BLACKRED ( parent , gparent , field ) ; elm = gparent ; continue ; } if ( RB_RIGHT ( parent , field ) == elm ) { RB_ROTATE_LEFT ( head , parent , tmp , field ) ; tmp = parent ; parent = elm ; elm = tmp ; } RB_SET_BLACKRED ( parent , gparent , field ) ; RB_ROTATE_RIGHT ( head , gparent , tmp , field ) ; } else { tmp = RB_LEFT ( gparent , field ) ; if ( tmp && RB_COLOR ( tmp , field ) == RB_RED ) { RB_COLOR ( tmp , field ) = RB_BLACK ; RB_SET_BLACKRED ( parent , gparent , field ) ; elm = gparent ; continue ; } if ( RB_LEFT ( parent , field ) == elm ) { RB_ROTATE_RIGHT ( head , parent , tmp , field ) ; tmp = parent ; parent = elm ; elm = tmp ; } RB_SET_
} *)
  { TODO : Unable to convert function-like macro: }
  (* RB_GENERATE_REMOVE_COLOR ( name , type , field , attr ) attr void name ## _RB_REMOVE_COLOR ( struct name * head , struct type * parent , struct type * elm ) \
{ struct type * tmp ; while ( ( elm == NULL || RB_COLOR ( elm , field ) == RB_BLACK ) && elm != RB_ROOT ( head ) ) { if ( RB_LEFT ( parent , field ) == elm ) { tmp = RB_RIGHT ( parent , field ) ; if ( RB_COLOR ( tmp , field ) == RB_RED ) { RB_SET_BLACKRED ( tmp , parent , field ) ; RB_ROTATE_LEFT ( head , parent , tmp , field ) ; tmp = RB_RIGHT ( parent , field ) ; } if ( ( RB_LEFT ( tmp , field ) == NULL || RB_COLOR ( RB_LEFT ( tmp , field ) , field ) == RB_BLACK ) && ( RB_RIGHT ( tmp , field ) == NULL || RB_COLOR ( RB_RIGHT ( tmp , field ) , field ) == RB_BLACK ) ) { RB_COLOR ( tmp , field ) = RB_RED ; elm = parent ; parent = RB_PARENT ( elm , field ) ; } else { if ( RB_RIGHT ( tmp , field ) == NULL || RB_COLOR ( RB_RIGHT ( tmp , field ) , field ) == RB_BLACK ) { struct type * oleft ; if ( ( oleft = RB_LEFT ( tmp , field ) ) != NULL ) RB_COLOR ( oleft , field ) = RB_BLACK ; RB_COLOR ( tmp , field ) = RB_RED ; RB_ROTATE_RIGHT ( head , tmp , oleft , field ) ; tmp = RB_RIGHT ( parent , field ) ; } RB_COLOR ( t
} *)
  { TODO : Unable to convert function-like macro: }
  (* RB_GENERATE_REMOVE ( name , type , field , attr ) attr struct type * name ## _RB_REMOVE ( struct name * head , struct type * elm ) \
{ struct type * child , * parent , * old = elm ; int color ; if ( RB_LEFT ( elm , field ) == NULL ) child = RB_RIGHT ( elm , field ) ; else if ( RB_RIGHT ( elm , field ) == NULL ) child = RB_LEFT ( elm , field ) ; else { struct type * left ; elm = RB_RIGHT ( elm , field ) ; while ( ( left = RB_LEFT ( elm , field ) ) != NULL ) elm = left ; child = RB_RIGHT ( elm , field ) ; parent = RB_PARENT ( elm , field ) ; color = RB_COLOR ( elm , field ) ; if ( child ) RB_PARENT ( child , field ) = parent ; if ( parent ) { if ( RB_LEFT ( parent , field ) == elm ) RB_LEFT ( parent , field ) = child ; else RB_RIGHT ( parent , field ) = child ; RB_AUGMENT ( parent ) ; } else RB_ROOT ( head ) = child ; if ( RB_PARENT ( elm , field ) == old ) parent = elm ; ( elm ) -> field = ( old ) -> field ; if ( RB_PARENT ( old , field ) ) { if ( RB_LEFT ( RB_PARENT ( old , field ) , field ) == old ) RB_LEFT ( RB_PARENT ( old , field ) , field ) = elm ; else RB_RIGHT ( RB_PARENT ( old , field ) , field ) = elm ; RB_AUGMENT ( RB_PARENT ( ol
} *)
  { TODO : Unable to convert function-like macro: }
  (* RB_GENERATE_INSERT ( name , type , field , cmp , attr ) \
/* Inserts a node into the RB tree */ attr struct type * name ## _RB_INSERT ( struct name * head , struct type * elm ) \
{ struct type * tmp ; struct type * parent = NULL ; int comp = 0 ; tmp = RB_ROOT ( head ) ; while ( tmp ) { parent = tmp ; comp = ( cmp ) ( elm , parent ) ; if ( comp < 0 ) tmp = RB_LEFT ( tmp , field ) ; else if ( comp > 0 ) tmp = RB_RIGHT ( tmp , field ) ; else return ( tmp ) ; } RB_SET ( elm , parent , field ) ; if ( parent != NULL ) { if ( comp < 0 ) RB_LEFT ( parent , field ) = elm ; else RB_RIGHT ( parent , field ) = elm ; RB_AUGMENT ( parent ) ; } else RB_ROOT ( head ) = elm ; name ## _RB_INSERT_COLOR ( head , elm ) ; return ( NULL ) ; \
} *)
  { TODO : Unable to convert function-like macro: }
  (* RB_GENERATE_FIND ( name , type , field , cmp , attr ) \
/* Finds the node with the same key as elm */ attr struct type * name ## _RB_FIND ( struct name * head , struct type * elm ) \
{ struct type * tmp = RB_ROOT ( head ) ; int comp ; while ( tmp ) { comp = cmp ( elm , tmp ) ; if ( comp < 0 ) tmp = RB_LEFT ( tmp , field ) ; else if ( comp > 0 ) tmp = RB_RIGHT ( tmp , field ) ; else return ( tmp ) ; } return ( NULL ) ; \
} *)
  { TODO : Unable to convert function-like macro: }
  (* RB_GENERATE_NFIND ( name , type , field , cmp , attr ) \
/* Finds the first node greater than or equal to the search key */ attr struct type * name ## _RB_NFIND ( struct name * head , struct type * elm ) \
{ struct type * tmp = RB_ROOT ( head ) ; struct type * res = NULL ; int comp ; while ( tmp ) { comp = cmp ( elm , tmp ) ; if ( comp < 0 ) { res = tmp ; tmp = RB_LEFT ( tmp , field ) ; } else if ( comp > 0 ) tmp = RB_RIGHT ( tmp , field ) ; else return ( tmp ) ; } return ( res ) ; \
} *)
  { TODO : Unable to convert function-like macro: }
  (* RB_GENERATE_NEXT ( name , type , field , attr ) \
/* ARGSUSED */ attr struct type * name ## _RB_NEXT ( struct type * elm ) \
{ if ( RB_RIGHT ( elm , field ) ) { elm = RB_RIGHT ( elm , field ) ; while ( RB_LEFT ( elm , field ) ) elm = RB_LEFT ( elm , field ) ; } else { if ( RB_PARENT ( elm , field ) && ( elm == RB_LEFT ( RB_PARENT ( elm , field ) , field ) ) ) elm = RB_PARENT ( elm , field ) ; else { while ( RB_PARENT ( elm , field ) && ( elm == RB_RIGHT ( RB_PARENT ( elm , field ) , field ) ) ) elm = RB_PARENT ( elm , field ) ; elm = RB_PARENT ( elm , field ) ; } } return ( elm ) ; \
} *)
  { TODO : Unable to convert function-like macro: }
  (* RB_GENERATE_PREV ( name , type , field , attr ) \
/* ARGSUSED */ attr struct type * name ## _RB_PREV ( struct type * elm ) \
{ if ( RB_LEFT ( elm , field ) ) { elm = RB_LEFT ( elm , field ) ; while ( RB_RIGHT ( elm , field ) ) elm = RB_RIGHT ( elm , field ) ; } else { if ( RB_PARENT ( elm , field ) && ( elm == RB_RIGHT ( RB_PARENT ( elm , field ) , field ) ) ) elm = RB_PARENT ( elm , field ) ; else { while ( RB_PARENT ( elm , field ) && ( elm == RB_LEFT ( RB_PARENT ( elm , field ) , field ) ) ) elm = RB_PARENT ( elm , field ) ; elm = RB_PARENT ( elm , field ) ; } } return ( elm ) ; \
} *)
  { TODO : Unable to convert function-like macro: }
  (* RB_GENERATE_MINMAX ( name , type , field , attr ) attr struct type * name ## _RB_MINMAX ( struct name * head , int val ) \
{ struct type * tmp = RB_ROOT ( head ) ; struct type * parent = NULL ; while ( tmp ) { parent = tmp ; if ( val < 0 ) tmp = RB_LEFT ( tmp , field ) ; else tmp = RB_RIGHT ( tmp , field ) ; } return ( parent ) ; \
} *)
  RB_NEGINF = -1;
  RB_INF = 1;
  { TODO : Unable to convert function-like macro: }
  (* RB_INSERT ( name , x , y ) name ## _RB_INSERT ( x , y ) *)
  { TODO : Unable to convert function-like macro: }
  (* RB_REMOVE ( name , x , y ) name ## _RB_REMOVE ( x , y ) *)
  { TODO : Unable to convert function-like macro: }
  (* RB_FIND ( name , x , y ) name ## _RB_FIND ( x , y ) *)
  { TODO : Unable to convert function-like macro: }
  (* RB_NFIND ( name , x , y ) name ## _RB_NFIND ( x , y ) *)
  { TODO : Unable to convert function-like macro: }
  (* RB_NEXT ( name , x , y ) name ## _RB_NEXT ( y ) *)
  { TODO : Unable to convert function-like macro: }
  (* RB_PREV ( name , x , y ) name ## _RB_PREV ( y ) *)
  { TODO : Unable to convert function-like macro: }
  (* RB_MIN ( name , x ) name ## _RB_MINMAX ( x , RB_NEGINF ) *)
  { TODO : Unable to convert function-like macro: }
  (* RB_MAX ( name , x ) name ## _RB_MINMAX ( x , RB_INF ) *)
  { TODO : Unable to convert function-like macro: }
  (* RB_FOREACH ( x , name , head ) for ( ( x ) = RB_MIN ( name , head ) ; ( x ) != NULL ; ( x ) = name ## _RB_NEXT ( x ) ) *)
  { TODO : Unable to convert function-like macro: }
  (* RB_FOREACH_FROM ( x , name , y ) for ( ( x ) = ( y ) ; ( ( x ) != NULL ) && ( ( y ) = name ## _RB_NEXT ( x ) , ( x ) != NULL ) ; ( x ) = ( y ) ) *)
  { TODO : Unable to convert function-like macro: }
  (* RB_FOREACH_SAFE ( x , name , head , y ) for ( ( x ) = RB_MIN ( name , head ) ; ( ( x ) != NULL ) && ( ( y ) = name ## _RB_NEXT ( x ) , ( x ) != NULL ) ; ( x ) = ( y ) ) *)
  { TODO : Unable to convert function-like macro: }
  (* RB_FOREACH_REVERSE ( x , name , head ) for ( ( x ) = RB_MAX ( name , head ) ; ( x ) != NULL ; ( x ) = name ## _RB_PREV ( x ) ) *)
  { TODO : Unable to convert function-like macro: }
  (* RB_FOREACH_REVERSE_FROM ( x , name , y ) for ( ( x ) = ( y ) ; ( ( x ) != NULL ) && ( ( y ) = name ## _RB_PREV ( x ) , ( x ) != NULL ) ; ( x ) = ( y ) ) *)
  { TODO : Unable to convert function-like macro: }
  (* RB_FOREACH_REVERSE_SAFE ( x , name , head , y ) for ( ( x ) = RB_MAX ( name , head ) ; ( ( x ) != NULL ) && ( ( y ) = name ## _RB_PREV ( x ) , ( x ) != NULL ) ; ( x ) = ( y ) ) *)
  { TODO : Macro probably uses invalid symbol "static": }
  (* STATIC static *)
  { TODO : Unable to convert function-like macro: }
  (* DEPRECATED ( func , msg ) __declspec ( deprecated , msg ) func *)
  LXW_MD5_SIZE = 16;
  LXW_SHEETNAME_MAX = 31;
  LXW_MAX_SHEETNAME_LENGTH = ((LXW_SHEETNAME_MAX*4)+2+1);
  { TODO : Macro probably uses invalid symbol "sizeof": }
  (* LXW_MAX_COL_NAME_LENGTH sizeof ( "$XFD" ) *)
  { TODO : Macro probably uses invalid symbol "sizeof": }
  (* LXW_MAX_ROW_NAME_LENGTH sizeof ( "$1048576" ) *)
  { TODO : Macro probably uses invalid symbol "sizeof": }
  (* LXW_MAX_CELL_NAME_LENGTH sizeof ( "$XFWD$1048576" ) *)
  { TODO : Macro uses commented-out symbol "LXW_MAX_CELL_NAME_LENGTH": }
  (* LXW_MAX_CELL_RANGE_LENGTH ( LXW_MAX_CELL_NAME_LENGTH * 2 ) *)
  { TODO : Macro uses commented-out symbol "LXW_MAX_CELL_RANGE_LENGTH": }
  (* LXW_MAX_FORMULA_RANGE_LENGTH ( LXW_MAX_SHEETNAME_LENGTH + LXW_MAX_CELL_RANGE_LENGTH ) *)
  { TODO : Macro probably uses invalid symbol "sizeof": }
  (* LXW_DATETIME_LENGTH sizeof ( "2016-12-12T23:00:00Z" ) *)
  { TODO : Macro probably uses invalid symbol "sizeof": }
  (* LXW_GUID_LENGTH sizeof ( "{12345678-1234-1234-1234-1234567890AB}\0" ) *)
//  LXW_EPOCH_1900 = 0;
//  LXW_EPOCH_1904 = 1;
  { TODO : Macro probably uses invalid symbol "sizeof": }
  (* LXW_UINT32_T_LENGTH sizeof ( "4294967296" ) *)
  LXW_FILENAME_LENGTH = 128;
  LXW_IGNORE = 1;
  LXW_PORTRAIT = 1;
  LXW_LANDSCAPE = 0;
  LXW_SCHEMA_MS = 'http://schemas.microsoft.com/office/2006/relationships';
  LXW_SCHEMA_ROOT = 'http://schemas.openxmlformats.org';
  LXW_SCHEMA_DRAWING = LXW_SCHEMA_ROOT + '/drawingml/2006';
  LXW_SCHEMA_OFFICEDOC = LXW_SCHEMA_ROOT + '/officeDocument/2006';
  LXW_SCHEMA_PACKAGE = LXW_SCHEMA_ROOT + '/package/2006/relationships';
  LXW_SCHEMA_DOCUMENT = LXW_SCHEMA_ROOT + '/officeDocument/2006/relationships';
  LXW_SCHEMA_CONTENT = LXW_SCHEMA_ROOT + '/package/2006/content-types';
  { TODO : Macro probably uses invalid symbol "fprintf": }
  (* LXW_PRINTF fprintf *)
  { TODO : Macro probably uses invalid symbol "stderr": }
  (* LXW_STDERR stderr , *)
  { TODO : Unable to convert function-like macro: }
  (* LXW_ERROR ( message ) LXW_PRINTF ( LXW_STDERR "[ERROR][%s:%d]: " message "\n" , __FILE__ , __LINE__ ) *)
  { TODO : Unable to convert function-like macro: }
  (* LXW_MEM_ERROR ( ) LXW_ERROR ( "Memory allocation failed." ) *)
  { TODO : Unable to convert function-like macro: }
  (* GOTO_LABEL_ON_MEM_ERROR ( pointer , label ) do { if ( ! pointer ) { LXW_MEM_ERROR ( ) ; goto label ; } } while ( 0 ) *)
  { TODO : Unable to convert function-like macro: }
  (* RETURN_ON_MEM_ERROR ( pointer , error ) do { if ( ! pointer ) { LXW_MEM_ERROR ( ) ; return error ; } } while ( 0 ) *)
  { TODO : Unable to convert function-like macro: }
  (* RETURN_VOID_ON_MEM_ERROR ( pointer ) do { if ( ! pointer ) { LXW_MEM_ERROR ( ) ; return ; } } while ( 0 ) *)
  { TODO : Unable to convert function-like macro: }
  (* RETURN_ON_ERROR ( error ) do { if ( error ) return error ; } while ( 0 ) *)
  { TODO : Unable to convert function-like macro: }
  (* RETURN_AND_ZIPCLOSE_ON_ERROR ( error ) do { if ( error ) { zipClose ( self -> zipfile , NULL ) ; return error ; } } while ( 0 ) *)
  { TODO : Unable to convert function-like macro: }
  (* LXW_WARN ( message ) LXW_PRINTF ( LXW_STDERR "[WARNING]: " message "\n" ) *)
  { TODO : Unable to convert function-like macro: }
  (* LXW_WARN_FORMAT ( message ) LXW_PRINTF ( LXW_STDERR "[WARNING]: " message "\n" ) *)
  { TODO : Unable to convert function-like macro: }
  (* LXW_WARN_FORMAT1 ( message , var ) LXW_PRINTF ( LXW_STDERR "[WARNING]: " message "\n" , var ) *)
  { TODO : Unable to convert function-like macro: }
  (* LXW_WARN_FORMAT2 ( message , var1 , var2 ) LXW_PRINTF ( LXW_STDERR "[WARNING]: " message "\n" , var1 , var2 ) *)
  { TODO : Unable to convert function-like macro: }
  (* LXW_WARN_FORMAT3 ( message , var1 , var2 , var3 ) LXW_PRINTF ( LXW_STDERR "[WARNING]: " message "\n" , var1 , var2 , var3 ) *)
  { TODO : Unable to convert function-like macro: }
  (* LXW_WARN_CAT_AXIS_ONLY ( function ) do { if ( ! axis -> is_category ) { LXW_PRINTF ( LXW_STDERR "[WARNING]: " function "() is only valid for category axes\n" ) ; return ; } } while ( 0 ) *)
  { TODO : Unable to convert function-like macro: }
  (* LXW_WARN_VALUE_AXIS_ONLY ( function ) do { if ( ! axis -> is_value ) { LXW_PRINTF ( LXW_STDERR "[WARNING]: " function "() is only valid for value axes\n" ) ; return ; } } while ( 0 ) *)
  { TODO : Unable to convert function-like macro: }
  (* LXW_WARN_DATE_AXIS_ONLY ( function ) do { if ( ! axis -> is_date ) { LXW_PRINTF ( LXW_STDERR "[WARNING]: " function "() is only valid for date axes\n" ) ; return ; } } while ( 0 ) *)
  { TODO : Unable to convert function-like macro: }
  (* LXW_WARN_CAT_AND_DATE_AXIS_ONLY ( function ) do { if ( ! axis -> is_category && ! axis -> is_date ) { LXW_PRINTF ( LXW_STDERR "[WARNING]: " function "() is only valid for category and date axes\n" ) ; return ; } } while ( 0 ) *)
//  { TODO : Unable to convert function-like macro: }
//  (* LXW_WARN_VALUE_AND_DATE_AXIS_ONLY ( function ) do { if ( ! axis -> is_value && ! axis -> is_date ) { LXW_PRINTF ( LXW_STDERR "[WARNING]: " function "() is only valid for value and date axes\n" ) ; return ; } } while ( 0 ) *)
//  { TODO : Unable to convert function-like macro: }
//  (* LXW_UINT16_HOST ( n ) ( n ) *)
//  { TODO : Unable to convert function-like macro: }
//  (* LXW_UINT32_HOST ( n ) ( n ) *)
//  { TODO : Unable to convert function-like macro: }
//  (* LXW_UINT16_NETWORK ( n ) ( ( ( ( n ) & 0x00FF ) << 8 ) | ( ( ( n ) & 0xFF00 ) >> 8 ) ) *)
//  { TODO : Unable to convert function-like macro: }
//  (* LXW_UINT32_NETWORK ( n ) ( ( ( ( n ) & 0xFF ) << 24 ) | ( ( ( n ) & 0xFF00 ) << 8 ) | ( ( ( n ) & 0xFF0000 ) >> 8 ) | ( ( ( n ) & 0xFF000000 ) >> 24 ) ) *)
//  { TODO : Macro probably uses invalid symbol "lxw_snprintf": }
//  (* lxw_snprintf snprintf *)
//  { TODO : Unable to convert function-like macro: }
//  (* lxw_strcpy ( dest , src ) lxw_snprintf ( dest , sizeof ( dest ) , "%s" , src ) *)
//  { TODO : Unable to convert function-like macro: }
//  (* LXW_RB_GENERATE_ELEMENT ( name , type , field , cmp ) RB_GENERATE_INSERT_COLOR ( name , type , field , static ) RB_GENERATE_INSERT ( name , type , field , cmp , static ) /* Add unused struct to allow adding a semicolon */ struct lxw_rb_generate_element { int unused ; } *)
//  { TODO : Unable to convert function-like macro: }
//  (* LXW_FOREACH_ORDERED ( elem , hash_table ) STAILQ_FOREACH ( ( elem ) , ( hash_table ) -> order_list , lxw_hash_order_pointers ) *)
  LXW_FORMAT_FIELD_LEN = 128;
  LXW_DEFAULT_FONT_NAME = 'Calibri';
  LXW_DEFAULT_FONT_FAMILY = 2;
  LXW_DEFAULT_FONT_THEME = 1;
  LXW_PROPERTY_UNSET = -1;
  LXW_COLOR_UNSET = $000000;
  LXW_COLOR_MASK = $FFFFFF;
  LXW_MIN_FONT_SIZE = 1.0;
  LXW_MAX_FONT_SIZE = 409.0;
  { TODO : Unable to convert function-like macro: }
  (* LXW_FORMAT_FIELD_COPY ( dst , src ) do { strncpy ( dst , src , LXW_FORMAT_FIELD_LEN - 1 ) ; dst [ LXW_FORMAT_FIELD_LEN - 1 ] = '\0' ; } while ( 0 ) *)
  LXW_CHART_NUM_FORMAT_LEN = 128;
  LXW_CHART_DEFAULT_GAP = 501;
  LXW_MAX_ATTRIBUTE_LENGTH = 2080;
  LXW_ATTR_32 = 32;
  { TODO : Unable to convert function-like macro: }
  (* LXW_ATTRIBUTE_COPY ( dst , src ) do { strncpy ( dst , src , LXW_MAX_ATTRIBUTE_LENGTH - 1 ) ; dst [ LXW_MAX_ATTRIBUTE_LENGTH - 1 ] = '\0' ; } while ( 0 ) *)
  { TODO : Unable to convert function-like macro: }
  (* LXW_INIT_ATTRIBUTES ( ) STAILQ_INIT ( & attributes ) *)
  { TODO : Unable to convert function-like macro: }
  (* LXW_PUSH_ATTRIBUTES_STR ( key , value ) do { attribute = lxw_new_attribute_str ( ( key ) , ( value ) ) ; STAILQ_INSERT_TAIL ( & attributes , attribute , list_entries ) ; } while ( 0 ) *)
  { TODO : Unable to convert function-like macro: }
  (* LXW_PUSH_ATTRIBUTES_INT ( key , value ) do { attribute = lxw_new_attribute_int ( ( key ) , ( value ) ) ; STAILQ_INSERT_TAIL ( & attributes , attribute , list_entries ) ; } while ( 0 ) *)
  { TODO : Unable to convert function-like macro: }
  (* LXW_PUSH_ATTRIBUTES_DBL ( key , value ) do { attribute = lxw_new_attribute_dbl ( ( key ) , ( value ) ) ; STAILQ_INSERT_TAIL ( & attributes , attribute , list_entries ) ; } while ( 0 ) *)
  { TODO : Unable to convert function-like macro: }
  (* LXW_FREE_ATTRIBUTES ( ) do { while ( ! STAILQ_EMPTY ( & attributes ) ) { attribute = STAILQ_FIRST ( & attributes ) ; STAILQ_REMOVE_HEAD ( & attributes , list_entries ) ; free ( attribute ) ; } } while ( 0 ) *)
  { TODO : Unable to convert function-like macro: }
  (* CELL ( cell ) lxw_name_to_row ( cell ) , lxw_name_to_col ( cell ) *)
  { TODO : Unable to convert function-like macro: }
  (* COLS ( cols ) lxw_name_to_col ( cols ) , lxw_name_to_col_2 ( cols ) *)
  { TODO : Unable to convert function-like macro: }
  (* RANGE ( range ) lxw_name_to_row ( range ) , lxw_name_to_col ( range ) , lxw_name_to_row_2 ( range ) , lxw_name_to_col_2 ( range ) *)
  { TODO : Macro probably uses invalid symbol "lxw_strcasecmp": }
  (* lxw_strcasecmp _stricmp *)
  { TODO : Unable to convert function-like macro: }
  (* lxw_sprintf_dbl ( data , number ) lxw_snprintf ( data , LXW_ATTR_32 , "%.16G" , number ) *)
  LXW_ROW_MAX = 1048576;
  LXW_COL_MAX = 16384;
  LXW_COL_META_MAX = 128;
  LXW_HEADER_FOOTER_MAX = 255;
  LXW_MAX_NUMBER_URLS = 65530;
  LXW_PANE_NAME_LENGTH = 12;
  LXW_IMAGE_BUFFER_SIZE = 1024;
  LXW_HEADER_FOOTER_OBJS_MAX = 6;
  LXW_BREAKS_MAX = 1023;
  { TODO : Macro probably uses invalid symbol "double": }
  LXW_DEF_COL_WIDTH = 8.43; 
  { TODO : Macro probably uses invalid symbol "double": }
  LXW_DEF_ROW_HEIGHT = 15.0;
  LXW_DEF_COL_WIDTH_PIXELS = 64;
  LXW_DEF_ROW_HEIGHT_PIXELS = 20;
  { TODO : Unable to convert function-like macro: }
  (* LXW_RB_GENERATE_ROW ( name , type , field , cmp ) RB_GENERATE_INSERT_COLOR ( name , type , field , static ) RB_GENERATE_REMOVE_COLOR ( name , type , field , static ) RB_GENERATE_INSERT ( name , type , field , cmp , static ) RB_GENERATE_REMOVE ( name , type , field , static ) RB_GENERATE_FIND ( name , type , field , cmp , static ) RB_GENERATE_NEXT ( name , type , field , static ) RB_GENERATE_MINMAX ( name , type , field , static ) /* Add unused struct to allow adding a semicolon */ struct lxw_rb_generate_row { int unused ; } *)
  { TODO : Unable to convert function-like macro: }
  (* LXW_RB_GENERATE_CELL ( name , type , field , cmp ) RB_GENERATE_INSERT_COLOR ( name , type , field , static ) RB_GENERATE_REMOVE_COLOR ( name , type , field , static ) RB_GENERATE_INSERT ( name , type , field , cmp , static ) RB_GENERATE_REMOVE ( name , type , field , static ) RB_GENERATE_FIND ( name , type , field , cmp , static ) RB_GENERATE_NEXT ( name , type , field , static ) RB_GENERATE_MINMAX ( name , type , field , static ) /* Add unused struct to allow adding a semicolon */ struct lxw_rb_generate_cell { int unused ; } *)
  { TODO : Unable to convert function-like macro: }
  (* LXW_RB_GENERATE_DRAWING_REL_IDS ( name , type , field , cmp ) RB_GENERATE_INSERT_COLOR ( name , type , field , static ) RB_GENERATE_REMOVE_COLOR ( name , type , field , static ) RB_GENERATE_INSERT ( name , type , field , cmp , static ) RB_GENERATE_REMOVE ( name , type , field , static ) RB_GENERATE_FIND ( name , type , field , cmp , static ) RB_GENERATE_NEXT ( name , type , field , static ) RB_GENERATE_MINMAX ( name , type , field , static ) /* Add unused struct to allow adding a semicolon */ struct lxw_rb_generate_drawing_rel_ids { int unused ; } *)
  { TODO : Unable to convert function-like macro: }
  (* LXW_RB_GENERATE_VML_DRAWING_REL_IDS ( name , type , field , cmp ) RB_GENERATE_INSERT_COLOR ( name , type , field , static ) RB_GENERATE_REMOVE_COLOR ( name , type , field , static ) RB_GENERATE_INSERT ( name , type , field , cmp , static ) RB_GENERATE_REMOVE ( name , type , field , static ) RB_GENERATE_FIND ( name , type , field , cmp , static ) RB_GENERATE_NEXT ( name , type , field , static ) RB_GENERATE_MINMAX ( name , type , field , static ) /* Add unused struct to allow adding a semicolon */ struct lxw_rb_generate_vml_drawing_rel_ids { int unused ; } *)
  { TODO : Unable to convert function-like macro: }
  (* LXW_RB_GENERATE_COND_FORMAT_HASH ( name , type , field , cmp ) RB_GENERATE_INSERT_COLOR ( name , type , field , static ) RB_GENERATE_REMOVE_COLOR ( name , type , field , static ) RB_GENERATE_INSERT ( name , type , field , cmp , static ) RB_GENERATE_REMOVE ( name , type , field , static ) RB_GENERATE_FIND ( name , type , field , cmp , static ) RB_GENERATE_NEXT ( name , type , field , static ) RB_GENERATE_MINMAX ( name , type , field , static ) /* Add unused struct to allow adding a semicolon */ struct lxw_rb_generate_cond_format_hash { int unused ; } *)
  LXW_DEFINED_NAME_LENGTH = 128;
  { TODO : Unable to convert function-like macro: }
  (* LXW_RB_GENERATE_WORKSHEET_NAMES ( name , type , field , cmp ) RB_GENERATE_INSERT_COLOR ( name , type , field , static ) RB_GENERATE_REMOVE_COLOR ( name , type , field , static ) RB_GENERATE_INSERT ( name , type , field , cmp , static ) RB_GENERATE_REMOVE ( name , type , field , static ) RB_GENERATE_FIND ( name , type , field , cmp , static ) RB_GENERATE_NEXT ( name , type , field , static ) RB_GENERATE_MINMAX ( name , type , field , static ) /* Add unused struct to allow adding a semicolon */ struct lxw_rb_generate_worksheet_names { int unused ; } *)
  { TODO : Unable to convert function-like macro: }
  (* LXW_RB_GENERATE_CHARTSHEET_NAMES ( name , type , field , cmp ) RB_GENERATE_INSERT_COLOR ( name , type , field , static ) RB_GENERATE_REMOVE_COLOR ( name , type , field , static ) RB_GENERATE_INSERT ( name , type , field , cmp , static ) RB_GENERATE_REMOVE ( name , type , field , static ) RB_GENERATE_FIND ( name , type , field , cmp , static ) RB_GENERATE_NEXT ( name , type , field , static ) RB_GENERATE_MINMAX ( name , type , field , static ) /* Add unused struct to allow adding a semicolon */ struct lxw_rb_generate_charsheet_names { int unused ; } *)
  { TODO : Unable to convert function-like macro: }
  (* LXW_RB_GENERATE_IMAGE_MD5S ( name , type , field , cmp ) RB_GENERATE_INSERT_COLOR ( name , type , field , static ) RB_GENERATE_REMOVE_COLOR ( name , type , field , static ) RB_GENERATE_INSERT ( name , type , field , cmp , static ) RB_GENERATE_REMOVE ( name , type , field , static ) RB_GENERATE_FIND ( name , type , field , cmp , static ) RB_GENERATE_NEXT ( name , type , field , static ) RB_GENERATE_MINMAX ( name , type , field , static ) /* Add unused struct to allow adding a semicolon */ struct lxw_rb_generate_image_md5s { int unused ; } *)
  { TODO : Unable to convert function-like macro: }
  (* LXW_FOREACH_WORKSHEET ( worksheet , workbook ) STAILQ_FOREACH ( ( worksheet ) , ( workbook ) -> worksheets , list_pointers ) *)
  LXW_VERSION_CC = '1.2.4';
  LXW_VERSION_ID_CC = 124;
  LXW_SOVERSION_CC = '11';

type
  UInt8 = Byte;
  Int8 = ShortInt;
  UInt16 = Word;
  Int16 = SmallInt;
  UInt32 = Cardinal;
  DWord = Cardinal;
  UTF8Char = AnsiChar;
  PUtf8Char = PAnsiChar;
//  Int32 = Integer;
  Int32 = LongInt;
  // Forward declarations
  PPUTF8Char = ^PUTF8Char;
  PUInt8 = ^UInt8;
  PUInt16 = ^UInt16;
  PInt16 = ^Int16;
  PPointer = ^Pointer;
  PNativeUInt = ^NativeUInt;
  Plxw_datetime = ^lxw_datetime;
  Plxw_formats = ^lxw_formats;
  Plxw_tuples = ^lxw_tuples;
  Plxw_custom_properties = ^lxw_custom_properties;
  Plxw_tuple = ^lxw_tuple;
  PPlxw_tuple = ^Plxw_tuple;
  Plxw_custom_property = ^lxw_custom_property;
  PPlxw_custom_property = ^Plxw_custom_property;
  Psst_rb_tree = ^sst_rb_tree;
  Psst_order_list = ^sst_order_list;
  Psst_element = ^sst_element;
  PPsst_element = ^Psst_element;
  Plxw_sst = ^lxw_sst;
  Plxw_hash_order_list = ^lxw_hash_order_list;
  Plxw_hash_bucket_list = ^lxw_hash_bucket_list;
  PPlxw_hash_bucket_list = ^Plxw_hash_bucket_list;
  Plxw_hash_table = ^lxw_hash_table;
  Plxw_hash_element = ^lxw_hash_element;
  PPlxw_hash_element = ^Plxw_hash_element;
  Plxw_format = ^lxw_format;
  PPlxw_format = ^Plxw_format;
  Plxw_font = ^lxw_font;
  Plxw_border = ^lxw_border;
  Plxw_fill = ^lxw_fill;
  Plxw_chart_series_list = ^lxw_chart_series_list;
  Plxw_series_data_points = ^lxw_series_data_points;
  Plxw_series_range = ^lxw_series_range;
  Plxw_series_data_point = ^lxw_series_data_point;
  PPlxw_series_data_point = ^Plxw_series_data_point;
  Plxw_chart_line = ^lxw_chart_line;
  Plxw_chart_fill = ^lxw_chart_fill;
  Plxw_chart_pattern = ^lxw_chart_pattern;
  Plxw_chart_font = ^lxw_chart_font;
  Plxw_chart_layout = ^lxw_chart_layout;
  Plxw_chart_marker = ^lxw_chart_marker;
  Plxw_chart_legend = ^lxw_chart_legend;
  Plxw_chart_title = ^lxw_chart_title;
  Plxw_chart_point = ^lxw_chart_point;
  Plxw_chart_data_label = ^lxw_chart_data_label;
  Plxw_chart_custom_label = ^lxw_chart_custom_label;
  Plxw_series_error_bars = ^lxw_series_error_bars;
  Plxw_chart_series = ^lxw_chart_series;
  PPlxw_chart_series = ^Plxw_chart_series;
  Plxw_chart_gridline = ^lxw_chart_gridline;
  Plxw_chart_axis = ^lxw_chart_axis;
  Plxw_chart = ^lxw_chart;
  PPlxw_chart = ^Plxw_chart;
  Plxw_drawing_objects = ^lxw_drawing_objects;
  Plxw_drawing_coords = ^lxw_drawing_coords;
  Plxw_drawing_object = ^lxw_drawing_object;
  PPlxw_drawing_object = ^Plxw_drawing_object;
  Plxw_drawing = ^lxw_drawing;
  Plxw_styles = ^lxw_styles;
  Pxml_attribute = ^xml_attribute;
  PPxml_attribute = ^Pxml_attribute;
  Pxml_attribute_list = ^xml_attribute_list;
  Plxw_rel_tuples = ^lxw_rel_tuples;
  Plxw_rel_tuple = ^lxw_rel_tuple;
  PPlxw_rel_tuple = ^Plxw_rel_tuple;
  Plxw_relationships = ^lxw_relationships;
  Plxw_table_cells = ^lxw_table_cells;
  Plxw_drawing_rel_ids = ^lxw_drawing_rel_ids;
  Plxw_vml_drawing_rel_ids = ^lxw_vml_drawing_rel_ids;
  Plxw_cond_format_hash = ^lxw_cond_format_hash;
  Plxw_table_rows = ^lxw_table_rows;
  Plxw_merged_ranges = ^lxw_merged_ranges;
  Plxw_selections = ^lxw_selections;
  Plxw_data_validations = ^lxw_data_validations;
  Plxw_cond_format_list = ^lxw_cond_format_list;
  Plxw_image_props = ^lxw_image_props;
  Plxw_embedded_image_props = ^lxw_embedded_image_props;
  Plxw_chart_props = ^lxw_chart_props;
  Plxw_comment_objs = ^lxw_comment_objs;
  Plxw_table_objs = ^lxw_table_objs;
  Plxw_row_col_options = ^lxw_row_col_options;
  Plxw_col_options = ^lxw_col_options;
  PPlxw_col_options = ^Plxw_col_options;
  Plxw_merged_range = ^lxw_merged_range;
  PPlxw_merged_range = ^Plxw_merged_range;
  Plxw_repeat_rows = ^lxw_repeat_rows;
  Plxw_repeat_cols = ^lxw_repeat_cols;
  Plxw_print_area = ^lxw_print_area;
  Plxw_autofilter = ^lxw_autofilter;
  Plxw_panes = ^lxw_panes;
  Plxw_selection = ^lxw_selection;
  PPlxw_selection = ^Plxw_selection;
  Plxw_data_validation = ^lxw_data_validation;
  Plxw_data_val_obj = ^lxw_data_val_obj;
  PPlxw_data_val_obj = ^Plxw_data_val_obj;
  Plxw_conditional_format = ^lxw_conditional_format;
  Plxw_cond_format_obj = ^lxw_cond_format_obj;
  PPlxw_cond_format_obj = ^Plxw_cond_format_obj;
  Plxw_cond_format_hash_element = ^lxw_cond_format_hash_element;
  Plxw_table_column = ^lxw_table_column;
  PPlxw_table_column = ^Plxw_table_column;
  Plxw_table_options = ^lxw_table_options;
  Plxw_table_obj = ^lxw_table_obj;
  PPlxw_table_obj = ^Plxw_table_obj;
  Plxw_filter_rule = ^lxw_filter_rule;
  Plxw_filter_rule_obj = ^lxw_filter_rule_obj;
  PPlxw_filter_rule_obj = ^Plxw_filter_rule_obj;
  Plxw_image_options = ^lxw_image_options;
  Plxw_chart_options = ^lxw_chart_options;
  Plxw_object_properties = ^lxw_object_properties;
  PPlxw_object_properties = ^Plxw_object_properties;
  Plxw_comment_options = ^lxw_comment_options;
  Plxw_button_options = ^lxw_button_options;
  Plxw_vml_obj = ^lxw_vml_obj;
  PPlxw_vml_obj = ^Plxw_vml_obj;
  Plxw_header_footer_options = ^lxw_header_footer_options;
  Plxw_protection = ^lxw_protection;
  Plxw_protection_obj = ^lxw_protection_obj;
  Plxw_rich_string_tuple = ^lxw_rich_string_tuple;
  Plxw_worksheet = ^lxw_worksheet;
  PPlxw_worksheet = ^Plxw_worksheet;
  Plxw_worksheet_init_data = ^lxw_worksheet_init_data;
  Plxw_row = ^lxw_row;
  Plxw_cell = ^lxw_cell;
  PPlxw_cell = ^Plxw_cell;
  Plxw_drawing_rel_id = ^lxw_drawing_rel_id;
  Plxw_chartsheet = ^lxw_chartsheet;
  PPlxw_chartsheet = ^Plxw_chartsheet;
  Plxw_worksheet_names = ^lxw_worksheet_names;
  Plxw_chartsheet_names = ^lxw_chartsheet_names;
  Plxw_image_md5s = ^lxw_image_md5s;
  Plxw_sheets = ^lxw_sheets;
  Plxw_worksheets = ^lxw_worksheets;
  Plxw_chartsheets = ^lxw_chartsheets;
  Plxw_charts = ^lxw_charts;
  Plxw_defined_names = ^lxw_defined_names;
  Plxw_sheet = ^lxw_sheet;
  PPlxw_sheet = ^Plxw_sheet;
  Plxw_worksheet_name = ^lxw_worksheet_name;
  Plxw_chartsheet_name = ^lxw_chartsheet_name;
  Plxw_image_md5 = ^lxw_image_md5;
  Plxw_defined_name = ^lxw_defined_name;
  PPlxw_defined_name = ^Plxw_defined_name;
  Plxw_doc_properties = ^lxw_doc_properties;
  Plxw_workbook_options = ^lxw_workbook_options;
  Plxw_workbook = ^lxw_workbook;

  (** Integer data type to represent a row value. Equivalent to `uint32_t`.
   *
   * The maximum row in Excel is 1,048,576.
   *)
  lxw_row_t = UInt32;
  Plxw_row_t = ^lxw_row_t;
  (** Integer data type to represent a column value. Equivalent to `uint16_t`.
   *
   * The maximum column in Excel is 16,384.
   *)
  lxw_col_t = UInt16;
  Plxw_col_t = ^lxw_col_t;

  (** Boolean values used in libxlsxwriter. *)
  lxw_boolean = (
    (** False value. *)
    LXW_FALSE = 0,
    (** True value. *)
    LXW_TRUE = 1,
    (** False value. Used to turn off a property that is default on, in order
     *  to distinguish it from an uninitialized value. *)
    LXW_EXPLICIT_FALSE = 2);
  Plxw_boolean = ^lxw_boolean;

  (**
   * @brief Error codes from libxlsxwriter functions.
   *
   * See the `lxw_strerror()` function for an example of how to convert the
   * enum number to a descriptive error message string.
   *)
  lxw_error = (
    (** No error. *)
    LXW_NO_ERROR = 0,
    (** Memory error, failed to malloc() required memory. *)
    LXW_ERROR_MEMORY_MALLOC_FAILED = 1,
    (** Error creating output xlsx file. Usually a permissions error. *)
    LXW_ERROR_CREATING_XLSX_FILE = 2,
    (** Error encountered when creating a tmpfile during file assembly. *)
    LXW_ERROR_CREATING_TMPFILE = 3,
    (** Error reading a tmpfile. *)
    LXW_ERROR_READING_TMPFILE = 4,
    (** Zip generic error ZIP_ERRNO while creating the xlsx file. *)
    LXW_ERROR_ZIP_FILE_OPERATION = 5,
    (** Zip error ZIP_PARAMERROR while creating the xlsx file. *)
    LXW_ERROR_ZIP_PARAMETER_ERROR = 6,
    (** Zip error ZIP_BADZIPFILE (use_zip64 option may be required). *)
    LXW_ERROR_ZIP_BAD_ZIP_FILE = 7,
    (** Zip error ZIP_INTERNALERROR while creating the xlsx file. *)
    LXW_ERROR_ZIP_INTERNAL_ERROR = 8,
    (** File error or unknown zip error when adding sub file to xlsx file. *)
    LXW_ERROR_ZIP_FILE_ADD = 9,
    (** Unknown zip error when closing xlsx file. *)
    LXW_ERROR_ZIP_CLOSE = 10,
    (** Feature is not currently supported in this configuration. *)
    LXW_ERROR_FEATURE_NOT_SUPPORTED = 11,
    (** NULL function parameter ignored. *)
    LXW_ERROR_NULL_PARAMETER_IGNORED = 12,
    (** Function parameter validation error. *)
    LXW_ERROR_PARAMETER_VALIDATION = 13,
    (** Function string parameter is empty. *)
    LXW_ERROR_PARAMETER_IS_EMPTY = 14,
    (** A #lxw_datetime parameter has a validation error. *)
    LXW_ERROR_DATETIME_VALIDATION = 15,
    (** Worksheet name exceeds Excel's limit of 31 characters. *)
    LXW_ERROR_SHEETNAME_LENGTH_EXCEEDED = 16,
    (** Worksheet name cannot contain invalid characters: '[ ] : * ? / \\' *)
    LXW_ERROR_INVALID_SHEETNAME_CHARACTER = 17,
    (** Worksheet name cannot start or end with an apostrophe. *)
    LXW_ERROR_SHEETNAME_START_END_APOSTROPHE = 18,
    (** Worksheet name is already in use. *)
    LXW_ERROR_SHEETNAME_ALREADY_USED = 19,
    (** Parameter exceeds Excel's limit of 32 characters. *)
    LXW_ERROR_32_STRING_LENGTH_EXCEEDED = 20,
    (** Parameter exceeds Excel's limit of 128 characters. *)
    LXW_ERROR_128_STRING_LENGTH_EXCEEDED = 21,
    (** Parameter exceeds Excel's limit of 255 characters. *)
    LXW_ERROR_255_STRING_LENGTH_EXCEEDED = 22,
    (** String exceeds Excel's limit of 32,767 characters. *)
    LXW_ERROR_MAX_STRING_LENGTH_EXCEEDED = 23,
    (** Error finding internal string index. *)
    LXW_ERROR_SHARED_STRING_INDEX_NOT_FOUND = 24,
    (** Worksheet row or column index out of range. *)
    LXW_ERROR_WORKSHEET_INDEX_OUT_OF_RANGE = 25,
    (** Maximum hyperlink length (2079) exceeded. *)
    LXW_ERROR_WORKSHEET_MAX_URL_LENGTH_EXCEEDED = 26,
    (** Maximum number of worksheet URLs (65530) exceeded. *)
    LXW_ERROR_WORKSHEET_MAX_NUMBER_URLS_EXCEEDED = 27,
    (** Couldn't read image dimensions or DPI. *)
    LXW_ERROR_IMAGE_DIMENSIONS = 28,
    (** Couldn't read image dimensions or DPI. *)
    LXW_MAX_ERRNO = 29);
  Plxw_error = ^lxw_error;

  (** @brief Struct to represent a date and time in Excel.
   *
   * Struct to represent a date and time in Excel. See @ref working_with_dates.
   *)
  lxw_datetime = packed record
    (** Year     : 1900 - 9999 *)
    year: Integer;
    (** Month    : 1 - 12 *)
    month: Integer;
    (** Day      : 1 - 31 *)
    day: Integer;
    (** Hour     : 0 - 23 *)
    hour: Integer;
    (** Minute   : 0 - 59 *)
    min: Integer;
    (** Seconds  : 0 - 59.999 *)
    sec: Double;
  end;

  lxw_custom_property_types = (
    LXW_CUSTOM_NONE = 0,
    LXW_CUSTOM_STRING = 1,
    LXW_CUSTOM_DOUBLE = 2,
    LXW_CUSTOM_INTEGER = 3,
    LXW_CUSTOM_BOOLEAN = 4,
    LXW_CUSTOM_DATETIME = 5);
  Plxw_custom_property_types = ^lxw_custom_property_types;

  lxw_formats = record
    stqh_first: Plxw_format;
    stqh_last: PPlxw_format;
  end;

  lxw_tuples = record
    stqh_first: Plxw_tuple;
    stqh_last: PPlxw_tuple;
  end;

  lxw_custom_properties = record
    stqh_first: Plxw_custom_property;
    stqh_last: PPlxw_custom_property;
  end;

  P_anonymous_type_1 = ^_anonymous_type_1;
  _anonymous_type_1 = record
    stqe_next: Plxw_tuple;
  end;

  lxw_tuple = record
    key: PUTF8Char;
    value: PUTF8Char;
    list_pointers: _anonymous_type_1;
  end;

  P_anonymous_type_2 = ^_anonymous_type_2;
  _anonymous_type_2 = record
    case Integer of
      0: (_str: PUTF8Char);
      1: (number: Double);
      2: (_int: Int32);
      3: (_bool: UInt8);
      4: (datetime: lxw_datetime);
  end;

  P_anonymous_type_3 = ^_anonymous_type_3;
  _anonymous_type_3 = record
    stqe_next: Plxw_custom_property;
  end;

  lxw_custom_property = record
    _type: lxw_custom_property_types;
    name: PUTF8Char;
    u: _anonymous_type_2;
    list_pointers: _anonymous_type_3;
  end;

  sst_rb_tree = record
    rbh_root: Psst_element;
  end;

  sst_order_list = record
    stqh_first: Psst_element;
    stqh_last: PPsst_element;
  end;

  P_anonymous_type_4 = ^_anonymous_type_4;
  _anonymous_type_4 = record
    stqe_next: Psst_element;
  end;

  P_anonymous_type_5 = ^_anonymous_type_5;
  _anonymous_type_5 = record
    rbe_left: Psst_element;
    rbe_right: Psst_element;
    rbe_parent: Psst_element;
    rbe_color: Integer;
  end;

  sst_element = record
    index: UInt32;
    _str: PUTF8Char;
    is_rich_string: UInt8;
    sst_order_pointers: _anonymous_type_4;
    sst_tree_pointers: _anonymous_type_5;
  end;

  lxw_sst = record
    _file: PPointer;
    string_count: UInt32;
    unique_count: UInt32;
    order_list: Psst_order_list;
    rb_tree: Psst_rb_tree;
  end;

  lxw_hash_order_list = record
    stqh_first: Plxw_hash_element;
    stqh_last: PPlxw_hash_element;
  end;

  lxw_hash_bucket_list = record
    slh_first: Plxw_hash_element;
  end;

  lxw_hash_table = record
    num_buckets: UInt32;
    used_buckets: UInt32;
    unique_count: UInt32;
    free_key: UInt8;
    free_value: UInt8;
    order_list: Plxw_hash_order_list;
    buckets: PPlxw_hash_bucket_list;
  end;

  P_anonymous_type_6 = ^_anonymous_type_6;
  _anonymous_type_6 = record
    stqe_next: Plxw_hash_element;
  end;

  P_anonymous_type_7 = ^_anonymous_type_7;
  _anonymous_type_7 = record
    sle_next: Plxw_hash_element;
  end;

  lxw_hash_element = record
    key: Pointer;
    value: Pointer;
    lxw_hash_order_pointers: _anonymous_type_6;
    lxw_hash_list_pointers: _anonymous_type_7;
  end;

  (**
   * @brief The type for RGB colors in libxlsxwriter.
   *
   * The type for RGB colors in libxlsxwriter. The valid range is `0x000000`
   * (black) to `0xFFFFFF` (white). See @ref working_with_colors.
   *)
  lxw_color_t = UInt32;

  (** Format underline values for format_set_underline(). *)
  lxw_format_underlines = (
    LXW_UNDERLINE_NONE = 0,
    (** Single underline *)
    LXW_UNDERLINE_SINGLE = 1,
    (** Double underline *)
    LXW_UNDERLINE_DOUBLE = 2,
    (** Single accounting underline *)
    LXW_UNDERLINE_SINGLE_ACCOUNTING = 3,
    (** Double accounting underline *)
    LXW_UNDERLINE_DOUBLE_ACCOUNTING = 4);
  Plxw_format_underlines = ^lxw_format_underlines;

  (** Superscript and subscript values for format_set_font_script(). *)
  lxw_format_scripts = (
    (** Superscript font *)
    LXW_FONT_SUPERSCRIPT = 1,
    (** Subscript font *)
    LXW_FONT_SUBSCRIPT = 2);
  Plxw_format_scripts = ^lxw_format_scripts;

  (** Alignment values for format_set_align(). *)
  lxw_format_alignments = (
    (** No alignment. Cell will use Excel's default for the data type *)
    LXW_ALIGN_NONE = 0,
    (** Left horizontal alignment *)
    LXW_ALIGN_LEFT = 1,
    (** Center horizontal alignment *)
    LXW_ALIGN_CENTER = 2,
    (** Right horizontal alignment *)
    LXW_ALIGN_RIGHT = 3,
    (** Cell fill horizontal alignment *)
    LXW_ALIGN_FILL = 4,
    (** Justify horizontal alignment *)
    LXW_ALIGN_JUSTIFY = 5,
    (** Center Across horizontal alignment *)
    LXW_ALIGN_CENTER_ACROSS = 6,
    (** Left horizontal alignment *)
    LXW_ALIGN_DISTRIBUTED = 7,
    (** Top vertical alignment *)
    LXW_ALIGN_VERTICAL_TOP = 8,
    (** Bottom vertical alignment *)
    LXW_ALIGN_VERTICAL_BOTTOM = 9,
    (** Center vertical alignment *)
    LXW_ALIGN_VERTICAL_CENTER = 10,
    (** Justify vertical alignment *)
    LXW_ALIGN_VERTICAL_JUSTIFY = 11,
    (** Distributed vertical alignment *)
    LXW_ALIGN_VERTICAL_DISTRIBUTED = 12);
  Plxw_format_alignments = ^lxw_format_alignments;

  (**
   * Diagonal border types.
   *
   *)
  lxw_format_diagonal_types = (
    (** Cell diagonal border from bottom left to top right. *)
    LXW_DIAGONAL_BORDER_UP = 1,
    (** Cell diagonal border from top left to bottom right. *)
    LXW_DIAGONAL_BORDER_DOWN = 2,
    (** Cell diagonal border in both directions. *)
    LXW_DIAGONAL_BORDER_UP_DOWN = 3);
  Plxw_format_diagonal_types = ^lxw_format_diagonal_types;

  (** Predefined values for common colors. *)
  lxw_defined_colors = (
    (** Black *)
    LXW_COLOR_BLACK = 16777216,
    (** Blue *)
    LXW_COLOR_BLUE = 255,
    (** Brown *)
    LXW_COLOR_BROWN = 8388608,
    (** Cyan *)
    LXW_COLOR_CYAN = 65535,
    (** Gray *)
    LXW_COLOR_GRAY = 8421504,
    (** Green *)
    LXW_COLOR_GREEN = 32768,
    (** Lime *)
    LXW_COLOR_LIME = 65280,
    (** Magenta *)
    LXW_COLOR_MAGENTA = 16711935,
    (** Navy *)
    LXW_COLOR_NAVY = 128,
    (** Orange *)
    LXW_COLOR_ORANGE = 16737792,
    (** Pink *)
    LXW_COLOR_PINK = 16711935,
    (** Purple *)
    LXW_COLOR_PURPLE = 8388736,
    (** Red *)
    LXW_COLOR_RED = 16711680,
    (** Silver *)
    LXW_COLOR_SILVER = 12632256,
    (** White *)
    LXW_COLOR_WHITE = 16777215,
    (** Yellow *)
    LXW_COLOR_YELLOW = 16776960);
  Plxw_defined_colors = ^lxw_defined_colors;

  (** Pattern value for use with format_set_pattern(). *)
  lxw_format_patterns = (
    (** Empty pattern *)
    LXW_PATTERN_NONE = 0,
    (** Solid pattern *)
    LXW_PATTERN_SOLID = 1,
    (** Medium gray pattern *)
    LXW_PATTERN_MEDIUM_GRAY = 2,
    (** Dark gray pattern *)
    LXW_PATTERN_DARK_GRAY = 3,
    (** Light gray pattern *)
    LXW_PATTERN_LIGHT_GRAY = 4,
    (** Dark horizontal line pattern *)
    LXW_PATTERN_DARK_HORIZONTAL = 5,
    (** Dark vertical line pattern *)
    LXW_PATTERN_DARK_VERTICAL = 6,
    (** Dark diagonal stripe pattern *)
    LXW_PATTERN_DARK_DOWN = 7,
    (** Reverse dark diagonal stripe pattern *)
    LXW_PATTERN_DARK_UP = 8,
    (** Dark grid pattern *)
    LXW_PATTERN_DARK_GRID = 9,
    (** Dark trellis pattern *)
    LXW_PATTERN_DARK_TRELLIS = 10,
    (** Light horizontal Line pattern *)
    LXW_PATTERN_LIGHT_HORIZONTAL = 11,
    (** Light vertical line pattern *)
    LXW_PATTERN_LIGHT_VERTICAL = 12,
    (** Light diagonal stripe pattern *)
    LXW_PATTERN_LIGHT_DOWN = 13,
    (** Reverse light diagonal stripe pattern *)
    LXW_PATTERN_LIGHT_UP = 14,
    (** Light grid pattern *)
    LXW_PATTERN_LIGHT_GRID = 15,
    (** Light trellis pattern *)
    LXW_PATTERN_LIGHT_TRELLIS = 16,
    (** 12.5% gray pattern *)
    LXW_PATTERN_GRAY_125 = 17,
    (** 6.25% gray pattern *)
    LXW_PATTERN_GRAY_0625 = 18);
  Plxw_format_patterns = ^lxw_format_patterns;

  (** Cell border styles for use with format_set_border(). *)
  lxw_format_borders = (
    (** No border *)
    LXW_BORDER_NONE = 0,
    (** Thin border style *)
    LXW_BORDER_THIN = 1,
    (** Medium border style *)
    LXW_BORDER_MEDIUM = 2,
    (** Dashed border style *)
    LXW_BORDER_DASHED = 3,
    (** Dotted border style *)
    LXW_BORDER_DOTTED = 4,
    (** Thick border style *)
    LXW_BORDER_THICK = 5,
    (** Double border style *)
    LXW_BORDER_DOUBLE = 6,
    (** Hair border style *)
    LXW_BORDER_HAIR = 7,
    (** Medium dashed border style *)
    LXW_BORDER_MEDIUM_DASHED = 8,
    (** Dash-dot border style *)
    LXW_BORDER_DASH_DOT = 9,
    (** Medium dash-dot border style *)
    LXW_BORDER_MEDIUM_DASH_DOT = 10,
    (** Dash-dot-dot border style *)
    LXW_BORDER_DASH_DOT_DOT = 11,
    (** Medium dash-dot-dot border style *)
    LXW_BORDER_MEDIUM_DASH_DOT_DOT = 12,
    (** Slant dash-dot border style *)
    LXW_BORDER_SLANT_DASH_DOT = 13);
  Plxw_format_borders = ^lxw_format_borders;

  P_anonymous_type_8 = ^_anonymous_type_8;
  _anonymous_type_8 = record
    stqe_next: Plxw_format;
  end;

  (**
   * @brief Struct to represent the formatting properties of an Excel format.
   *
   * Formats in `libxlsxwriter` are accessed via this struct.
   *
   * The members of the lxw_format struct aren't modified directly. Instead the
   * format properties are set by calling the functions shown in format.h.
   *
   * For example:
   *
   * @code
   *    // Create the Format.
   *    lxw_format *format = workbook_add_format(workbook);
   *
   *    // Set some of the format properties.
   *    format_set_bold(format);
   *    format_set_font_color(format, LXW_COLOR_RED);
   *
   *    // Use the format to change the text format in a cell.
   *    worksheet_write_string(worksheet, 0, 0, "Hello", format);
   *
   * @endcode
   *
   *)
  lxw_format = record
    _file: PPointer;
    xf_format_indices: Plxw_hash_table;
    dxf_format_indices: Plxw_hash_table;
    num_xf_formats: PUInt16;
    num_dxf_formats: PUInt16;
    xf_index: Int32;
    dxf_index: Int32;
    xf_id: Int32;
    num_format: array [0..127] of UTF8Char;
    font_name: array [0..127] of UTF8Char;
    font_scheme: array [0..127] of UTF8Char;
    num_format_index: UInt16;
    font_index: UInt16;
    has_font: UInt8;
    has_dxf_font: UInt8;
    font_size: Double;
    bold: UInt8;
    italic: UInt8;
    font_color: lxw_color_t;
    underline: UInt8;
    font_strikeout: UInt8;
    font_outline: UInt8;
    font_shadow: UInt8;
    font_script: UInt8;
    font_family: UInt8;
    font_charset: UInt8;
    font_condense: UInt8;
    font_extend: UInt8;
    theme: UInt8;
    hyperlink: UInt8;
    hidden: UInt8;
    locked: UInt8;
    text_h_align: UInt8;
    text_wrap: UInt8;
    text_v_align: UInt8;
    text_justlast: UInt8;
    rotation: Int16;
    fg_color: lxw_color_t;
    bg_color: lxw_color_t;
    dxf_fg_color: lxw_color_t;
    dxf_bg_color: lxw_color_t;
    pattern: UInt8;
    has_fill: UInt8;
    has_dxf_fill: UInt8;
    fill_index: Int32;
    fill_count: Int32;
    border_index: Int32;
    has_border: UInt8;
    has_dxf_border: UInt8;
    border_count: Int32;
    bottom: UInt8;
    diag_border: UInt8;
    diag_type: UInt8;
    left: UInt8;
    right: UInt8;
    top: UInt8;
    bottom_color: lxw_color_t;
    diag_color: lxw_color_t;
    left_color: lxw_color_t;
    right_color: lxw_color_t;
    top_color: lxw_color_t;
    indent: UInt8;
    shrink: UInt8;
    merge_range: UInt8;
    reading_order: UInt8;
    just_distrib: UInt8;
    color_indexed: UInt8;
    font_only: UInt8;
    quote_prefix: UInt8;
    list_pointers: _anonymous_type_8;
  end;

  lxw_font = record
    font_name: array [0..127] of UTF8Char;
    font_size: Double;
    bold: UInt8;
    italic: UInt8;
    underline: UInt8;
    theme: UInt8;
    font_strikeout: UInt8;
    font_outline: UInt8;
    font_shadow: UInt8;
    font_script: UInt8;
    font_family: UInt8;
    font_charset: UInt8;
    font_condense: UInt8;
    font_extend: UInt8;
    font_color: lxw_color_t;
  end;

  lxw_border = record
    bottom: UInt8;
    diag_border: UInt8;
    diag_type: UInt8;
    left: UInt8;
    right: UInt8;
    top: UInt8;
    bottom_color: lxw_color_t;
    diag_color: lxw_color_t;
    left_color: lxw_color_t;
    right_color: lxw_color_t;
    top_color: lxw_color_t;
  end;

  lxw_fill = record
    fg_color: lxw_color_t;
    bg_color: lxw_color_t;
    pattern: UInt8;
  end;

  lxw_chart_series_list = record
    stqh_first: Plxw_chart_series;
    stqh_last: PPlxw_chart_series;
  end;

  lxw_series_data_points = record
    stqh_first: Plxw_series_data_point;
    stqh_last: PPlxw_series_data_point;
  end;

  (**
   * @brief Available chart types.
   *)
  lxw_chart_type = (
    (** None. *)
    LXW_CHART_NONE = 0,
    (** Area chart. *)
    LXW_CHART_AREA = 1,
    (** Area chart - stacked. *)
    LXW_CHART_AREA_STACKED = 2,
    (** Area chart - percentage stacked. *)
    LXW_CHART_AREA_STACKED_PERCENT = 3,
    (** Bar chart. *)
    LXW_CHART_BAR = 4,
    (** Bar chart - stacked. *)
    LXW_CHART_BAR_STACKED = 5,
    (** Bar chart - percentage stacked. *)
    LXW_CHART_BAR_STACKED_PERCENT = 6,
    (** Column chart. *)
    LXW_CHART_COLUMN = 7,
    (** Column chart - stacked. *)
    LXW_CHART_COLUMN_STACKED = 8,
    (** Column chart - percentage stacked. *)
    LXW_CHART_COLUMN_STACKED_PERCENT = 9,
    (** Doughnut chart. *)
    LXW_CHART_DOUGHNUT = 10,
    (** Line chart. *)
//    LXW_CHART_LINE = 11,
    LXW_CHART_LINE_CC = 11,
    (** Line chart - stacked. *)
    LXW_CHART_LINE_STACKED = 12,
    (** Line chart - percentage stacked. *)
    LXW_CHART_LINE_STACKED_PERCENT = 13,
    (** Pie chart. *)
    LXW_CHART_PIE = 14,
    (** Scatter chart. *)
    LXW_CHART_SCATTER = 15,
    (** Scatter chart - straight. *)
    LXW_CHART_SCATTER_STRAIGHT = 16,
    (** Scatter chart - straight with markers. *)
    LXW_CHART_SCATTER_STRAIGHT_WITH_MARKERS = 17,
    (** Scatter chart - smooth. *)
    LXW_CHART_SCATTER_SMOOTH = 18,
    (** Scatter chart - smooth with markers. *)
    LXW_CHART_SCATTER_SMOOTH_WITH_MARKERS = 19,
    (** Radar chart. *)
    LXW_CHART_RADAR = 20,
    (** Radar chart - with markers. *)
    LXW_CHART_RADAR_WITH_MARKERS = 21,
    (** Radar chart - filled. *)
    LXW_CHART_RADAR_FILLED = 22);
  Plxw_chart_type = ^lxw_chart_type;

  (**
   * @brief Chart legend positions.
   *)
  lxw_chart_legend_position = (
    (** No chart legend. *)
    LXW_CHART_LEGEND_NONE = 0,
    (** Chart legend positioned at right side. *)
    LXW_CHART_LEGEND_RIGHT = 1,
    (** Chart legend positioned at left side. *)
    LXW_CHART_LEGEND_LEFT = 2,
    (** Chart legend positioned at top. *)
    LXW_CHART_LEGEND_TOP = 3,
    (** Chart legend positioned at bottom. *)
    LXW_CHART_LEGEND_BOTTOM = 4,
    (** Chart legend positioned at top right. *)
    LXW_CHART_LEGEND_TOP_RIGHT = 5,
    (** Chart legend overlaid at right side. *)
    LXW_CHART_LEGEND_OVERLAY_RIGHT = 6,
    (** Chart legend overlaid at left side. *)
    LXW_CHART_LEGEND_OVERLAY_LEFT = 7,
    (** Chart legend overlaid at top right. *)
    LXW_CHART_LEGEND_OVERLAY_TOP_RIGHT = 8);
  Plxw_chart_legend_position = ^lxw_chart_legend_position;

  (**
   * @brief Chart line dash types.
   *
   * The dash types are shown in the order that they appear in the Excel dialog.
   * See @ref chart_lines.
   *)
  lxw_chart_line_dash_type = (
    (** Solid. *)
    LXW_CHART_LINE_DASH_SOLID = 0,
    (** Round Dot. *)
    LXW_CHART_LINE_DASH_ROUND_DOT = 1,
    (** Square Dot. *)
    LXW_CHART_LINE_DASH_SQUARE_DOT = 2,
    (** Dash. *)
    LXW_CHART_LINE_DASH_DASH = 3,
    (** Dash Dot. *)
    LXW_CHART_LINE_DASH_DASH_DOT = 4,
    (** Long Dash. *)
    LXW_CHART_LINE_DASH_LONG_DASH = 5,
    (** Long Dash Dot. *)
    LXW_CHART_LINE_DASH_LONG_DASH_DOT = 6,
    (** Long Dash Dot Dot. *)
    LXW_CHART_LINE_DASH_LONG_DASH_DOT_DOT = 7,
    (** Long Dash Dot Dot. *)
    LXW_CHART_LINE_DASH_DOT = 8,
    (** Long Dash Dot Dot. *)
    LXW_CHART_LINE_DASH_SYSTEM_DASH_DOT = 9,
    (** Long Dash Dot Dot. *)
    LXW_CHART_LINE_DASH_SYSTEM_DASH_DOT_DOT = 10);
  Plxw_chart_line_dash_type = ^lxw_chart_line_dash_type;

  (**
   * @brief Chart marker types.
   *)
  lxw_chart_marker_type = (
    (** Automatic, series default, marker type. *)
    LXW_CHART_MARKER_AUTOMATIC = 0,
    (** No marker type. *)
    LXW_CHART_MARKER_NONE = 1,
    (** Square marker type. *)
    LXW_CHART_MARKER_SQUARE = 2,
    (** Diamond marker type. *)
    LXW_CHART_MARKER_DIAMOND = 3,
    (** Triangle marker type. *)
    LXW_CHART_MARKER_TRIANGLE = 4,
    (** X shape marker type. *)
    LXW_CHART_MARKER_X = 5,
    (** Star marker type. *)
    LXW_CHART_MARKER_STAR = 6,
    (** Short dash marker type. *)
    LXW_CHART_MARKER_SHORT_DASH = 7,
    (** Long dash marker type. *)
    LXW_CHART_MARKER_LONG_DASH = 8,
    (** Circle marker type. *)
    LXW_CHART_MARKER_CIRCLE = 9,
    (** Plus (+) marker type. *)
    LXW_CHART_MARKER_PLUS = 10);
  Plxw_chart_marker_type = ^lxw_chart_marker_type;

  (**
   * @brief Chart pattern types.
   *)
  lxw_chart_pattern_type = (
    (** None pattern. *)
    LXW_CHART_PATTERN_NONE = 0,
    (** 5 Percent pattern. *)
    LXW_CHART_PATTERN_PERCENT_5 = 1,
    (** 10 Percent pattern. *)
    LXW_CHART_PATTERN_PERCENT_10 = 2,
    (** 20 Percent pattern. *)
    LXW_CHART_PATTERN_PERCENT_20 = 3,
    (** 25 Percent pattern. *)
    LXW_CHART_PATTERN_PERCENT_25 = 4,
    (** 30 Percent pattern. *)
    LXW_CHART_PATTERN_PERCENT_30 = 5,
    (** 40 Percent pattern. *)
    LXW_CHART_PATTERN_PERCENT_40 = 6,
    (** 50 Percent pattern. *)
    LXW_CHART_PATTERN_PERCENT_50 = 7,
    (** 60 Percent pattern. *)
    LXW_CHART_PATTERN_PERCENT_60 = 8,
    (** 70 Percent pattern. *)
    LXW_CHART_PATTERN_PERCENT_70 = 9,
    (** 75 Percent pattern. *)
    LXW_CHART_PATTERN_PERCENT_75 = 10,
    (** 80 Percent pattern. *)
    LXW_CHART_PATTERN_PERCENT_80 = 11,
    (** 90 Percent pattern. *)
    LXW_CHART_PATTERN_PERCENT_90 = 12,
    (** Light downward diagonal pattern. *)
    LXW_CHART_PATTERN_LIGHT_DOWNWARD_DIAGONAL = 13,
    (** Light upward diagonal pattern. *)
    LXW_CHART_PATTERN_LIGHT_UPWARD_DIAGONAL = 14,
    (** Dark downward diagonal pattern. *)
    LXW_CHART_PATTERN_DARK_DOWNWARD_DIAGONAL = 15,
    (** Dark upward diagonal pattern. *)
    LXW_CHART_PATTERN_DARK_UPWARD_DIAGONAL = 16,
    (** Wide downward diagonal pattern. *)
    LXW_CHART_PATTERN_WIDE_DOWNWARD_DIAGONAL = 17,
    (** Wide upward diagonal pattern. *)
    LXW_CHART_PATTERN_WIDE_UPWARD_DIAGONAL = 18,
    (** Light vertical pattern. *)
    LXW_CHART_PATTERN_LIGHT_VERTICAL = 19,
    (** Light horizontal pattern. *)
    LXW_CHART_PATTERN_LIGHT_HORIZONTAL = 20,
    (** Narrow vertical pattern. *)
    LXW_CHART_PATTERN_NARROW_VERTICAL = 21,
    (** Narrow horizontal pattern. *)
    LXW_CHART_PATTERN_NARROW_HORIZONTAL = 22,
    (** Dark vertical pattern. *)
    LXW_CHART_PATTERN_DARK_VERTICAL = 23,
    (** Dark horizontal pattern. *)
    LXW_CHART_PATTERN_DARK_HORIZONTAL = 24,
    (** Dashed downward diagonal pattern. *)
    LXW_CHART_PATTERN_DASHED_DOWNWARD_DIAGONAL = 25,
    (** Dashed upward diagonal pattern. *)
    LXW_CHART_PATTERN_DASHED_UPWARD_DIAGONAL = 26,
    (** Dashed horizontal pattern. *)
    LXW_CHART_PATTERN_DASHED_HORIZONTAL = 27,
    (** Dashed vertical pattern. *)
    LXW_CHART_PATTERN_DASHED_VERTICAL = 28,
    (** Small confetti pattern. *)
    LXW_CHART_PATTERN_SMALL_CONFETTI = 29,
    (** Large confetti pattern. *)
    LXW_CHART_PATTERN_LARGE_CONFETTI = 30,
    (** Zigzag pattern. *)
    LXW_CHART_PATTERN_ZIGZAG = 31,
    (** Wave pattern. *)
    LXW_CHART_PATTERN_WAVE = 32,
    (** Diagonal brick pattern. *)
    LXW_CHART_PATTERN_DIAGONAL_BRICK = 33,
    (** Horizontal brick pattern. *)
    LXW_CHART_PATTERN_HORIZONTAL_BRICK = 34,
    (** Weave pattern. *)
    LXW_CHART_PATTERN_WEAVE = 35,
    (** Plaid pattern. *)
    LXW_CHART_PATTERN_PLAID = 36,
    (** Divot pattern. *)
    LXW_CHART_PATTERN_DIVOT = 37,
    (** Dotted grid pattern. *)
    LXW_CHART_PATTERN_DOTTED_GRID = 38,
    (** Dotted diamond pattern. *)
    LXW_CHART_PATTERN_DOTTED_DIAMOND = 39,
    (** Shingle pattern. *)
    LXW_CHART_PATTERN_SHINGLE = 40,
    (** Trellis pattern. *)
    LXW_CHART_PATTERN_TRELLIS = 41,
    (** Sphere pattern. *)
    LXW_CHART_PATTERN_SPHERE = 42,
    (** Small grid pattern. *)
    LXW_CHART_PATTERN_SMALL_GRID = 43,
    (** Large grid pattern. *)
    LXW_CHART_PATTERN_LARGE_GRID = 44,
    (** Small check pattern. *)
    LXW_CHART_PATTERN_SMALL_CHECK = 45,
    (** Large check pattern. *)
    LXW_CHART_PATTERN_LARGE_CHECK = 46,
    (** Outlined diamond pattern. *)
    LXW_CHART_PATTERN_OUTLINED_DIAMOND = 47,
    (** Solid diamond pattern. *)
    LXW_CHART_PATTERN_SOLID_DIAMOND = 48);
  Plxw_chart_pattern_type = ^lxw_chart_pattern_type;

  (**
   * @brief Chart data label positions.
   *)
  lxw_chart_label_position = (
    (** Series data label position: default position. *)
    LXW_CHART_LABEL_POSITION_DEFAULT = 0,
    (** Series data label position: center. *)
    LXW_CHART_LABEL_POSITION_CENTER = 1,
    (** Series data label position: right. *)
    LXW_CHART_LABEL_POSITION_RIGHT = 2,
    (** Series data label position: left. *)
    LXW_CHART_LABEL_POSITION_LEFT = 3,
    (** Series data label position: above. *)
    LXW_CHART_LABEL_POSITION_ABOVE = 4,
    (** Series data label position: below. *)
    LXW_CHART_LABEL_POSITION_BELOW = 5,
    (** Series data label position: inside base.  *)
    LXW_CHART_LABEL_POSITION_INSIDE_BASE = 6,
    (** Series data label position: inside end. *)
    LXW_CHART_LABEL_POSITION_INSIDE_END = 7,
    (** Series data label position: outside end. *)
    LXW_CHART_LABEL_POSITION_OUTSIDE_END = 8,
    (** Series data label position: best fit. *)
    LXW_CHART_LABEL_POSITION_BEST_FIT = 9);
  Plxw_chart_label_position = ^lxw_chart_label_position;

  (**
   * @brief Chart data label separator.
   *)
  lxw_chart_label_separator = (
    (** Series data label separator: comma (the default). *)
    LXW_CHART_LABEL_SEPARATOR_COMMA = 0,
    (** Series data label separator: semicolon. *)
    LXW_CHART_LABEL_SEPARATOR_SEMICOLON = 1,
    (** Series data label separator: period. *)
    LXW_CHART_LABEL_SEPARATOR_PERIOD = 2,
    (** Series data label separator: newline. *)
    LXW_CHART_LABEL_SEPARATOR_NEWLINE = 3,
    (** Series data label separator: space. *)
    LXW_CHART_LABEL_SEPARATOR_SPACE = 4);
  Plxw_chart_label_separator = ^lxw_chart_label_separator;

  (**
   * @brief Chart axis types.
   *)
  lxw_chart_axis_type = (
    (** Chart X axis. *)
    LXW_CHART_AXIS_TYPE_X = 0,
    (** Chart Y axis. *)
    LXW_CHART_AXIS_TYPE_Y = 1);
  Plxw_chart_axis_type = ^lxw_chart_axis_type;

  lxw_chart_subtype = (
    LXW_CHART_SUBTYPE_NONE = 0,
    LXW_CHART_SUBTYPE_STACKED = 1,
    LXW_CHART_SUBTYPE_STACKED_PERCENT = 2);
  Plxw_chart_subtype = ^lxw_chart_subtype;

  lxw_chart_grouping = (
    LXW_GROUPING_CLUSTERED = 0,
    LXW_GROUPING_STANDARD = 1,
    LXW_GROUPING_PERCENTSTACKED = 2,
    LXW_GROUPING_STACKED = 3);
  Plxw_chart_grouping = ^lxw_chart_grouping;

  (**
   * @brief Axis positions for category axes.
   *)
  lxw_chart_axis_tick_position = (
    LXW_CHART_AXIS_POSITION_DEFAULT = 0,
    (** Position category axis on tick marks. *)
    LXW_CHART_AXIS_POSITION_ON_TICK = 1,
    (** Position category axis between tick marks. *)
    LXW_CHART_AXIS_POSITION_BETWEEN = 2);
  Plxw_chart_axis_tick_position = ^lxw_chart_axis_tick_position;

  (**
   * @brief Axis label positions.
   *)
  lxw_chart_axis_label_position = (
    (** Position the axis labels next to the axis. The default. *)
    LXW_CHART_AXIS_LABEL_POSITION_NEXT_TO = 0,
    (** Position the axis labels at the top of the chart, for horizontal
     * axes, or to the right for vertical axes.*)
    LXW_CHART_AXIS_LABEL_POSITION_HIGH = 1,
    (** Position the axis labels at the bottom of the chart, for horizontal
     * axes, or to the left for vertical axes.*)
    LXW_CHART_AXIS_LABEL_POSITION_LOW = 2,
    (** Turn off the the axis labels. *)
    LXW_CHART_AXIS_LABEL_POSITION_NONE = 3);
  Plxw_chart_axis_label_position = ^lxw_chart_axis_label_position;

  (**
   * @brief Axis label alignments.
   *)
  lxw_chart_axis_label_alignment = (
    (** Chart axis label alignment: center. *)
    LXW_CHART_AXIS_LABEL_ALIGN_CENTER = 0,
    (** Chart axis label alignment: left. *)
    LXW_CHART_AXIS_LABEL_ALIGN_LEFT = 1,
    (** Chart axis label alignment: right. *)
    LXW_CHART_AXIS_LABEL_ALIGN_RIGHT = 2);
  Plxw_chart_axis_label_alignment = ^lxw_chart_axis_label_alignment;

  (**
   * @brief Display units for chart value axis.
   *)
  lxw_chart_axis_display_unit = (
    (** Axis display units: None. The default. *)
    LXW_CHART_AXIS_UNITS_NONE = 0,
    (** Axis display units: Hundreds. *)
    LXW_CHART_AXIS_UNITS_HUNDREDS = 1,
    (** Axis display units: Thousands. *)
    LXW_CHART_AXIS_UNITS_THOUSANDS = 2,
    (** Axis display units: Ten thousands. *)
    LXW_CHART_AXIS_UNITS_TEN_THOUSANDS = 3,
    (** Axis display units: Hundred thousands. *)
    LXW_CHART_AXIS_UNITS_HUNDRED_THOUSANDS = 4,
    (** Axis display units: Millions. *)
    LXW_CHART_AXIS_UNITS_MILLIONS = 5,
    (** Axis display units: Ten millions. *)
    LXW_CHART_AXIS_UNITS_TEN_MILLIONS = 6,
    (** Axis display units: Hundred millions. *)
    LXW_CHART_AXIS_UNITS_HUNDRED_MILLIONS = 7,
    (** Axis display units: Billions. *)
    LXW_CHART_AXIS_UNITS_BILLIONS = 8,
    (** Axis display units: Trillions. *)
    LXW_CHART_AXIS_UNITS_TRILLIONS = 9);
  Plxw_chart_axis_display_unit = ^lxw_chart_axis_display_unit;

  (**
   * @brief Tick mark types for an axis.
   *)
  lxw_chart_axis_tick_mark = (
    (** Default tick mark for the chart axis. Usually outside. *)
    LXW_CHART_AXIS_TICK_MARK_DEFAULT = 0,
    (** No tick mark for the axis. *)
    LXW_CHART_AXIS_TICK_MARK_NONE = 1,
    (** Tick mark inside the axis only. *)
    LXW_CHART_AXIS_TICK_MARK_INSIDE = 2,
    (** Tick mark outside the axis only. *)
    LXW_CHART_AXIS_TICK_MARK_OUTSIDE = 3,
    (** Tick mark inside and outside the axis. *)
    LXW_CHART_AXIS_TICK_MARK_CROSSING = 4);
  Plxw_chart_axis_tick_mark = ^lxw_chart_axis_tick_mark;
  (**
   * @brief Tick mark types for an axis.
   *)
  lxw_chart_tick_mark = lxw_chart_axis_tick_mark;

  lxw_series_range = record
    formula: PUTF8Char;
    sheetname: PUTF8Char;
    first_row: lxw_row_t;
    last_row: lxw_row_t;
    first_col: lxw_col_t;
    last_col: lxw_col_t;
    ignore_cache: UInt8;
    has_string_cache: UInt8;
    num_data_points: UInt16;
    data_cache: Plxw_series_data_points;
  end;

  P_anonymous_type_9 = ^_anonymous_type_9;
  _anonymous_type_9 = record
    stqe_next: Plxw_series_data_point;
  end;

  lxw_series_data_point = record
    is_string: UInt8;
    number: Double;
    _str: PUTF8Char;
    no_data: UInt8;
    list_pointers: _anonymous_type_9;
  end;

  (**
   * @brief Struct to represent a chart line.
   *
   * See @ref chart_lines.
   *)
  lxw_chart_line = packed record
    (** The chart font color. See @ref working_with_colors. *)
    color: lxw_color_t;
    (** Turn off/hide line. Set to 0 or 1.*)
    none: UInt8;
    (** Width of the line in increments of 0.25. Default is 2.25. *)
    width: Single;
    (** The line dash type. See #lxw_chart_line_dash_type. *)
    dash_type: UInt8;
    (** Set the transparency of the line. 0 - 100. Default 0. *)
    transparency: UInt8;
  end;

  (**
   * @brief Struct to represent a chart fill.
   *
   * See @ref chart_fills.
   *)
  lxw_chart_fill = packed record
    (** The chart font color. See @ref working_with_colors. *)
    color: lxw_color_t;
    (** Turn off/hide line. Set to 0 or 1.*)
    none: UInt8;
    (** Set the transparency of the fill. 0 - 100. Default 0. *)
    transparency: UInt8;
  end;

  (**
   * @brief Struct to represent a chart pattern.
   *
   * See @ref chart_patterns.
   *)
  lxw_chart_pattern = packed record
    (** The pattern foreground color. See @ref working_with_colors. *)
    fg_color: lxw_color_t;
    (** The pattern background color. See @ref working_with_colors. *)
    bg_color: lxw_color_t;
    (** The pattern type. See #lxw_chart_pattern_type. *)
    _type: UInt8;
  end;

  (**
   * @brief Struct to represent a chart font.
   *
   * See @ref chart_fonts.
   *)
  lxw_chart_font = packed record
    (** The chart font name, such as "Arial" or "Calibri". *)
    name: PUTF8Char;
    (** The chart font size. The default is 11. *)
    size: Double;
    (** The chart font bold property. Set to 0 or 1. *)
    bold: UInt8;
    (** The chart font italic property. Set to 0 or 1. *)
    italic: UInt8;
    (** The chart font underline property. Set to 0 or 1. *)
    underline: UInt8;
    (** The chart font rotation property. Range: -90 to 90, and 270, 271 and 360:
     *
     *  - The angles -90 to 90 are the normal range shown in the Excel user interface.
     *  - The angle 270 gives a stacked (top to bottom) alignment.
     *  - The angle 271 gives a stacked alignment for East Asian fonts.
     *  - The angle 360 gives an explicit angle of 0 to override the y axis default.
     * *)
    rotation: Int32;
    (** The chart font color. See @ref working_with_colors. *)
    color: lxw_color_t;
    (** The chart font pitch family property. Rarely required, set to 0. *)
    pitch_family: UInt8;
    (** The chart font character set property. Rarely required, set to 0. *)
    charset: UInt8;
    (** The chart font baseline property. Rarely required, set to 0. *)
    baseline: Int8;
  end;

  (**
   * @brief Struct to represent Excel chart element layout dimensions.
   *
   * Excel supports manual positioning of elements such as the chart axis labels,
   * the chart legend, the chart plot area and the chart title. The
   * `lxw_chart_layout` struct represents the layout dimension for these elements.
   *
   * The layout units used by Excel are relative units expressed as a percentage
   * of the chart dimensions and are double values in the range `0.0 < x <= 1.0`.
   * Excel calculates these dimensions as shown below:
   *
   * @image html chart_layout.png
   *
   * With reference to the above figure the layout units are calculated as
   * follows:
   *
   * ```text
   *     x = a / W
   *     y = b / H
   * ```
   *
   * These units are cumbersome and can vary depending on other elements in the
   * chart such as text lengths. However, these are the units that are required by
   * Excel to allow relative positioning. Some trial and error is generally
   * required.
   *
   * For the chart `chart_plotarea_set_layout()` and `chart_legend_set_layout()`
   * functions you can also set the width and height based on the following
   * calculation:
   *
   * ```text
   *     width  = w / W
   *     height = h / H
   * ```
   *
   * For other text based objects the width and height are changed by the font
   * dimensions.
   *
   * The chart functions that support `lxw_chart_layout` are:
   *
   * - `chart_title_set_layout()`
   * - `chart_legend_set_layout()`
   * - `chart_plotarea_set_layout()`
   * - `chart_axis_set_name_layout()`
   *
   *)
  lxw_chart_layout = record
    (** The x offset in the range `0.0 < x <= 1.0` *)
    x: Double;
    (** The y offset in the range `0.0 < y <= 1.0` *)
    y: Double;
    (** The width of the plotarea or legend in the range `0.0 < x <= 1.0` *)
    width: Double;
    (** The height of the plotarea or legend in the range `0.0 < x <= 1.0` *)
    height: Double;
    has_inner: UInt8;
  end;

  lxw_chart_marker = record
    _type: UInt8;
    size: UInt8;
    line: Plxw_chart_line;
    fill: Plxw_chart_fill;
    pattern: Plxw_chart_pattern;
  end;

  lxw_chart_legend = record
    font: Plxw_chart_font;
    position: UInt8;
    layout: Plxw_chart_layout;
  end;

  lxw_chart_title = record
    name: PUTF8Char;
    row: lxw_row_t;
    col: lxw_col_t;
    font: Plxw_chart_font;
    off: UInt8;
    is_horizontal: UInt8;
    ignore_cache: UInt8;
    has_overlay: UInt8;
    range: Plxw_series_range;
    data_point: lxw_series_data_point;
    layout: Plxw_chart_layout;
  end;

  (**
   * @brief Struct to represent an Excel chart data point.
   *
   * The lxw_chart_point used to set the line, fill and pattern of one or more
   * points in a chart data series. See @ref chart_points.
   *)
  lxw_chart_point = record
    (** The line/border for the chart point. See @ref chart_lines. *)
    line: Plxw_chart_line;
    (** The fill for the chart point. See @ref chart_fills. *)
    fill: Plxw_chart_fill;
    (** The pattern for the chart point. See @ref chart_patterns.*)
    pattern: Plxw_chart_pattern;
  end;

  (**
   * @brief Struct to represent an Excel chart data label.
   *
   * The lxw_chart_data_label struct is used to represent a data label in a
   * chart series so that custom properties can be set for it.
   *)
  lxw_chart_data_label = packed record
    (** The string or formula value for the data label. See
     *  @ref chart_custom_labels. *)
    value: PUTF8Char;
    (** Option to hide/delete the data label from the chart series.
     *  See @ref chart_custom_labels. *)
    hide: UInt8;
    (** The font properties for the chart data label. @ref chart_fonts. *)
    font: Plxw_chart_font;
    (** The line/border for the chart data label. See @ref chart_lines. *)
    line: Plxw_chart_line;
    (** The fill for the chart data label. See @ref chart_fills. *)
    fill: Plxw_chart_fill;
    (** The pattern for the chart data label. See @ref chart_patterns.*)
    pattern: Plxw_chart_pattern;
  end;

  lxw_chart_custom_label = record
    value: PUTF8Char;
    hide: UInt8;
    font: Plxw_chart_font;
    line: Plxw_chart_line;
    fill: Plxw_chart_fill;
    pattern: Plxw_chart_pattern;
    range: Plxw_series_range;
    data_point: lxw_series_data_point;
  end;

  (**
   * @brief Define how blank values are displayed in a chart.
   *)
  lxw_chart_blank = (
    (** Show empty chart cells as gaps in the data. The default. *)
    LXW_CHART_BLANKS_AS_GAP = 0,
    (** Show empty chart cells as zeros. *)
    LXW_CHART_BLANKS_AS_ZERO = 1,
    (** Show empty chart cells as connected. Only for charts with lines. *)
    LXW_CHART_BLANKS_AS_CONNECTED = 2);
  Plxw_chart_blank = ^lxw_chart_blank;

  lxw_chart_position = (
    LXW_CHART_AXIS_RIGHT = 0,
    LXW_CHART_AXIS_LEFT = 1,
    LXW_CHART_AXIS_TOP = 2,
    LXW_CHART_AXIS_BOTTOM = 3);
  Plxw_chart_position = ^lxw_chart_position;

  lxw_chart_layout_type = (
    LXW_CHART_LAYOUT_TITLE = 0,
    LXW_CHART_LAYOUT_LEGEND = 1,
    LXW_CHART_LAYOUT_PLOTAREA = 2,
    LXW_CHART_LAYOUT_AXIS_NAME = 3);
  Plxw_chart_layout_type = ^lxw_chart_layout_type;

  (**
   * @brief Type/amount of data series error bar.
   *)
  lxw_chart_error_bar_type = (
    (** Error bar type: Standard error. *)
    LXW_CHART_ERROR_BAR_TYPE_STD_ERROR = 0,
    (** Error bar type: Fixed value. *)
    LXW_CHART_ERROR_BAR_TYPE_FIXED = 1,
    (** Error bar type: Percentage. *)
    LXW_CHART_ERROR_BAR_TYPE_PERCENTAGE = 2,
    (** Error bar type: Standard deviation(s). *)
    LXW_CHART_ERROR_BAR_TYPE_STD_DEV = 3);
  Plxw_chart_error_bar_type = ^lxw_chart_error_bar_type;

  (**
   * @brief Direction for a data series error bar.
   *)
  lxw_chart_error_bar_direction = (
    (** Error bar extends in both directions. The default. *)
    LXW_CHART_ERROR_BAR_DIR_BOTH = 0,
    (** Error bar extends in positive direction. *)
    LXW_CHART_ERROR_BAR_DIR_PLUS = 1,
    (** Error bar extends in negative direction. *)
    LXW_CHART_ERROR_BAR_DIR_MINUS = 2);
  Plxw_chart_error_bar_direction = ^lxw_chart_error_bar_direction;

  (**
   * @brief Direction for a data series error bar.
   *)
  lxw_chart_error_bar_axis = (
    (** X axis error bar. *)
    LXW_CHART_ERROR_BAR_AXIS_X = 0,
    (** Y axis error bar. *)
    LXW_CHART_ERROR_BAR_AXIS_Y = 1);
  Plxw_chart_error_bar_axis = ^lxw_chart_error_bar_axis;

  (**
   * @brief End cap styles for a data series error bar.
   *)
  lxw_chart_error_bar_cap = (
    (** Flat end cap. The default. *)
    LXW_CHART_ERROR_BAR_END_CAP = 0,
    (** No end cap. *)
    LXW_CHART_ERROR_BAR_NO_CAP = 1);
  Plxw_chart_error_bar_cap = ^lxw_chart_error_bar_cap;

  lxw_series_error_bars = record
    _type: UInt8;
    direction: UInt8;
    endcap: UInt8;
    has_value: UInt8;
    is_set: UInt8;
    is_x: UInt8;
    chart_group: UInt8;
    value: Double;
    line: Plxw_chart_line;
  end;

  (**
   * @brief Series trendline/regression types.
   *)
  lxw_chart_trendline_type = (
    (** Trendline type: Linear. *)
    LXW_CHART_TRENDLINE_TYPE_LINEAR = 0,
    (** Trendline type: Logarithm. *)
    LXW_CHART_TRENDLINE_TYPE_LOG = 1,
    (** Trendline type: Polynomial. *)
    LXW_CHART_TRENDLINE_TYPE_POLY = 2,
    (** Trendline type: Power. *)
    LXW_CHART_TRENDLINE_TYPE_POWER = 3,
    (** Trendline type: Exponential. *)
    LXW_CHART_TRENDLINE_TYPE_EXP = 4,
    (** Trendline type: Moving Average. *)
    LXW_CHART_TRENDLINE_TYPE_AVERAGE = 5);
  Plxw_chart_trendline_type = ^lxw_chart_trendline_type;

  P_anonymous_type_10 = ^_anonymous_type_10;
  _anonymous_type_10 = record
    stqe_next: Plxw_chart_series;
  end;

  (**
   * @brief Struct to represent an Excel chart data series.
   *
   * The lxw_chart_series is created using the chart_add_series function. It is
   * used in functions that modify a chart series but the members of the struct
   * aren't modified directly.
   *)
  lxw_chart_series = record
    categories: Plxw_series_range;
    values: Plxw_series_range;
    title: lxw_chart_title;
    line: Plxw_chart_line;
    fill: Plxw_chart_fill;
    pattern: Plxw_chart_pattern;
    marker: Plxw_chart_marker;
    points: Plxw_chart_point;
    data_labels: Plxw_chart_custom_label;
    point_count: UInt16;
    data_label_count: UInt16;
    smooth: UInt8;
    invert_if_negative: UInt8;
    has_labels: UInt8;
    show_labels_value: UInt8;
    show_labels_category: UInt8;
    show_labels_name: UInt8;
    show_labels_leader: UInt8;
    show_labels_legend: UInt8;
    show_labels_percent: UInt8;
    label_position: UInt8;
    label_separator: UInt8;
    default_label_position: UInt8;
    label_num_format: PUTF8Char;
    label_font: Plxw_chart_font;
    label_line: Plxw_chart_line;
    label_fill: Plxw_chart_fill;
    label_pattern: Plxw_chart_pattern;
    x_error_bars: Plxw_series_error_bars;
    y_error_bars: Plxw_series_error_bars;
    has_trendline: UInt8;
    has_trendline_forecast: UInt8;
    has_trendline_equation: UInt8;
    has_trendline_r_squared: UInt8;
    has_trendline_intercept: UInt8;
    trendline_type: UInt8;
    trendline_value: UInt8;
    trendline_forward: Double;
    trendline_backward: Double;
    trendline_value_type: UInt8;
    trendline_name: PUTF8Char;
    trendline_line: Plxw_chart_line;
    trendline_intercept: Double;
    list_pointers: _anonymous_type_10;
  end;

  lxw_chart_gridline = record
    visible: UInt8;
    line: Plxw_chart_line;
  end;

  (**
   * @brief Struct to represent an Excel chart axis.
   *
   * The lxw_chart_axis struct is used in functions that modify a chart axis
   * but the members of the struct aren't modified directly.
   *)
  lxw_chart_axis = record
    title: lxw_chart_title;
    num_format: PUTF8Char;
    default_num_format: PUTF8Char;
    source_linked: UInt8;
    major_tick_mark: UInt8;
    minor_tick_mark: UInt8;
    is_horizontal: UInt8;
    major_gridlines: lxw_chart_gridline;
    minor_gridlines: lxw_chart_gridline;
    num_font: Plxw_chart_font;
    line: Plxw_chart_line;
    fill: Plxw_chart_fill;
    pattern: Plxw_chart_pattern;
    is_category: UInt8;
    is_date: UInt8;
    is_value: UInt8;
    axis_position: UInt8;
    position_axis: UInt8;
    label_position: UInt8;
    label_align: UInt8;
    hidden: UInt8;
    reverse: UInt8;
    has_min: UInt8;
    min: Double;
    has_max: UInt8;
    max: Double;
    has_major_unit: UInt8;
    major_unit: Double;
    has_minor_unit: UInt8;
    minor_unit: Double;
    interval_unit: UInt16;
    interval_tick: UInt16;
    log_base: UInt16;
    display_units: UInt8;
    display_units_visible: UInt8;
    has_crossing: UInt8;
    crossing_min: UInt8;
    crossing_max: UInt8;
    crossing: Double;
  end;

  P_anonymous_type_11 = ^_anonymous_type_11;
  _anonymous_type_11 = record
    stqe_next: Plxw_chart;
  end;

  P_anonymous_type_12 = ^_anonymous_type_12;
  _anonymous_type_12 = record
    stqe_next: Plxw_chart;
  end;

  (**
   * @brief Struct to represent an Excel chart.
   *
   * The members of the lxw_chart struct aren't modified directly. Instead
   * the chart properties are set by calling the functions shown in chart.h.
   *)
  lxw_chart = record
    _file: PPointer;
    _type: UInt8;
    subtype: UInt8;
    series_index: UInt16;
    write_chart_type: procedure(p1: Plxw_chart); cdecl;
    write_plot_area: procedure(p1: Plxw_chart); cdecl;
    (**
     * A pointer to the chart x_axis object which can be used in functions
     * that configures the X axis.
     *)
    x_axis: Plxw_chart_axis;
    (**
     * A pointer to the chart y_axis object which can be used in functions
     * that configures the Y axis.
     *)
    y_axis: Plxw_chart_axis;
    title: lxw_chart_title;
    id: UInt32;
    axis_id_1: UInt32;
    axis_id_2: UInt32;
    axis_id_3: UInt32;
    axis_id_4: UInt32;
    in_use: UInt8;
    chart_group: UInt8;
    cat_has_num_fmt: UInt8;
    is_chartsheet: UInt8;
    has_horiz_cat_axis: UInt8;
    has_horiz_val_axis: UInt8;
    style_id: UInt8;
    rotation: UInt16;
    hole_size: UInt16;
    no_title: UInt8;
    has_overlap: UInt8;
    overlap_y1: Int8;
    overlap_y2: Int8;
    gap_y1: UInt16;
    gap_y2: UInt16;
    grouping: UInt8;
    default_cross_between: UInt8;
    legend: lxw_chart_legend;
    delete_series: PInt16;
    delete_series_count: UInt16;
    default_marker: Plxw_chart_marker;
    chartarea_line: Plxw_chart_line;
    chartarea_fill: Plxw_chart_fill;
    chartarea_pattern: Plxw_chart_pattern;
    plotarea_line: Plxw_chart_line;
    plotarea_fill: Plxw_chart_fill;
    plotarea_layout: Plxw_chart_layout;
    plotarea_pattern: Plxw_chart_pattern;
    has_drop_lines: UInt8;
    drop_lines_line: Plxw_chart_line;
    has_high_low_lines: UInt8;
    high_low_lines_line: Plxw_chart_line;
    series_list: Plxw_chart_series_list;
    has_table: UInt8;
    has_table_vertical: UInt8;
    has_table_horizontal: UInt8;
    has_table_outline: UInt8;
    has_table_legend_keys: UInt8;
    table_font: Plxw_chart_font;
    show_blanks_as: UInt8;
    show_hidden_data: UInt8;
    has_up_down_bars: UInt8;
    up_bar_line: Plxw_chart_line;
    down_bar_line: Plxw_chart_line;
    up_bar_fill: Plxw_chart_fill;
    down_bar_fill: Plxw_chart_fill;
    default_label_position: UInt8;
    is_protected: UInt8;
    ordered_list_pointers: _anonymous_type_11;
    list_pointers: _anonymous_type_12;
  end;

  lxw_drawing_objects = record
    stqh_first: Plxw_drawing_object;
    stqh_last: PPlxw_drawing_object;
  end;

  lxw_drawing_types = (
    LXW_DRAWING_NONE = 0,
    LXW_DRAWING_IMAGE = 1,
    LXW_DRAWING_CHART = 2,
    LXW_DRAWING_SHAPE = 3);
  Plxw_drawing_types = ^lxw_drawing_types;

  image_types = (
    LXW_IMAGE_UNKNOWN = 0,
    LXW_IMAGE_PNG = 1,
    LXW_IMAGE_JPEG = 2,
    LXW_IMAGE_BMP = 3,
    LXW_IMAGE_GIF = 4);
  Pimage_types = ^image_types;

  lxw_drawing_coords = record
    col: UInt32;
    row: UInt32;
    col_offset: Double;
    row_offset: Double;
  end;

  P_anonymous_type_13 = ^_anonymous_type_13;
  _anonymous_type_13 = record
    stqe_next: Plxw_drawing_object;
  end;

  lxw_drawing_object = record
    _type: UInt8;
    anchor: UInt8;
    from: lxw_drawing_coords;
    _to: lxw_drawing_coords;
    col_absolute: UInt64;
    row_absolute: UInt64;
    width: UInt32;
    height: UInt32;
    shape: UInt8;
    rel_index: UInt32;
    url_rel_index: UInt32;
    description: PUTF8Char;
    tip: PUTF8Char;
    decorative: UInt8;
    list_pointers: _anonymous_type_13;
  end;

  lxw_drawing = record
    _file: PPointer;
    embedded: UInt8;
    orientation: UInt8;
    drawing_objects: Plxw_drawing_objects;
  end;

  lxw_styles = record
    _file: PPointer;
    font_count: UInt32;
    xf_count: UInt32;
    dxf_count: UInt32;
    num_format_count: UInt32;
    border_count: UInt32;
    fill_count: UInt32;
    xf_formats: Plxw_formats;
    dxf_formats: Plxw_formats;
    has_hyperlink: UInt8;
    hyperlink_font_id: UInt16;
    has_comments: UInt8;
  end;

  P_anonymous_type_14 = ^_anonymous_type_14;
  _anonymous_type_14 = record
    stqe_next: Pxml_attribute;
  end;

  xml_attribute = record
    key: array [0..2079] of UTF8Char;
    value: array [0..2079] of UTF8Char;
    list_entries: _anonymous_type_14;
  end;

  xml_attribute_list = record
    stqh_first: Pxml_attribute;
    stqh_last: PPxml_attribute;
  end;

  lxw_rel_tuples = record
    stqh_first: Plxw_rel_tuple;
    stqh_last: PPlxw_rel_tuple;
  end;

  P_anonymous_type_15 = ^_anonymous_type_15;
  _anonymous_type_15 = record
    stqe_next: Plxw_rel_tuple;
  end;

  lxw_rel_tuple = record
    _type: PUTF8Char;
    target: PUTF8Char;
    target_mode: PUTF8Char;
    list_pointers: _anonymous_type_15;
  end;

  lxw_relationships = record
    _file: PPointer;
    rel_id: UInt32;
    relationships: Plxw_rel_tuples;
  end;

  (** Gridline options using in `worksheet_gridlines()`. *)
  lxw_gridlines = (
    (** Hide screen and print gridlines. *)
    LXW_HIDE_ALL_GRIDLINES = 0,
    (** Show screen gridlines. *)
    LXW_SHOW_SCREEN_GRIDLINES = 1,
    (** Show print gridlines. *)
    LXW_SHOW_PRINT_GRIDLINES = 2,
    (** Show screen and print gridlines. *)
    LXW_SHOW_ALL_GRIDLINES = 3);
  Plxw_gridlines = ^lxw_gridlines;

  (** Data validation property values. *)
  lxw_validation_boolean = (
    LXW_VALIDATION_DEFAULT = 0,
    (** Turn a data validation property off. *)
    LXW_VALIDATION_OFF = 1,
    (** Turn a data validation property on. Data validation properties are
     * generally on by default. *)
    LXW_VALIDATION_ON = 2);
  Plxw_validation_boolean = ^lxw_validation_boolean;

  (** Data validation types. *)
  lxw_validation_types = (
    LXW_VALIDATION_TYPE_NONE = 0,
    (** Restrict cell input to whole/integer numbers only. *)
    LXW_VALIDATION_TYPE_INTEGER = 1,
    (** Restrict cell input to whole/integer numbers only, using a cell
     *  reference. *)
    LXW_VALIDATION_TYPE_INTEGER_FORMULA = 2,
    (** Restrict cell input to decimal numbers only. *)
    LXW_VALIDATION_TYPE_DECIMAL = 3,
    (** Restrict cell input to decimal numbers only, using a cell
     * reference. *)
    LXW_VALIDATION_TYPE_DECIMAL_FORMULA = 4,
    (** Restrict cell input to a list of strings in a dropdown. *)
    LXW_VALIDATION_TYPE_LIST = 5,
    (** Restrict cell input to a list of strings in a dropdown, using a
     * cell range. *)
    LXW_VALIDATION_TYPE_LIST_FORMULA = 6,
    (** Restrict cell input to date values only, using a lxw_datetime type. *)
    LXW_VALIDATION_TYPE_DATE = 7,
    (** Restrict cell input to date values only, using a cell reference. *)
    LXW_VALIDATION_TYPE_DATE_FORMULA = 8,
    (** Restrict cell input to date values only, using a cell reference. *)
    LXW_VALIDATION_TYPE_DATE_NUMBER = 9,
    (** Restrict cell input to time values only, using a lxw_datetime type. *)
    LXW_VALIDATION_TYPE_TIME = 10,
    (** Restrict cell input to time values only, using a cell reference. *)
    LXW_VALIDATION_TYPE_TIME_FORMULA = 11,
    (** Restrict cell input to time values only, using a cell reference. *)
    LXW_VALIDATION_TYPE_TIME_NUMBER = 12,
    (** Restrict cell input to strings of defined length, using a cell
     * reference. *)
    LXW_VALIDATION_TYPE_LENGTH = 13,
    (** Restrict cell input to strings of defined length, using a cell
     * reference. *)
    LXW_VALIDATION_TYPE_LENGTH_FORMULA = 14,
    (** Restrict cell to input controlled by a custom formula that returns
     * `TRUE/FALSE`. *)
    LXW_VALIDATION_TYPE_CUSTOM_FORMULA = 15,
    (** Allow any type of input. Mainly only useful for pop-up messages. *)
    LXW_VALIDATION_TYPE_ANY = 16);
  Plxw_validation_types = ^lxw_validation_types;

  (** Data validation criteria uses to control the selection of data. *)
  lxw_validation_criteria = (
    LXW_VALIDATION_CRITERIA_NONE = 0,
    (** Select data between two values. *)
    LXW_VALIDATION_CRITERIA_BETWEEN = 1,
    (** Select data that is not between two values. *)
    LXW_VALIDATION_CRITERIA_NOT_BETWEEN = 2,
    (** Select data equal to a value. *)
    LXW_VALIDATION_CRITERIA_EQUAL_TO = 3,
    (** Select data not equal to a value. *)
    LXW_VALIDATION_CRITERIA_NOT_EQUAL_TO = 4,
    (** Select data greater than a value. *)
    LXW_VALIDATION_CRITERIA_GREATER_THAN = 5,
    (** Select data less than a value. *)
    LXW_VALIDATION_CRITERIA_LESS_THAN = 6,
    (** Select data greater than or equal to a value. *)
    LXW_VALIDATION_CRITERIA_GREATER_THAN_OR_EQUAL_TO = 7,
    (** Select data less than or equal to a value. *)
    LXW_VALIDATION_CRITERIA_LESS_THAN_OR_EQUAL_TO = 8);
  Plxw_validation_criteria = ^lxw_validation_criteria;

  (** Data validation error types for pop-up messages. *)
  lxw_validation_error_types = (
    (** Show a "Stop" data validation pop-up message. This is the default. *)
    LXW_VALIDATION_ERROR_TYPE_STOP = 0,
    (** Show an "Error" data validation pop-up message. *)
    LXW_VALIDATION_ERROR_TYPE_WARNING = 1,
    (** Show an "Information" data validation pop-up message. *)
    LXW_VALIDATION_ERROR_TYPE_INFORMATION = 2);
  Plxw_validation_error_types = ^lxw_validation_error_types;

  (** Set the display type for a cell comment. This is hidden by default but
   *  can be set to visible with the `worksheet_show_comments()` function. *)
  lxw_comment_display_types = (
    (** Default to the worksheet default which can be hidden or visible.*)
    LXW_COMMENT_DISPLAY_DEFAULT = 0,
    (** Hide the cell comment. Usually the default. *)
    LXW_COMMENT_DISPLAY_HIDDEN = 1,
    (** Show the cell comment. Can also be set for the worksheet with the
     *  `worksheet_show_comments()` function.*)
    LXW_COMMENT_DISPLAY_VISIBLE = 2);
  Plxw_comment_display_types = ^lxw_comment_display_types;

  (** @brief Type definitions for conditional formats.
   *
   * Values used to set the "type" field of conditional format.
   *)
  lxw_conditional_format_types = (
    LXW_CONDITIONAL_TYPE_NONE = 0,
    (** The Cell type is the most common conditional formatting type. It is
     *  used when a format is applied to a cell based on a simple
     *  criterion.  *)
    LXW_CONDITIONAL_TYPE_CELL = 1,
    (** The Text type is used to specify Excel's "Specific Text" style
     *  conditional format. *)
    LXW_CONDITIONAL_TYPE_TEXT = 2,
    (** The Time Period type is used to specify Excel's "Dates Occurring"
     *  style conditional format. *)
    LXW_CONDITIONAL_TYPE_TIME_PERIOD = 3,
    (** The Average type is used to specify Excel's "Average" style
     *  conditional format. *)
    LXW_CONDITIONAL_TYPE_AVERAGE = 4,
    (** The Duplicate type is used to highlight duplicate cells in a range. *)
    LXW_CONDITIONAL_TYPE_DUPLICATE = 5,
    (** The Unique type is used to highlight unique cells in a range. *)
    LXW_CONDITIONAL_TYPE_UNIQUE = 6,
    (** The Top type is used to specify the top n values by number or
     *  percentage in a range. *)
    LXW_CONDITIONAL_TYPE_TOP = 7,
    (** The Bottom type is used to specify the bottom n values by number or
     *  percentage in a range. *)
    LXW_CONDITIONAL_TYPE_BOTTOM = 8,
    (** The Blanks type is used to highlight blank cells in a range. *)
    LXW_CONDITIONAL_TYPE_BLANKS = 9,
    (** The No Blanks type is used to highlight non blank cells in a range. *)
    LXW_CONDITIONAL_TYPE_NO_BLANKS = 10,
    (** The Errors type is used to highlight error cells in a range. *)
    LXW_CONDITIONAL_TYPE_ERRORS = 11,
    (** The No Errors type is used to highlight non error cells in a range. *)
    LXW_CONDITIONAL_TYPE_NO_ERRORS = 12,
    (** The Formula type is used to specify a conditional format based on a
     *  user defined formula. *)
    LXW_CONDITIONAL_TYPE_FORMULA = 13,
    (** The 2 Color Scale type is used to specify Excel's "2 Color Scale"
     *  style conditional format. *)
    LXW_CONDITIONAL_2_COLOR_SCALE = 14,
    (** The 3 Color Scale type is used to specify Excel's "3 Color Scale"
     *  style conditional format. *)
    LXW_CONDITIONAL_3_COLOR_SCALE = 15,
    (** The Data Bar type is used to specify Excel's "Data Bar" style
     *  conditional format. *)
    LXW_CONDITIONAL_DATA_BAR = 16,
    (** The Icon Set type is used to specify a conditional format with a set
     *  of icons such as traffic lights or arrows. *)
    LXW_CONDITIONAL_TYPE_ICON_SETS = 17,
    (** The Icon Set type is used to specify a conditional format with a set
     *  of icons such as traffic lights or arrows. *)
    LXW_CONDITIONAL_TYPE_LAST = 18);
  Plxw_conditional_format_types = ^lxw_conditional_format_types;

  (** @brief The criteria used in a conditional format.
   *
   * Criteria used to define how a conditional format works.
   *)
  lxw_conditional_criteria = (
    LXW_CONDITIONAL_CRITERIA_NONE = 0,
    (** Format cells equal to a value. *)
    LXW_CONDITIONAL_CRITERIA_EQUAL_TO = 1,
    (** Format cells not equal to a value. *)
    LXW_CONDITIONAL_CRITERIA_NOT_EQUAL_TO = 2,
    (** Format cells greater than a value. *)
    LXW_CONDITIONAL_CRITERIA_GREATER_THAN = 3,
    (** Format cells less than a value. *)
    LXW_CONDITIONAL_CRITERIA_LESS_THAN = 4,
    (** Format cells greater than or equal to a value. *)
    LXW_CONDITIONAL_CRITERIA_GREATER_THAN_OR_EQUAL_TO = 5,
    (** Format cells less than or equal to a value. *)
    LXW_CONDITIONAL_CRITERIA_LESS_THAN_OR_EQUAL_TO = 6,
    (** Format cells between two values. *)
    LXW_CONDITIONAL_CRITERIA_BETWEEN = 7,
    (** Format cells that is not between two values. *)
    LXW_CONDITIONAL_CRITERIA_NOT_BETWEEN = 8,
    (** Format cells that contain the specified text. *)
    LXW_CONDITIONAL_CRITERIA_TEXT_CONTAINING = 9,
    (** Format cells that don't contain the specified text. *)
    LXW_CONDITIONAL_CRITERIA_TEXT_NOT_CONTAINING = 10,
    (** Format cells that begin with the specified text. *)
    LXW_CONDITIONAL_CRITERIA_TEXT_BEGINS_WITH = 11,
    (** Format cells that end with the specified text. *)
    LXW_CONDITIONAL_CRITERIA_TEXT_ENDS_WITH = 12,
    (** Format cells with a date of yesterday. *)
    LXW_CONDITIONAL_CRITERIA_TIME_PERIOD_YESTERDAY = 13,
    (** Format cells with a date of today. *)
    LXW_CONDITIONAL_CRITERIA_TIME_PERIOD_TODAY = 14,
    (** Format cells with a date of tomorrow. *)
    LXW_CONDITIONAL_CRITERIA_TIME_PERIOD_TOMORROW = 15,
    (** Format cells with a date in the last 7 days. *)
    LXW_CONDITIONAL_CRITERIA_TIME_PERIOD_LAST_7_DAYS = 16,
    (** Format cells with a date in the last week. *)
    LXW_CONDITIONAL_CRITERIA_TIME_PERIOD_LAST_WEEK = 17,
    (** Format cells with a date in the current week. *)
    LXW_CONDITIONAL_CRITERIA_TIME_PERIOD_THIS_WEEK = 18,
    (** Format cells with a date in the next week. *)
    LXW_CONDITIONAL_CRITERIA_TIME_PERIOD_NEXT_WEEK = 19,
    (** Format cells with a date in the last month. *)
    LXW_CONDITIONAL_CRITERIA_TIME_PERIOD_LAST_MONTH = 20,
    (** Format cells with a date in the current month. *)
    LXW_CONDITIONAL_CRITERIA_TIME_PERIOD_THIS_MONTH = 21,
    (** Format cells with a date in the next month. *)
    LXW_CONDITIONAL_CRITERIA_TIME_PERIOD_NEXT_MONTH = 22,
    (** Format cells above the average for the range. *)
    LXW_CONDITIONAL_CRITERIA_AVERAGE_ABOVE = 23,
    (** Format cells below the average for the range. *)
    LXW_CONDITIONAL_CRITERIA_AVERAGE_BELOW = 24,
    (** Format cells above or equal to the average for the range. *)
    LXW_CONDITIONAL_CRITERIA_AVERAGE_ABOVE_OR_EQUAL = 25,
    (** Format cells below or equal to the average for the range. *)
    LXW_CONDITIONAL_CRITERIA_AVERAGE_BELOW_OR_EQUAL = 26,
    (** Format cells 1 standard deviation above the average for the range. *)
    LXW_CONDITIONAL_CRITERIA_AVERAGE_1_STD_DEV_ABOVE = 27,
    (** Format cells 1 standard deviation below the average for the range. *)
    LXW_CONDITIONAL_CRITERIA_AVERAGE_1_STD_DEV_BELOW = 28,
    (** Format cells 2 standard deviation above the average for the range. *)
    LXW_CONDITIONAL_CRITERIA_AVERAGE_2_STD_DEV_ABOVE = 29,
    (** Format cells 2 standard deviation below the average for the range. *)
    LXW_CONDITIONAL_CRITERIA_AVERAGE_2_STD_DEV_BELOW = 30,
    (** Format cells 3 standard deviation above the average for the range. *)
    LXW_CONDITIONAL_CRITERIA_AVERAGE_3_STD_DEV_ABOVE = 31,
    (** Format cells 3 standard deviation below the average for the range. *)
    LXW_CONDITIONAL_CRITERIA_AVERAGE_3_STD_DEV_BELOW = 32,
    (** Format cells in the top of bottom percentage. *)
    LXW_CONDITIONAL_CRITERIA_TOP_OR_BOTTOM_PERCENT = 33);
  Plxw_conditional_criteria = ^lxw_conditional_criteria;

  (** @brief Conditional format rule types.
   *
   * Conditional format rule types that apply to Color Scale and Data Bars.
   *)
  lxw_conditional_format_rule_types = (
    LXW_CONDITIONAL_RULE_TYPE_NONE = 0,
    (** Conditional format rule type: matches the minimum values in the
     *  range. Can only be applied to min_rule_type.*)
    LXW_CONDITIONAL_RULE_TYPE_MINIMUM = 1,
    (** Conditional format rule type: use a number to set the bound.*)
    LXW_CONDITIONAL_RULE_TYPE_NUMBER = 2,
    (** Conditional format rule type: use a percentage to set the bound.*)
    LXW_CONDITIONAL_RULE_TYPE_PERCENT = 3,
    (** Conditional format rule type: use a percentile to set the bound.*)
    LXW_CONDITIONAL_RULE_TYPE_PERCENTILE = 4,
    (** Conditional format rule type: use a formula to set the bound.*)
    LXW_CONDITIONAL_RULE_TYPE_FORMULA = 5,
    (** Conditional format rule type: matches the maximum values in the
     *  range. Can only be applied to max_rule_type.*)
    LXW_CONDITIONAL_RULE_TYPE_MAXIMUM = 6,
    (** Conditional format rule type: matches the maximum values in the
     *  range. Can only be applied to max_rule_type.*)
    LXW_CONDITIONAL_RULE_TYPE_AUTO_MIN = 7,
    (** Conditional format rule type: matches the maximum values in the
     *  range. Can only be applied to max_rule_type.*)
    LXW_CONDITIONAL_RULE_TYPE_AUTO_MAX = 8);
  Plxw_conditional_format_rule_types = ^lxw_conditional_format_rule_types;

  (** @brief Conditional format data bar directions.
   *
   * Values used to set the bar direction of a conditional format data bar.
   *)
  lxw_conditional_format_bar_direction = (
    (** Data bar direction is set by Excel based on the context of the data
     *  displayed. *)
    LXW_CONDITIONAL_BAR_DIRECTION_CONTEXT = 0,
    (** Data bar direction is from right to left. *)
    LXW_CONDITIONAL_BAR_DIRECTION_RIGHT_TO_LEFT = 1,
    (** Data bar direction is from left to right. *)
    LXW_CONDITIONAL_BAR_DIRECTION_LEFT_TO_RIGHT = 2);
  Plxw_conditional_format_bar_direction = ^lxw_conditional_format_bar_direction;

  (** @brief Conditional format data bar axis options.
   *
   * Values used to set the position of the axis in a conditional format data
   * bar.
   *)
  lxw_conditional_bar_axis_position = (
    (** Data bar axis position is set by Excel based on the context of the
     *  data displayed. *)
    LXW_CONDITIONAL_BAR_AXIS_AUTOMATIC = 0,
    (** Data bar axis position is set at the midpoint. *)
    LXW_CONDITIONAL_BAR_AXIS_MIDPOINT = 1,
    (** Data bar axis is turned off. *)
    LXW_CONDITIONAL_BAR_AXIS_NONE = 2);
  Plxw_conditional_bar_axis_position = ^lxw_conditional_bar_axis_position;

  (** @brief Icon types used in the #lxw_conditional_format icon_style field.
   *
   * Definitions of icon styles used with Icon Set conditional formats.
   *)
  lxw_conditional_icon_types = (
    (** Icon style: 3 colored arrows showing up, sideways and down. *)
    LXW_CONDITIONAL_ICONS_3_ARROWS_COLORED = 0,
    (** Icon style: 3 gray arrows showing up, sideways and down. *)
    LXW_CONDITIONAL_ICONS_3_ARROWS_GRAY = 1,
    (** Icon style: 3 colored flags in red, yellow and green. *)
    LXW_CONDITIONAL_ICONS_3_FLAGS = 2,
    (** Icon style: 3 traffic lights - rounded. *)
    LXW_CONDITIONAL_ICONS_3_TRAFFIC_LIGHTS_UNRIMMED = 3,
    (** Icon style: 3 traffic lights with a rim - squarish. *)
    LXW_CONDITIONAL_ICONS_3_TRAFFIC_LIGHTS_RIMMED = 4,
    (** Icon style: 3 colored shapes - a circle, triangle and diamond. *)
    LXW_CONDITIONAL_ICONS_3_SIGNS = 5,
    (** Icon style: 3 circled symbols with tick mark, exclamation and
     *  cross. *)
    LXW_CONDITIONAL_ICONS_3_SYMBOLS_CIRCLED = 6,
    (** Icon style: 3 symbols with tick mark, exclamation and cross. *)
    LXW_CONDITIONAL_ICONS_3_SYMBOLS_UNCIRCLED = 7,
    (** Icon style: 4 colored arrows showing up, diagonal up, diagonal down
     *  and down. *)
    LXW_CONDITIONAL_ICONS_4_ARROWS_COLORED = 8,
    (** Icon style: 4 gray arrows showing up, diagonal up, diagonal down and
     * down. *)
    LXW_CONDITIONAL_ICONS_4_ARROWS_GRAY = 9,
    (** Icon style: 4 circles in 4 colors going from red to black. *)
    LXW_CONDITIONAL_ICONS_4_RED_TO_BLACK = 10,
    (** Icon style: 4 histogram ratings. *)
    LXW_CONDITIONAL_ICONS_4_RATINGS = 11,
    (** Icon style: 4 traffic lights. *)
    LXW_CONDITIONAL_ICONS_4_TRAFFIC_LIGHTS = 12,
    (** Icon style: 5 colored arrows showing up, diagonal up, sideways,
     * diagonal down and down. *)
    LXW_CONDITIONAL_ICONS_5_ARROWS_COLORED = 13,
    (** Icon style: 5 gray arrows showing up, diagonal up, sideways, diagonal
     *  down and down. *)
    LXW_CONDITIONAL_ICONS_5_ARROWS_GRAY = 14,
    (** Icon style: 5 histogram ratings. *)
    LXW_CONDITIONAL_ICONS_5_RATINGS = 15,
    (** Icon style: 5 quarters, from 0 to 4 quadrants filled. *)
    LXW_CONDITIONAL_ICONS_5_QUARTERS = 16);
  Plxw_conditional_icon_types = ^lxw_conditional_icon_types;

  (** @brief The type of table style.
   *
   * The type of table style (Light, Medium or Dark).
   *)
  lxw_table_style_type = (
    LXW_TABLE_STYLE_TYPE_DEFAULT = 0,
    (** Light table style. *)
    LXW_TABLE_STYLE_TYPE_LIGHT = 1,
    (** Light table style. *)
    LXW_TABLE_STYLE_TYPE_MEDIUM = 2,
    (** Light table style. *)
    LXW_TABLE_STYLE_TYPE_DARK = 3);
  Plxw_table_style_type = ^lxw_table_style_type;

  (**
   * @brief Standard Excel functions for totals in tables.
   *
   * Definitions for the standard Excel functions that are available via the
   * dropdown in the total row of an Excel table.
   *
   *)
  lxw_table_total_functions = (
    LXW_TABLE_FUNCTION_NONE = 0,
    (** Use the average function as the table total. *)
    LXW_TABLE_FUNCTION_AVERAGE = 101,
    (** Use the count numbers function as the table total. *)
    LXW_TABLE_FUNCTION_COUNT_NUMS = 102,
    (** Use the count function as the table total. *)
    LXW_TABLE_FUNCTION_COUNT = 103,
    (** Use the max function as the table total. *)
    LXW_TABLE_FUNCTION_MAX = 104,
    (** Use the min function as the table total. *)
    LXW_TABLE_FUNCTION_MIN = 105,
    (** Use the standard deviation function as the table total. *)
    LXW_TABLE_FUNCTION_STD_DEV = 107,
    (** Use the sum function as the table total. *)
    LXW_TABLE_FUNCTION_SUM = 109,
    (** Use the var function as the table total. *)
    LXW_TABLE_FUNCTION_VAR = 110);
  Plxw_table_total_functions = ^lxw_table_total_functions;

  (** @brief The criteria used in autofilter rules.
   *
   * Criteria used to define an autofilter rule condition.
   *)
  lxw_filter_criteria = (
    LXW_FILTER_CRITERIA_NONE = 0,
    (** Filter cells equal to a value. *)
    LXW_FILTER_CRITERIA_EQUAL_TO = 1,
    (** Filter cells not equal to a value. *)
    LXW_FILTER_CRITERIA_NOT_EQUAL_TO = 2,
    (** Filter cells greater than a value. *)
    LXW_FILTER_CRITERIA_GREATER_THAN = 3,
    (** Filter cells less than a value. *)
    LXW_FILTER_CRITERIA_LESS_THAN = 4,
    (** Filter cells greater than or equal to a value. *)
    LXW_FILTER_CRITERIA_GREATER_THAN_OR_EQUAL_TO = 5,
    (** Filter cells less than or equal to a value. *)
    LXW_FILTER_CRITERIA_LESS_THAN_OR_EQUAL_TO = 6,
    (** Filter cells that are blank. *)
    LXW_FILTER_CRITERIA_BLANKS = 7,
    (** Filter cells that are not blank. *)
    LXW_FILTER_CRITERIA_NON_BLANKS = 8);
  Plxw_filter_criteria = ^lxw_filter_criteria;

  (**
   * @brief And/or operator when using 2 filter rules.
   *
   * And/or operator conditions when using 2 filter rules with
   * worksheet_filter_column2(). In general LXW_FILTER_OR is used with
   * LXW_FILTER_CRITERIA_EQUAL_TO and LXW_FILTER_AND is used with the other
   * filter criteria.
   *)
  lxw_filter_operator = (
    (** Logical "and" of 2 filter rules. *)
    LXW_FILTER_AND = 0,
    (** Logical "or" of 2 filter rules. *)
    LXW_FILTER_OR = 1);
  Plxw_filter_operator = ^lxw_filter_operator;

  lxw_filter_type = (
    LXW_FILTER_TYPE_NONE = 0,
    LXW_FILTER_TYPE_SINGLE = 1,
    LXW_FILTER_TYPE_AND = 2,
    LXW_FILTER_TYPE_OR = 3,
    LXW_FILTER_TYPE_STRING_LIST = 4);
  Plxw_filter_type = ^lxw_filter_type;

  (** Options to control the positioning of worksheet objects such as images
   *  or charts. See @ref working_with_object_positioning. *)
  lxw_object_position = (
    (** Default positioning for the object. *)
    LXW_OBJECT_POSITION_DEFAULT = 0,
    (** Move and size the worksheet object with the cells. *)
    LXW_OBJECT_MOVE_AND_SIZE = 1,
    (** Move but don't size the worksheet object with the cells. *)
    LXW_OBJECT_MOVE_DONT_SIZE = 2,
    (** Don't move or size the worksheet object with the cells. *)
    LXW_OBJECT_DONT_MOVE_DONT_SIZE = 3,
    (** Same as #LXW_OBJECT_MOVE_AND_SIZE except libxlsxwriter applies hidden
     *  cells after the object is inserted. *)
    LXW_OBJECT_MOVE_AND_SIZE_AFTER = 4);
  Plxw_object_position = ^lxw_object_position;

  (** Options for ignoring worksheet errors/warnings. See worksheet_ignore_errors(). *)
  lxw_ignore_errors = (
    (** Turn off errors/warnings for numbers stores as text. *)
    LXW_IGNORE_NUMBER_STORED_AS_TEXT = 1,
    (** Turn off errors/warnings for formula errors (such as divide by
     *  zero). *)
    LXW_IGNORE_EVAL_ERROR = 2,
    (** Turn off errors/warnings for formulas that differ from surrounding
     *  formulas. *)
    LXW_IGNORE_FORMULA_DIFFERS = 3,
    (** Turn off errors/warnings for formulas that omit cells in a range. *)
    LXW_IGNORE_FORMULA_RANGE = 4,
    (** Turn off errors/warnings for unlocked cells that contain formulas. *)
    LXW_IGNORE_FORMULA_UNLOCKED = 5,
    (** Turn off errors/warnings for formulas that refer to empty cells. *)
    LXW_IGNORE_EMPTY_CELL_REFERENCE = 6,
    (** Turn off errors/warnings for cells in a table that do not comply with
     *  applicable data validation rules. *)
    LXW_IGNORE_LIST_DATA_VALIDATION = 7,
    (** Turn off errors/warnings for cell formulas that differ from the column
     *  formula. *)
    LXW_IGNORE_CALCULATED_COLUMN = 8,
    (** Turn off errors/warnings for formulas that contain a two digit text
     *  representation of a year. *)
    LXW_IGNORE_TWO_DIGIT_TEXT_YEAR = 9,
    (** Turn off errors/warnings for formulas that contain a two digit text
     *  representation of a year. *)
    LXW_IGNORE_LAST_OPTION = 10);
  Plxw_ignore_errors = ^lxw_ignore_errors;

  cell_types = (
    NUMBER_CELL = 1,
    STRING_CELL = 2,
    INLINE_STRING_CELL = 3,
    INLINE_RICH_STRING_CELL = 4,
    FORMULA_CELL = 5,
    ARRAY_FORMULA_CELL = 6,
    DYNAMIC_ARRAY_FORMULA_CELL = 7,
    BLANK_CELL = 8,
    BOOLEAN_CELL = 9,
    ERROR_CELL = 10,
    COMMENT = 11,
    HYPERLINK_URL = 12,
    HYPERLINK_INTERNAL = 13,
    HYPERLINK_EXTERNAL = 14);
  Pcell_types = ^cell_types;

  pane_types = (
    NO_PANES = 0,
    FREEZE_PANES = 1,
    SPLIT_PANES = 2,
    FREEZE_SPLIT_PANES = 3);
  Ppane_types = ^pane_types;

  lxw_image_position = (
    HEADER_LEFT = 0,
    HEADER_CENTER = 1,
    HEADER_RIGHT = 2,
    FOOTER_LEFT = 3,
    FOOTER_CENTER = 4,
    FOOTER_RIGHT = 5);
  Plxw_image_position = ^lxw_image_position;

  lxw_table_cells = record
    rbh_root: Plxw_cell;
  end;

  lxw_drawing_rel_ids = record
    rbh_root: Plxw_drawing_rel_id;
  end;

  lxw_vml_drawing_rel_ids = record
    rbh_root: Plxw_drawing_rel_id;
  end;

  lxw_cond_format_hash = record
    rbh_root: Plxw_cond_format_hash_element;
  end;

  lxw_table_rows = record
    rbh_root: Plxw_row;
    cached_row: Plxw_row;
    cached_row_num: lxw_row_t;
  end;

  lxw_merged_ranges = record
    stqh_first: Plxw_merged_range;
    stqh_last: PPlxw_merged_range;
  end;

  lxw_selections = record
    stqh_first: Plxw_selection;
    stqh_last: PPlxw_selection;
  end;

  lxw_data_validations = record
    stqh_first: Plxw_data_val_obj;
    stqh_last: PPlxw_data_val_obj;
  end;

  lxw_cond_format_list = record
    stqh_first: Plxw_cond_format_obj;
    stqh_last: PPlxw_cond_format_obj;
  end;

  lxw_image_props = record
    stqh_first: Plxw_object_properties;
    stqh_last: PPlxw_object_properties;
  end;

  lxw_embedded_image_props = record
    stqh_first: Plxw_object_properties;
    stqh_last: PPlxw_object_properties;
  end;

  lxw_chart_props = record
    stqh_first: Plxw_object_properties;
    stqh_last: PPlxw_object_properties;
  end;

  lxw_comment_objs = record
    stqh_first: Plxw_vml_obj;
    stqh_last: PPlxw_vml_obj;
  end;

  lxw_table_objs = record
    stqh_first: Plxw_table_obj;
    stqh_last: PPlxw_table_obj;
  end;

  (**
   * @brief Options for rows and columns.
   *
   * Options struct for the worksheet_set_column() and worksheet_set_row()
   * functions.
   *
   * It has the following members:
   *
   * * `hidden`
   * * `level`
   * * `collapsed`
   *
   * The members of this struct are explained in @ref ww_outlines_grouping.
   *
   *)
  lxw_row_col_options = packed record
    (** Hide the row/column. @ref ww_outlines_grouping.*)
    hidden: UInt8;
    (** Outline level. See @ref ww_outlines_grouping.*)
    level: UInt8;
    (** Set the outline row as collapsed. See @ref ww_outlines_grouping.*)
    collapsed: UInt8;
  end;

  lxw_col_options = record
    firstcol: lxw_col_t;
    lastcol: lxw_col_t;
    width: Double;
    format: Plxw_format;
    hidden: UInt8;
    level: UInt8;
    collapsed: UInt8;
  end;

  P_anonymous_type_16 = ^_anonymous_type_16;
  _anonymous_type_16 = record
    stqe_next: Plxw_merged_range;
  end;

  lxw_merged_range = record
    first_row: lxw_row_t;
    last_row: lxw_row_t;
    first_col: lxw_col_t;
    last_col: lxw_col_t;
    list_pointers: _anonymous_type_16;
  end;

  lxw_repeat_rows = record
    in_use: UInt8;
    first_row: lxw_row_t;
    last_row: lxw_row_t;
  end;

  lxw_repeat_cols = record
    in_use: UInt8;
    first_col: lxw_col_t;
    last_col: lxw_col_t;
  end;

  lxw_print_area = record
    in_use: UInt8;
    first_row: lxw_row_t;
    last_row: lxw_row_t;
    first_col: lxw_col_t;
    last_col: lxw_col_t;
  end;

  lxw_autofilter = record
    in_use: UInt8;
    has_rules: UInt8;
    first_row: lxw_row_t;
    last_row: lxw_row_t;
    first_col: lxw_col_t;
    last_col: lxw_col_t;
  end;

  lxw_panes = record
    _type: UInt8;
    first_row: lxw_row_t;
    first_col: lxw_col_t;
    top_row: lxw_row_t;
    left_col: lxw_col_t;
    x_split: Double;
    y_split: Double;
  end;

  P_anonymous_type_17 = ^_anonymous_type_17;
  _anonymous_type_17 = record
    stqe_next: Plxw_selection;
  end;

  lxw_selection = record
    pane: array [0..11] of UTF8Char;
    active_cell: array [0..27] of UTF8Char;
    sqref: array [0..27] of UTF8Char;
    list_pointers: _anonymous_type_17;
  end;

  (**
   * @brief Worksheet data validation options.
   *)
  lxw_data_validation = record
    (**
     * Set the validation type. Should be a #lxw_validation_types value.
     *)
    validate: UInt8;
    (**
     * Set the validation criteria type to select the data. Should be a
     * #lxw_validation_criteria value.
     *)
    criteria: UInt8;
    (** Controls whether a data validation is not applied to blank data in the
     * cell. Should be a #lxw_validation_boolean value. It is on by
     * default.
     *)
    ignore_blank: UInt8;
    (**
     * This parameter is used to toggle on and off the 'Show input message
     * when cell is selected' option in the Excel data validation dialog. When
     * the option is off an input message is not displayed even if it has been
     * set using input_message. Should be a #lxw_validation_boolean value. It
     * is on by default.
     *)
    show_input: UInt8;
    (**
     * This parameter is used to toggle on and off the 'Show error alert
     * after invalid data is entered' option in the Excel data validation
     * dialog. When the option is off an error message is not displayed even
     * if it has been set using error_message. Should be a
     * #lxw_validation_boolean value. It is on by default.
     *)
    show_error: UInt8;
    (**
     * This parameter is used to specify the type of error dialog that is
     * displayed. Should be a #lxw_validation_error_types value.
     *)
    error_type: UInt8;
    (**
     * This parameter is used to toggle on and off the 'In-cell dropdown'
     * option in the Excel data validation dialog. When the option is on a
     * dropdown list will be shown for list validations. Should be a
     * #lxw_validation_boolean value. It is on by default.
     *)
    dropdown: UInt8;
    (**
     * This parameter is used to set the limiting value to which the criteria
     * is applied using a whole or decimal number.
     *)
    value_number: Double;
    (**
     * This parameter is used to set the limiting value to which the criteria
     * is applied using a cell reference. It is valid for any of the
     * `_FORMULA` validation types.
     *)
    value_formula: PUTF8Char;
    (**
     * This parameter is used to set a list of strings for a dropdown list.
     * The list should be a `NULL` terminated array of char* strings:
     *
     * @code
     *    char *list[] = {"open", "high", "close", NULL};
     *
     *    data_validation->validate   = LXW_VALIDATION_TYPE_LIST;
     *    data_validation->value_list = list;
     * @endcode
     *
     * The `value_formula` parameter can also be used to specify a list from
     * an Excel cell range.
     *
     * Note, the string list is restricted by Excel to 255 characters,
     * including comma separators.
     *)
    value_list: PPUTF8Char;
    (**
     * This parameter is used to set the limiting value to which the date or
     * time criteria is applied using a #lxw_datetime struct.
     *)
    value_datetime: lxw_datetime;
    (**
     * This parameter is the same as `value_number` but for the minimum value
     * when a `BETWEEN` criteria is used.
     *)
    minimum_number: Double;
    (**
     * This parameter is the same as `value_formula` but for the minimum value
     * when a `BETWEEN` criteria is used.
     *)
    minimum_formula: PUTF8Char;
    (**
     * This parameter is the same as `value_datetime` but for the minimum value
     * when a `BETWEEN` criteria is used.
     *)
    minimum_datetime: lxw_datetime;
    (**
     * This parameter is the same as `value_number` but for the maximum value
     * when a `BETWEEN` criteria is used.
     *)
    maximum_number: Double;
    (**
     * This parameter is the same as `value_formula` but for the maximum value
     * when a `BETWEEN` criteria is used.
     *)
    maximum_formula: PUTF8Char;
    (**
     * This parameter is the same as `value_datetime` but for the maximum value
     * when a `BETWEEN` criteria is used.
     *)
    maximum_datetime: lxw_datetime;
    (**
     * The input_title parameter is used to set the title of the input message
     * that is displayed when a cell is entered. It has no default value and
     * is only displayed if the input message is displayed. See the
     * `input_message` parameter below.
     *
     * The maximum title length is 32 characters.
     *)
    input_title: PUTF8Char;
    (**
     * The input_message parameter is used to set the input message that is
     * displayed when a cell is entered. It has no default value.
     *
     * The message can be split over several lines using newlines. The maximum
     * message length is 255 characters.
     *)
    input_message: PUTF8Char;
    (**
     * The error_title parameter is used to set the title of the error message
     * that is displayed when the data validation criteria is not met. The
     * default error title is 'Microsoft Excel'. The maximum title length is
     * 32 characters.
     *)
    error_title: PUTF8Char;
    (**
     * The error_message parameter is used to set the error message that is
     * displayed when a cell is entered. The default error message is "The
     * value you entered is not valid. A user has restricted values that can
     * be entered into the cell".
     *
     * The message can be split over several lines using newlines. The maximum
     * message length is 255 characters.
     *)
    error_message: PUTF8Char;
  end;

  P_anonymous_type_18 = ^_anonymous_type_18;
  _anonymous_type_18 = record
    stqe_next: Plxw_data_val_obj;
  end;

  lxw_data_val_obj = record
    validate: UInt8;
    criteria: UInt8;
    ignore_blank: UInt8;
    show_input: UInt8;
    show_error: UInt8;
    error_type: UInt8;
    dropdown: UInt8;
    value_number: Double;
    value_formula: PUTF8Char;
    value_list: PPUTF8Char;
    minimum_number: Double;
    minimum_formula: PUTF8Char;
    minimum_datetime: lxw_datetime;
    maximum_number: Double;
    maximum_formula: PUTF8Char;
    maximum_datetime: lxw_datetime;
    input_title: PUTF8Char;
    input_message: PUTF8Char;
    error_title: PUTF8Char;
    error_message: PUTF8Char;
    sqref: array [0..27] of UTF8Char;
    list_pointers: _anonymous_type_18;
  end;

  (**
   * @brief Worksheet conditional formatting options.
   *
   * The fields/options in the the lxw_conditional_format are used to define a
   * worksheet conditional format. It is used in conjunction with
   * `worksheet_conditional_format()`.
   *
   *)
  lxw_conditional_format = record
    (** The type of conditional format such as #LXW_CONDITIONAL_TYPE_CELL or
     *  #LXW_CONDITIONAL_DATA_BAR. Should be a #lxw_conditional_format_types
     *  value.*)
    _type: UInt8;
    (** The criteria parameter is used to set the criteria by which the cell
     *  data will be evaluated. For example in the expression `a > 5 the
     *  criteria is `>` or, in libxlsxwriter terms,
     *  #LXW_CONDITIONAL_CRITERIA_GREATER_THAN. The criteria that are
     *  applicable depend on the conditional format type.  The criteria
     *  options are defined in #lxw_conditional_criteria. *)
    criteria: UInt8;
    (** The number value to which the condition refers. For example in the
     * expression `a > 5`, the value is 5.*)
    value: Double;
    (** The string value to which the condition refers, such as `"=A1"`. If a
     *  value_string exists in the struct then the number value is
     *  ignored. Note, if the condition refers to a text string then it must
     *  be double quoted like this `"foo"`. *)
    value_string: PUTF8Char;
    (** The format field is used to specify the #lxw_format format that will
     *  be applied to the cell when the conditional formatting criterion is
     *  met. The #lxw_format is created using the `workbook_add_format()`
     *  method in the same way as cell formats.
     *
     *  @note In Excel, a conditional format is superimposed over the existing
     *  cell format and not all cell format properties can be
     *  modified. Properties that @b cannot be modified, in Excel, by a
     *  conditional format are: font name, font size, superscript and
     *  subscript, diagonal borders, all alignment properties and all
     *  protection properties. *)
    format: Plxw_format;
    (** The minimum value used for Cell, Color Scale and Data Bar conditional
     *  formats. For Cell types this is usually used with a "Between" style criteria. *)
    min_value: Double;
    (** The minimum string value used for Cell, Color Scale and Data Bar conditional
     *  formats. Usually used to set ranges like `=A1`. *)
    min_value_string: PUTF8Char;
    (** The rule used for the minimum condition in Color Scale and Data Bar
     *  conditional formats. The rule types are defined in
     *  #lxw_conditional_format_rule_types. *)
    min_rule_type: UInt8;
    (** The color used for the minimum Color Scale conditional format.
     *  See @ref working_with_colors. *)
    min_color: lxw_color_t;
    (** The middle value used for Color Scale and Data Bar conditional
     *  formats.  *)
    mid_value: Double;
    (** The middle string value used for Color Scale and Data Bar conditional
     *  formats. Usually used to set ranges like `=A1`. *)
    mid_value_string: PUTF8Char;
    (** The rule used for the middle condition in Color Scale and Data Bar
     *  conditional formats. The rule types are defined in
     *  #lxw_conditional_format_rule_types. *)
    mid_rule_type: UInt8;
    (** The color used for the middle Color Scale conditional format.
     *  See @ref working_with_colors. *)
    mid_color: lxw_color_t;
    (** The maximum value used for Cell, Color Scale and Data Bar conditional
     *  formats. For Cell types this is usually used with a "Between" style
     *  criteria. *)
    max_value: Double;
    (** The maximum string value used for Cell, Color Scale and Data Bar conditional
     *  formats. Usually used to set ranges like `=A1`. *)
    max_value_string: PUTF8Char;
    (** The rule used for the maximum condition in Color Scale and Data Bar
     *  conditional formats. The rule types are defined in
     *  #lxw_conditional_format_rule_types. *)
    max_rule_type: UInt8;
    (** The color used for the maximum Color Scale conditional format.
     *  See @ref working_with_colors. *)
    max_color: lxw_color_t;
    (** The bar_color field sets the fill color for data bars. See @ref
     *  working_with_colors. *)
    bar_color: lxw_color_t;
    (** The bar_only field sets The bar_only field displays a bar data but
     *  not the data in the cells. *)
    bar_only: UInt8;
    (** In Excel 2010 additional data bar properties were added such as solid
     *  (non-gradient) bars and control over how negative values are
     *  displayed. These properties can shown below.
     *
     *  The data_bar_2010 field sets Excel 2010 style data bars even when
     *  Excel 2010 specific properties aren't used. *)
    data_bar_2010: UInt8;
    (** The bar_solid field turns on a solid (non-gradient) fill for data
     *  bars. Set to LXW_TRUE to turn on. Excel 2010 only. *)
    bar_solid: UInt8;
    (** The bar_negative_color field sets the color fill for the negative
     *  portion of a data bar. See @ref working_with_colors. Excel 2010 only. *)
    bar_negative_color: lxw_color_t;
    (** The bar_border_color field sets the color for the border line of a
     *  data bar. See @ref working_with_colors. Excel 2010 only. *)
    bar_border_color: lxw_color_t;
    (** The bar_negative_border_color field sets the color for the border of
     *  the negative portion of a data bar. See @ref
     *  working_with_colors. Excel 2010 only. *)
    bar_negative_border_color: lxw_color_t;
    (** The bar_negative_color_same field sets the fill color for the negative
     *  portion of a data bar to be the same as the fill color for the
     *  positive portion of the data bar. Set to LXW_TRUE to turn on. Excel
     *  2010 only. *)
    bar_negative_color_same: UInt8;
    (** The bar_negative_border_color_same field sets the border color for the
     *  negative portion of a data bar to be the same as the border color for
     *  the positive portion of the data bar. Set to LXW_TRUE to turn
     *  on. Excel 2010 only. *)
    bar_negative_border_color_same: UInt8;
    (** The bar_no_border field turns off the border for data bars. Set to
     *  LXW_TRUE to enable. Excel 2010 only. *)
    bar_no_border: UInt8;
    (** The bar_direction field sets the direction for data bars. This
     *  property can be either left for left-to-right or right for
     *  right-to-left. If the property isn't set then Excel will adjust the
     *  position automatically based on the context. Should be a
     *  #lxw_conditional_format_bar_direction value. Excel 2010 only. *)
    bar_direction: UInt8;
    (** The bar_axis_position field sets the position within the cells for the
     *  axis that is shown in data bars when there are negative values to
     *  display. The property can be either middle or none. If the property
     *  isn't set then Excel will position the axis based on the range of
     *  positive and negative values. Should be a
     *  lxw_conditional_bar_axis_position value. Excel 2010 only. *)
    bar_axis_position: UInt8;
    (** The bar_axis_color field sets the color for the axis that is shown
     *  in data bars when there are negative values to display. See @ref
     *  working_with_colors. Excel 2010 only. *)
    bar_axis_color: lxw_color_t;
    (** The Icons Sets style is specified by the icon_style parameter. Should
     *  be a #lxw_conditional_icon_types. *)
    icon_style: UInt8;
    (** The order of Icon Sets icons can be reversed by setting reverse_icons
     *  to LXW_TRUE.  *)
    reverse_icons: UInt8;
    (** The icons can be displayed without the cell value by settings the
     *  icons_only parameter to LXW_TRUE.  *)
    icons_only: UInt8;
    (** The multi_range field is used to extend a conditional format over
     *  non-contiguous ranges.
     *
     *  It is possible to apply the conditional format to different cell
     *  ranges in a worksheet using multiple calls to
     *  `worksheet_conditional_format()`. However, as a minor optimization it
     *  is also possible in Excel to apply the same conditional format to
     *  different non-contiguous cell ranges.
     *
     *  This is replicated in `worksheet_conditional_format()` using the
     *  multi_range option. The range must contain the primary range for the
     *  conditional format and any others separated by spaces. For example
     *  `"A1 C1:C5 E2 G1:G100"`.
     *)
    multi_range: PUTF8Char;
    (** The stop_if_true parameter can be used to set the "stop if true"
     *  feature of a conditional formatting rule when more than one rule is
     *  applied to a cell or a range of cells. When this parameter is set then
     *  subsequent rules are not evaluated if the current rule is true. Set to
     *  LXW_TRUE to turn on. *)
    stop_if_true: UInt8;
  end;

  P_anonymous_type_19 = ^_anonymous_type_19;
  _anonymous_type_19 = record
    stqe_next: Plxw_cond_format_obj;
  end;

  lxw_cond_format_obj = record
    _type: UInt8;
    criteria: UInt8;
    min_value: Double;
    min_value_string: PUTF8Char;
    min_rule_type: UInt8;
    min_color: lxw_color_t;
    mid_value: Double;
    mid_value_string: PUTF8Char;
    mid_value_type: UInt8;
    mid_rule_type: UInt8;
    mid_color: lxw_color_t;
    max_value: Double;
    max_value_string: PUTF8Char;
    max_value_type: UInt8;
    max_rule_type: UInt8;
    max_color: lxw_color_t;
    data_bar_2010: UInt8;
    auto_min: UInt8;
    auto_max: UInt8;
    bar_only: UInt8;
    bar_solid: UInt8;
    bar_negative_color_same: UInt8;
    bar_negative_border_color_same: UInt8;
    bar_no_border: UInt8;
    bar_direction: UInt8;
    bar_axis_position: UInt8;
    bar_color: lxw_color_t;
    bar_negative_color: lxw_color_t;
    bar_border_color: lxw_color_t;
    bar_negative_border_color: lxw_color_t;
    bar_axis_color: lxw_color_t;
    icon_style: UInt8;
    reverse_icons: UInt8;
    icons_only: UInt8;
    stop_if_true: UInt8;
    has_max: UInt8;
    type_string: PUTF8Char;
    guid: PUTF8Char;
    dxf_index: Int32;
    dxf_priority: UInt32;
    first_cell: array [0..13] of UTF8Char;
    sqref: array [0..2079] of UTF8Char;
    list_pointers: _anonymous_type_19;
  end;

  P_anonymous_type_20 = ^_anonymous_type_20;
  _anonymous_type_20 = record
    rbe_left: Plxw_cond_format_hash_element;
    rbe_right: Plxw_cond_format_hash_element;
    rbe_parent: Plxw_cond_format_hash_element;
    rbe_color: Integer;
  end;

  lxw_cond_format_hash_element = record
    sqref: array [0..2079] of UTF8Char;
    cond_formats: Plxw_cond_format_list;
    tree_pointers: _anonymous_type_20;
  end;

  (**
   * @brief Table columns options.
   *
   * Structure to set the options of a table column added with
   * worksheet_add_table(). See @ref ww_tables_columns.
   *)
  lxw_table_column = packed record
    (** Set the header name/caption for the column. If NULL the header defaults
     *  to  Column 1, Column 2, etc. *)
    header: PUTF8Char;
    (** Set the formula for the column. *)
    formula: PUTF8Char;
    (** Set the string description for the column total.  *)
    total_string: PUTF8Char;
    (** Set the function for the column total.  *)
    total_function: UInt8;
    (** Set the format for the column header.  *)
    header_format: Plxw_format;
    (** Set the format for the data rows in the column.  *)
    format: Plxw_format;
    (** Set the formula value for the column total (not generally required). *)
    total_value: Double;
  end;

  (**
   * @brief Worksheet table options.
   *
   * Options used to define worksheet tables. See @ref working_with_tables for
   * more information.
   *
   *)
  lxw_table_options = packed record
    (**
     * The `name` parameter is used to set the name of the table. This
     * parameter is optional and by default tables are named `Table1`,
     * `Table2`, etc. in the worksheet order that they are added.
     *
     * @code
     *     lxw_table_options options = {.name = "Sales"};
     *
     *     worksheet_add_table(worksheet, RANGE("B3:G8"), &options);
     * @endcode
     *
     * If you override the table name you must ensure that it doesn't clash
     * with an existing table name and that it follows Excel's requirements
     * for table names, see the Microsoft Office documentation on
     * [Naming an Excel Table]
     * (https://support.microsoft.com/en-us/office/rename-an-excel-table-fbf49a4f-82a3-43eb-8ba2-44d21233b114).
     *)
    name: PUTF8Char;
    (**
     * The `no_header_row` parameter can be used to turn off the header row in
     * the table. It is on by default:
     *
     * @code
     *     lxw_table_options options = {.no_header_row = LXW_TRUE};
     *
     *     worksheet_add_table(worksheet, RANGE("B4:F7"), &options);
     * @endcode
     *
     * @image html tables4.png
     *
     * Without this option the header row will contain default captions such
     * as `Column 1`, ``Column 2``, etc. These captions can be overridden
     * using the `columns` parameter shown below.
     *
     *)
    no_header_row: UInt8;
    (**
     * The `no_autofilter` parameter can be used to turn off the autofilter in
     * the header row. It is on by default:
     *
     * @code
     *     lxw_table_options options = {.no_autofilter = LXW_TRUE};
     *
     *     worksheet_add_table(worksheet, RANGE("B3:F7"), &options);
     * @endcode
     *
     * @image html tables3.png
     *
     * The autofilter is only shown if the `no_header_row` parameter is off
     * (the default). Filter conditions within the table are not supported.
     *
     *)
    no_autofilter: UInt8;
    (**
     * The `no_banded_rows` parameter can be used to turn off the rows of alternating
     * color in the table. It is on by default:
     *
     * @code
     *     lxw_table_options options = {.no_banded_rows = LXW_TRUE};
     *
     *     worksheet_add_table(worksheet, RANGE("B3:F7"), &options);
     * @endcode
     *
     * @image html tables6.png
     *
     *)
    no_banded_rows: UInt8;
    (**
     * The `banded_columns` parameter can be used to used to create columns of
     * alternating color in the table. It is off by default:
     *
     * @code
     *     lxw_table_options options = {.banded_columns = LXW_TRUE};
     *
     *     worksheet_add_table(worksheet, RANGE("B3:F7"), &options);
     * @endcode
     *
     * The banded columns formatting is shown in the image in the previous
     * section above.
     *)
    banded_columns: UInt8;
    (**
     * The `first_column` parameter can be used to highlight the first column
     * of the table. The type of highlighting will depend on the `style_type`
     * of the table. It may be bold text or a different color. It is off by
     * default:
     *
     * @code
     *     lxw_table_options options = {.first_column = LXW_TRUE, .last_column = LXW_TRUE};
     *
     *     worksheet_add_table(worksheet, RANGE("B3:F7"), &options);
     * @endcode
     *
     * @image html tables5.png
     *)
    first_column: UInt8;
    (**
     * The `last_column` parameter can be used to highlight the last column of
     * the table. The type of highlighting will depend on the `style` of the
     * table. It may be bold text or a different color. It is off by default:
     *
     * @code
     *     lxw_table_options options = {.first_column = LXW_TRUE, .last_column = LXW_TRUE};
     *
     *     worksheet_add_table(worksheet, RANGE("B3:F7"), &options);
     * @endcode
     *
     * The `last_column` formatting is shown in the image in the previous
     * section above.
     *)
    last_column: UInt8;
    (**
     * The `style_type` parameter can be used to set the style of the table,
     * in conjunction with the `style_type_number` parameter:
     *
     * @code
     *     lxw_table_options options = {
     *         .style_type = LXW_TABLE_STYLE_TYPE_LIGHT,
     *         .style_type_number = 11,
     *     };
     *
     *     worksheet_add_table(worksheet, RANGE("B3:G8"), &options);
     * @endcode
     *
     *
     * @image html tables11.png
     *
     * There are three types of table style in Excel: Light, Medium and Dark
     * which are represented using the #lxw_table_style_type enum values:
     *
     * - #LXW_TABLE_STYLE_TYPE_LIGHT
     *
     * - #LXW_TABLE_STYLE_TYPE_MEDIUM
     *
     * - #LXW_TABLE_STYLE_TYPE_DARK
     *
     * Within those ranges there are between 11 and 28 other style types which
     * can be set with `style_type_number` (depending on the style type).
     * Check Excel to find the style that you want. The dialog with the
     * options laid out in numeric order are shown below:
     *
     * @image html tables14.png
     *
     * The default table style in Excel is 'Table Style Medium 9' (highlighted
     * with a green border in the image above), which is set by default in
     * libxlsxwriter as:
     *
     * @code
     *     lxw_table_options options = {
     *         .style_type = LXW_TABLE_STYLE_TYPE_MEDIUM,
     *         .style_type_number = 9,
     *     };
     * @endcode
     *
     * You can also turn the table style off by setting it to Light 0:
     *
     * @code
     *     lxw_table_options options = {
     *         .style_type = LXW_TABLE_STYLE_TYPE_LIGHT,
     *         .style_type_number = 0,
     *     };
     * @endcode
     *
     * @image html tables13.png
     *
     *)
    style_type: UInt8;
    (**
     * The `style_type_number` parameter is used with `style_type` to set the
     * style of a worksheet table. *)
    style_type_number: UInt8;
    (**
     * The `total_row` parameter can be used to turn on the total row in the
     * last row of a table. It is distinguished from the other rows by a
     * different formatting and also with dropdown `SUBTOTAL` functions:
     *
     * @code
     *     lxw_table_options options = {.total_row = LXW_TRUE};
     *
     *     worksheet_add_table(worksheet, RANGE("B3:G8"), &options);
     * @endcode
     *
     * @image html tables9.png
     *
     * The default total row doesn't have any captions or functions. These
     * must by specified via the `columns` parameter below.
     *)
    total_row: UInt8;
    (**
     * The `columns` parameter can be used to set properties for columns
     * within the table. See @ref ww_tables_columns for a detailed
     * explanation.
     *)
    columns: PPlxw_table_column;
  end;

  P_anonymous_type_21 = ^_anonymous_type_21;
  _anonymous_type_21 = record
    stqe_next: Plxw_table_obj;
  end;

  lxw_table_obj = record
    name: PUTF8Char;
    total_string: PUTF8Char;
    columns: PPlxw_table_column;
    banded_columns: UInt8;
    first_column: UInt8;
    last_column: UInt8;
    no_autofilter: UInt8;
    no_banded_rows: UInt8;
    no_header_row: UInt8;
    style_type: UInt8;
    style_type_number: UInt8;
    total_row: UInt8;
    first_row: lxw_row_t;
    first_col: lxw_col_t;
    last_row: lxw_row_t;
    last_col: lxw_col_t;
    num_cols: lxw_col_t;
    id: UInt32;
    sqref: array [0..2079] of UTF8Char;
    filter_sqref: array [0..2079] of UTF8Char;
    list_pointers: _anonymous_type_21;
  end;

  (**
   * @brief Options for autofilter rules.
   *
   * Options to define an autofilter rule.
   *
   *)
  lxw_filter_rule = packed record
    (** The #lxw_filter_criteria to define the rule. *)
    criteria: UInt8;
    (** String value to which the criteria applies. *)
    value_string: PUTF8Char;
    (** Numeric value to which the criteria applies (if value_string isn't used). *)
    value: Double;
  end;

  lxw_filter_rule_obj = record
    _type: UInt8;
    is_custom: UInt8;
    has_blanks: UInt8;
    col_num: lxw_col_t;
    criteria1: UInt8;
    criteria2: UInt8;
    value1: Double;
    value2: Double;
    value1_string: PUTF8Char;
    value2_string: PUTF8Char;
    num_list_filters: UInt16;
    list: PPUTF8Char;
  end;

  (**
   * @brief Options for inserted images.
   *
   * Options for modifying images inserted via `worksheet_insert_image_opt()`.
   *
   *)
  lxw_image_options = packed record
    (** Offset from the left of the cell in pixels. *)
    x_offset: Int32;
    (** Offset from the top of the cell in pixels. *)
    y_offset: Int32;
    (** X scale of the image as a decimal. *)
    x_scale: Double;
    (** Y scale of the image as a decimal. *)
    y_scale: Double;
    (** Object position - use one of the values of #lxw_object_position.
     *  See @ref working_with_object_positioning.*)
    object_position: UInt8;
    (** Optional description or "Alt text" for the image. This field can be
     *  used to provide a text description of the image to help
     *  accessibility. Defaults to the image filename as in Excel. Set to ""
     *  to ignore the description field. *)
    description: PUTF8Char;
    (** Optional parameter to help accessibility. It is used to mark the image
     *  as decorative, and thus uninformative, for automated screen
     *  readers. As in Excel, if this parameter is in use the `description`
     *  field isn't written. *)
    decorative: UInt8;
    (** Add an optional hyperlink to the image. Follows the same URL rules
     *  and types as `worksheet_write_url()`. *)
    url: PUTF8Char;
    (** Add an optional mouseover tip for a hyperlink to the image. *)
    tip: PUTF8Char;
    (** Add an optional format to the cell. Only used with
     * `worksheet_embed_image_opt()` *)
    cell_format: Plxw_format;
  end;

  (**
   * @brief Options for inserted charts.
   *
   * Options for modifying charts inserted via `worksheet_insert_chart_opt()`.
   *
   *)
  lxw_chart_options = packed record
    (** Offset from the left of the cell in pixels. *)
    x_offset: Int32;
    (** Offset from the top of the cell in pixels. *)
    y_offset: Int32;
    (** X scale of the chart as a decimal. *)
    x_scale: Double;
    (** Y scale of the chart as a decimal. *)
    y_scale: Double;
    (** Object position - use one of the values of #lxw_object_position.
     *  See @ref working_with_object_positioning.*)
    object_position: UInt8;
    (** Optional description or "Alt text" for the chart. This field can be
     *  used to provide a text description of the chart to help
     *  accessibility. Defaults to the image filename as in Excel. Set to NULL
     *  to ignore the description field. *)
    description: PUTF8Char;
    (** Optional parameter to help accessibility. It is used to mark the chart
     *  as decorative, and thus uninformative, for automated screen
     *  readers. As in Excel, if this parameter is in use the `description`
     *  field isn't written. *)
    decorative: UInt8;
  end;

  P_anonymous_type_22 = ^_anonymous_type_22;
  _anonymous_type_22 = record
    stqe_next: Plxw_object_properties;
  end;

  lxw_object_properties = record
    x_offset: Int32;
    y_offset: Int32;
    x_scale: Double;
    y_scale: Double;
    row: lxw_row_t;
    col: lxw_col_t;
    filename: PUTF8Char;
    description: PUTF8Char;
    url: PUTF8Char;
    tip: PUTF8Char;
    object_position: UInt8;
    stream: PPointer;
    image_type: UInt8;
    is_image_buffer: UInt8;
    image_buffer: PUTF8Char;
    image_buffer_size: NativeUInt;
    width: Double;
    height: Double;
    extension: PUTF8Char;
    x_dpi: Double;
    y_dpi: Double;
    chart: Plxw_chart;
    is_duplicate: UInt8;
    is_background: UInt8;
    md5: PUTF8Char;
    image_position: PUTF8Char;
    decorative: UInt8;
    format: Plxw_format;
    list_pointers: _anonymous_type_22;
  end;

  (**
   * @brief Options for inserted comments.
   *
   * Options for modifying comments inserted via `worksheet_write_comment_opt()`.
   *
   *)
  lxw_comment_options = record
    (** This option is used to make a cell comment visible when the worksheet
     *  is opened. The default behavior in Excel is that comments are
     *  initially hidden. However, it is also possible in Excel to make
     *  individual comments or all comments visible.  You can make all
     *  comments in the worksheet visible using the
     *  `worksheet_show_comments()` function. Defaults to
     *  LXW_COMMENT_DISPLAY_DEFAULT. See also @ref ww_comments_visible. *)
    visible: UInt8;
    (** This option is used to indicate the author of the cell comment. Excel
     *  displays the author in the status bar at the bottom of the
     *  worksheet. The default author for all cell comments in a worksheet can
     *  be set using the `worksheet_set_comments_author()` function. Set to
     *  NULL if not required.  See also @ref ww_comments_author. *)
    author: PUTF8Char;
    (** This option is used to set the width of the cell comment box
     *  explicitly in pixels. The default width is 128 pixels. See also @ref
     *  ww_comments_width. *)
    width: UInt16;
    (** This option is used to set the height of the cell comment box
     *  explicitly in pixels. The default height is 74 pixels.  See also @ref
     *  ww_comments_height. *)
    height: UInt16;
    (** X scale of the comment as a decimal. See also
     * @ref ww_comments_x_scale. *)
    x_scale: Double;
    (** Y scale of the comment as a decimal. See also
     * @ref ww_comments_y_scale. *)
    y_scale: Double;
    (** This option is used to set the background color of cell comment
     *  box. The color should be an RGB integer value, see @ref
     *  working_with_colors. See also @ref ww_comments_color. *)
    color: lxw_color_t;
    (** This option is used to set the font for the comment. The default font
     *  is 'Tahoma'.  See also @ref ww_comments_font_name. *)
    font_name: PUTF8Char;
    (** This option is used to set the font size for the comment. The default
     * is 8. See also @ref ww_comments_font_size. *)
    font_size: Double;
    (** This option is used to set the font family number for the comment.
     *  Not required very often. Set to 0. *)
    font_family: UInt8;
    (** This option is used to set the row in which the comment will
     *  appear. By default Excel displays comments one cell to the right and
     *  one cell above the cell to which the comment relates. The `start_row`
     *  and `start_col` options should both be set to 0 if not used.  See also
     *  @ref ww_comments_start_row. *)
    start_row: lxw_row_t;
    (** This option is used to set the column in which the comment will
     *   appear. See the `start_row` option for more information and see also
     *   @ref ww_comments_start_col. *)
    start_col: lxw_col_t;
    (** Offset from the left of the cell in pixels. See also
     * @ref ww_comments_x_offset. *)
    x_offset: Int32;
    (** Offset from the top of the cell in pixels. See also
     * @ref ww_comments_y_offset. *)
    y_offset: Int32;
  end;

  (**
   * @brief Options for inserted buttons.
   *
   * Options for modifying buttons inserted via `worksheet_insert_button()`.
   *
   *)
  lxw_button_options = packed record
    (** Sets the caption on the button. The default is "Button n" where n is
     *  the current number of buttons in the worksheet, including this
     *  button. *)
    caption: PUTF8Char;
    (** Name of the macro to run when the button is pressed. The macro must be
     *  included with workbook_add_vba_project(). *)
    macro: PUTF8Char;
    (** Optional description or "Alt text" for the button. This field can be
     *  used to provide a text description of the button to help
     *  accessibility. Set to NULL to ignore the description field. *)
    description: PUTF8Char;
    (** This option is used to set the width of the cell button box
     *  explicitly in pixels. The default width is 64 pixels. *)
    width: UInt16;
    (** This option is used to set the height of the cell button box
     *  explicitly in pixels. The default height is 20 pixels. *)
    height: UInt16;
    (** X scale of the button as a decimal. *)
    x_scale: Double;
    (** Y scale of the button as a decimal. *)
    y_scale: Double;
    (** Offset from the left of the cell in pixels.  *)
    x_offset: Int32;
    (** Offset from the top of the cell in pixels. *)
    y_offset: Int32;
  end;

  P_anonymous_type_23 = ^_anonymous_type_23;
  _anonymous_type_23 = record
    stqe_next: Plxw_vml_obj;
  end;

  lxw_vml_obj = record
    row: lxw_row_t;
    col: lxw_col_t;
    start_row: lxw_row_t;
    start_col: lxw_col_t;
    x_offset: Int32;
    y_offset: Int32;
    col_absolute: UInt64;
    row_absolute: UInt64;
    width: UInt32;
    height: UInt32;
    x_dpi: Double;
    y_dpi: Double;
    color: lxw_color_t;
    font_family: UInt8;
    visible: UInt8;
    author_id: UInt32;
    rel_index: UInt32;
    font_size: Double;
    from: lxw_drawing_coords;
    _to: lxw_drawing_coords;
    author: PUTF8Char;
    font_name: PUTF8Char;
    text: PUTF8Char;
    image_position: PUTF8Char;
    name: PUTF8Char;
    macro: PUTF8Char;
    list_pointers: _anonymous_type_23;
  end;

  (**
   * @brief Header and footer options.
   *
   * Optional parameters used in the `worksheet_set_header_opt()` and
   * worksheet_set_footer_opt() functions.
   *
   *)
  lxw_header_footer_options = packed record
    (** Header or footer margin in inches. Excel default is 0.3. Must by
     *  larger than 0.0.  See `worksheet_set_header_opt()`. *)
    margin: Double;
    (** The left header image filename, with path if required. This should
     * have a corresponding `&G/&[Picture]` placeholder in the `&L` section of
     * the header/footer string. See `worksheet_set_header_opt()`. *)
    image_left: PUTF8Char;
    (** The center header image filename, with path if required. This should
     * have a corresponding `&G/&[Picture]` placeholder in the `&C` section of
     * the header/footer string. See `worksheet_set_header_opt()`. *)
    image_center: PUTF8Char;
    (** The right header image filename, with path if required. This should
     * have a corresponding `&G/&[Picture]` placeholder in the `&R` section of
     * the header/footer string. See `worksheet_set_header_opt()`. *)
    image_right: PUTF8Char;
  end;

  (**
   * @brief Worksheet protection options.
   *)
  lxw_protection = packed record
    (** Turn off selection of locked cells. This in on in Excel by default.*)
    no_select_locked_cells: UInt8;
    (** Turn off selection of unlocked cells. This in on in Excel by default.*)
    no_select_unlocked_cells: UInt8;
    (** Prevent formatting of cells. *)
    format_cells: UInt8;
    (** Prevent formatting of columns. *)
    format_columns: UInt8;
    (** Prevent formatting of rows. *)
    format_rows: UInt8;
    (** Prevent insertion of columns. *)
    insert_columns: UInt8;
    (** Prevent insertion of rows. *)
    insert_rows: UInt8;
    (** Prevent insertion of hyperlinks. *)
    insert_hyperlinks: UInt8;
    (** Prevent deletion of columns. *)
    delete_columns: UInt8;
    (** Prevent deletion of rows. *)
    delete_rows: UInt8;
    (** Prevent sorting data. *)
    sort: UInt8;
    (** Prevent filtering data. *)
    autofilter: UInt8;
    (** Prevent insertion of pivot tables. *)
    pivot_tables: UInt8;
    (** Protect scenarios. *)
    scenarios: UInt8;
    (** Protect drawing objects. Worksheets only. *)
    objects: UInt8;
    (** Turn off chartsheet content protection. *)
    no_content: UInt8;
    (** Turn off chartsheet objects. *)
    no_objects: UInt8;
  end;

  lxw_protection_obj = record
    no_select_locked_cells: UInt8;
    no_select_unlocked_cells: UInt8;
    format_cells: UInt8;
    format_columns: UInt8;
    format_rows: UInt8;
    insert_columns: UInt8;
    insert_rows: UInt8;
    insert_hyperlinks: UInt8;
    delete_columns: UInt8;
    delete_rows: UInt8;
    sort: UInt8;
    autofilter: UInt8;
    pivot_tables: UInt8;
    scenarios: UInt8;
    objects: UInt8;
    no_content: UInt8;
    no_objects: UInt8;
    no_sheet: UInt8;
    is_configured: UInt8;
    hash: array [0..4] of UTF8Char;
  end;

  (**
   * @brief Struct to represent a rich string format/string pair.
   *
   * Arrays of this struct are used to define "rich" multi-format strings that
   * are passed to `worksheet_write_rich_string()`. Each struct represents a
   * fragment of the rich multi-format string with a lxw_format to define the
   * format for the string part. If the string fragment is unformatted then
   * `NULL` can be used for the format.
   *)
  lxw_rich_string_tuple = packed record
    (** The format for a string fragment in a rich string. NULL if the string
     *  isn't formatted. *)
    format: Plxw_format;
    (** The string fragment. *)
    _str: PUTF8Char;
  end;

  P_anonymous_type_24 = ^_anonymous_type_24;
  _anonymous_type_24 = record
    stqe_next: Plxw_worksheet;
  end;

  (**
   * @brief Struct to represent an Excel worksheet.
   *
   * The members of the lxw_worksheet struct aren't modified directly. Instead
   * the worksheet properties are set by calling the functions shown in
   * worksheet.h.
   *)
  lxw_worksheet = record
    _file: PPointer;
    optimize_tmpfile: PPointer;
    optimize_buffer: PUTF8Char;
    optimize_buffer_size: NativeUInt;
    table: Plxw_table_rows;
    hyperlinks: Plxw_table_rows;
    comments: Plxw_table_rows;
    _array: PPlxw_cell;
    merged_ranges: Plxw_merged_ranges;
    selections: Plxw_selections;
    data_validations: Plxw_data_validations;
    conditional_formats: Plxw_cond_format_hash;
    image_props: Plxw_image_props;
    embedded_image_props: Plxw_image_props;
    chart_data: Plxw_chart_props;
    drawing_rel_ids: Plxw_drawing_rel_ids;
    vml_drawing_rel_ids: Plxw_vml_drawing_rel_ids;
    comment_objs: Plxw_comment_objs;
    header_image_objs: Plxw_comment_objs;
    button_objs: Plxw_comment_objs;
    table_objs: Plxw_table_objs;
    table_count: UInt16;
    dim_rowmin: lxw_row_t;
    dim_rowmax: lxw_row_t;
    dim_colmin: lxw_col_t;
    dim_colmax: lxw_col_t;
    sst: Plxw_sst;
    name: PUTF8Char;
    quoted_name: PUTF8Char;
    tmpdir: PUTF8Char;
    index: UInt16;
    active: UInt8;
    selected: UInt8;
    hidden: UInt8;
    active_sheet: PUInt16;
    first_sheet: PUInt16;
    is_chartsheet: UInt8;
    col_options: PPlxw_col_options;
    col_options_max: UInt16;
    col_sizes: PDouble;
    col_sizes_max: UInt16;
    col_formats: PPlxw_format;
    col_formats_max: UInt16;
    col_size_changed: UInt8;
    row_size_changed: UInt8;
    optimize: UInt8;
    optimize_row: Plxw_row;
    fit_height: UInt16;
    fit_width: UInt16;
    horizontal_dpi: UInt16;
    hlink_count: UInt16;
    page_start: UInt16;
    print_scale: UInt16;
    rel_count: UInt16;
    vertical_dpi: UInt16;
    zoom: UInt16;
    filter_on: UInt8;
    fit_page: UInt8;
    hcenter: UInt8;
    orientation: UInt8;
    outline_changed: UInt8;
    outline_on: UInt8;
    outline_style: UInt8;
    outline_below: UInt8;
    outline_right: UInt8;
    page_order: UInt8;
    page_setup_changed: UInt8;
    page_view: UInt8;
    paper_size: UInt8;
    print_gridlines: UInt8;
    print_headers: UInt8;
    print_options_changed: UInt8;
    right_to_left: UInt8;
    screen_gridlines: UInt8;
    show_zeros: UInt8;
    vcenter: UInt8;
    zoom_scale_normal: UInt8;
    black_white: UInt8;
    num_validations: UInt8;
    has_dynamic_functions: UInt8;
    vba_codename: PUTF8Char;
    num_buttons: UInt16;
    tab_color: lxw_color_t;
    margin_left: Double;
    margin_right: Double;
    margin_top: Double;
    margin_bottom: Double;
    margin_header: Double;
    margin_footer: Double;
    default_row_height: Double;
    default_row_pixels: UInt32;
    default_col_pixels: UInt32;
    default_row_zeroed: UInt8;
    default_row_set: UInt8;
    outline_row_level: UInt8;
    outline_col_level: UInt8;
    header_footer_changed: UInt8;
    header: PUTF8Char;
    footer: PUTF8Char;
    repeat_rows: lxw_repeat_rows;
    repeat_cols: lxw_repeat_cols;
    print_area: lxw_print_area;
    autofilter: lxw_autofilter;
    merged_range_count: UInt16;
    max_url_length: UInt16;
    hbreaks: Plxw_row_t;
    vbreaks: Plxw_col_t;
    hbreaks_count: UInt16;
    vbreaks_count: UInt16;
    drawing_rel_id: UInt32;
    vml_drawing_rel_id: UInt32;
    external_hyperlinks: Plxw_rel_tuples;
    external_drawing_links: Plxw_rel_tuples;
    drawing_links: Plxw_rel_tuples;
    vml_drawing_links: Plxw_rel_tuples;
    external_table_links: Plxw_rel_tuples;
    panes: lxw_panes;
    top_left_cell: array [0..13] of UTF8Char;
    protection: lxw_protection_obj;
    drawing: Plxw_drawing;
    default_url_format: Plxw_format;
    has_vml: UInt8;
    has_comments: UInt8;
    has_header_vml: UInt8;
    has_background_image: UInt8;
    has_buttons: UInt8;
    storing_embedded_image: UInt8;
    external_vml_comment_link: Plxw_rel_tuple;
    external_comment_link: Plxw_rel_tuple;
    external_vml_header_link: Plxw_rel_tuple;
    external_background_link: Plxw_rel_tuple;
    comment_author: PUTF8Char;
    vml_data_id_str: PUTF8Char;
    vml_header_id_str: PUTF8Char;
    vml_shape_id: UInt32;
    vml_header_id: UInt32;
    dxf_priority: UInt32;
    comment_display_default: UInt8;
    data_bar_2010_index: UInt32;
    has_ignore_errors: UInt8;
    ignore_number_stored_as_text: PUTF8Char;
    ignore_eval_error: PUTF8Char;
    ignore_formula_differs: PUTF8Char;
    ignore_formula_range: PUTF8Char;
    ignore_formula_unlocked: PUTF8Char;
    ignore_empty_cell_reference: PUTF8Char;
    ignore_list_data_validation: PUTF8Char;
    ignore_calculated_column: PUTF8Char;
    ignore_two_digit_text_year: PUTF8Char;
	use_1904_epoch: UInt8;
    excel_version: UInt16;
    header_footer_objs: array [0..5] of PPlxw_object_properties;
    header_left_object_props: Plxw_object_properties;
    header_center_object_props: Plxw_object_properties;
    header_right_object_props: Plxw_object_properties;
    footer_left_object_props: Plxw_object_properties;
    footer_center_object_props: Plxw_object_properties;
    footer_right_object_props: Plxw_object_properties;
    background_image: Plxw_object_properties;
    filter_rules: PPlxw_filter_rule_obj;
    num_filter_rules: lxw_col_t;
    list_pointers: _anonymous_type_24;
  end;

  lxw_worksheet_init_data = record
    index: UInt16;
    hidden: UInt8;
    optimize: UInt8;
    active_sheet: PUInt16;
    first_sheet: PUInt16;
    sst: Plxw_sst;
    name: PUTF8Char;
    quoted_name: PUTF8Char;
    tmpdir: PUTF8Char;
    default_url_format: Plxw_format;
    max_url_length: UInt16;
    use_1904_epoch: UInt8;
  end;

  P_anonymous_type_25 = ^_anonymous_type_25;
  _anonymous_type_25 = record
    rbe_left: Plxw_row;
    rbe_right: Plxw_row;
    rbe_parent: Plxw_row;
    rbe_color: Integer;
  end;

  lxw_row = record
    row_num: lxw_row_t;
    height: Double;
    format: Plxw_format;
    hidden: UInt8;
    level: UInt8;
    collapsed: UInt8;
    row_changed: UInt8;
    data_changed: UInt8;
    height_changed: UInt8;
    cells: Plxw_table_cells;
    tree_pointers: _anonymous_type_25;
  end;

  P_anonymous_type_26 = ^_anonymous_type_26;
  _anonymous_type_26 = record
    case Integer of
      0: (number: Double);
      1: (string_id: Int32);
      2: (_str: PUTF8Char);
  end;

  P_anonymous_type_27 = ^_anonymous_type_27;
  _anonymous_type_27 = record
    rbe_left: Plxw_cell;
    rbe_right: Plxw_cell;
    rbe_parent: Plxw_cell;
    rbe_color: Integer;
  end;

  lxw_cell = record
    row_num: lxw_row_t;
    col_num: lxw_col_t;
    _type: cell_types;
    format: Plxw_format;
    comment: Plxw_vml_obj;
    u: _anonymous_type_26;
    formula_result: Double;
    user_data1: PUTF8Char;
    user_data2: PUTF8Char;
    sst_string: PUTF8Char;
    tree_pointers: _anonymous_type_27;
  end;

  P_anonymous_type_28 = ^_anonymous_type_28;
  _anonymous_type_28 = record
    rbe_left: Plxw_drawing_rel_id;
    rbe_right: Plxw_drawing_rel_id;
    rbe_parent: Plxw_drawing_rel_id;
    rbe_color: Integer;
  end;

  lxw_drawing_rel_id = record
    id: UInt32;
    target: PUTF8Char;
    tree_pointers: _anonymous_type_28;
  end;

  P_anonymous_type_29 = ^_anonymous_type_29;
  _anonymous_type_29 = record
    stqe_next: Plxw_chartsheet;
  end;

  (**
   * @brief Struct to represent an Excel chartsheet.
   *
   * The members of the lxw_chartsheet struct aren't modified directly. Instead
   * the chartsheet properties are set by calling the functions shown in
   * chartsheet.h.
   *)
  lxw_chartsheet = record
    _file: PPointer;
    worksheet: Plxw_worksheet;
    chart: Plxw_chart;
    protection: lxw_protection_obj;
    is_protected: UInt8;
    name: PUTF8Char;
    quoted_name: PUTF8Char;
    tmpdir: PUTF8Char;
    index: UInt16;
    active: UInt8;
    selected: UInt8;
    hidden: UInt8;
    active_sheet: PUInt16;
    first_sheet: PUInt16;
    rel_count: UInt16;
    list_pointers: _anonymous_type_29;
  end;

  lxw_worksheet_names = record
    rbh_root: Plxw_worksheet_name;
  end;

  lxw_chartsheet_names = record
    rbh_root: Plxw_chartsheet_name;
  end;

  lxw_image_md5s = record
    rbh_root: Plxw_image_md5;
  end;

  lxw_sheets = record
    stqh_first: Plxw_sheet;
    stqh_last: PPlxw_sheet;
  end;

  lxw_worksheets = record
    stqh_first: Plxw_worksheet;
    stqh_last: PPlxw_worksheet;
  end;

  lxw_chartsheets = record
    stqh_first: Plxw_chartsheet;
    stqh_last: PPlxw_chartsheet;
  end;

  lxw_charts = record
    stqh_first: Plxw_chart;
    stqh_last: PPlxw_chart;
  end;

  lxw_defined_names = record
    tqh_first: Plxw_defined_name;
    tqh_last: PPlxw_defined_name;
  end;

  P_anonymous_type_30 = ^_anonymous_type_30;
  _anonymous_type_30 = record
    case Integer of
      0: (worksheet: Plxw_worksheet);
      1: (chartsheet: Plxw_chartsheet);
  end;

  P_anonymous_type_31 = ^_anonymous_type_31;
  _anonymous_type_31 = record
    stqe_next: Plxw_sheet;
  end;

  lxw_sheet = record
    is_chartsheet: UInt8;
    u: _anonymous_type_30;
    list_pointers: _anonymous_type_31;
  end;

  P_anonymous_type_32 = ^_anonymous_type_32;
  _anonymous_type_32 = record
    rbe_left: Plxw_worksheet_name;
    rbe_right: Plxw_worksheet_name;
    rbe_parent: Plxw_worksheet_name;
    rbe_color: Integer;
  end;

  lxw_worksheet_name = record
    name: PUTF8Char;
    worksheet: Plxw_worksheet;
    tree_pointers: _anonymous_type_32;
  end;

  P_anonymous_type_33 = ^_anonymous_type_33;
  _anonymous_type_33 = record
    rbe_left: Plxw_chartsheet_name;
    rbe_right: Plxw_chartsheet_name;
    rbe_parent: Plxw_chartsheet_name;
    rbe_color: Integer;
  end;

  lxw_chartsheet_name = record
    name: PUTF8Char;
    chartsheet: Plxw_chartsheet;
    tree_pointers: _anonymous_type_33;
  end;

  P_anonymous_type_34 = ^_anonymous_type_34;
  _anonymous_type_34 = record
    rbe_left: Plxw_image_md5;
    rbe_right: Plxw_image_md5;
    rbe_parent: Plxw_image_md5;
    rbe_color: Integer;
  end;

  lxw_image_md5 = record
    id: UInt32;
    md5: PUTF8Char;
    tree_pointers: _anonymous_type_34;
  end;

  P_anonymous_type_35 = ^_anonymous_type_35;
  _anonymous_type_35 = record
    tqe_next: Plxw_defined_name;
    tqe_prev: PPlxw_defined_name;
  end;

  lxw_defined_name = record
    index: Int16;
    hidden: UInt8;
    name: array [0..127] of UTF8Char;
    app_name: array [0..127] of UTF8Char;
    formula: array [0..127] of UTF8Char;
    normalised_name: array [0..127] of UTF8Char;
    normalised_sheetname: array [0..127] of UTF8Char;
    list_pointers: _anonymous_type_35;
  end;

  (**
   * Workbook document properties. Set any unused fields to NULL or 0.
   *)
  lxw_doc_properties = packed record
    (** The title of the Excel Document. *)
    title: PUTF8Char;
    (** The subject of the Excel Document. *)
    subject: PUTF8Char;
    (** The author of the Excel Document. *)
    author: PUTF8Char;
    (** The manager field of the Excel Document. *)
    manager: PUTF8Char;
    (** The company field of the Excel Document. *)
    company: PUTF8Char;
    (** The category of the Excel Document. *)
    category: PUTF8Char;
    (** The keywords of the Excel Document. *)
    keywords: PUTF8Char;
    (** The comment field of the Excel Document. *)
    comments: PUTF8Char;
    (** The status of the Excel Document. *)
    status: PUTF8Char;
    (** The hyperlink base URL of the Excel Document. *)
    hyperlink_base: PUTF8Char;
    (** The file creation date/time shown in Excel. This defaults to the
     * current time and date if set to 0. If you wish to create files that are
     * binary equivalent (for the same input data) then you should set this
     * creation date/time to a known value. *)
    created: Longint;
  end;

  (**
   * @brief Workbook options.
   *
   * Optional parameters when creating a new Workbook object via
   * workbook_new_opt().
   *
   * The following properties are supported:
   *
   * - `constant_memory`: This option reduces the amount of data stored in
   *   memory so that large files can be written efficiently. This option is off
   *   by default. See the notes below for limitations when this mode is on.
   *
   * - `tmpdir`: libxlsxwriter stores workbook data in temporary files prior to
   *   assembling the final XLSX file. The temporary files are created in the
   *   system's temp directory. If the default temporary directory isn't
   *   accessible to your application, or doesn't contain enough space, you can
   *   specify an alternative location using the `tmpdir` option.
   *
   * - `use_zip64`: Make the zip library use ZIP64 extensions when writing very
   *   large xlsx files to allow the zip container, or individual XML files
   *   within it, to be greater than 4 GB. See [ZIP64 on Wikipedia][zip64_wiki]
   *   for more information. This option is off by default.
   *
   *   [zip64_wiki]: https://en.wikipedia.org/wiki/Zip_(file_format)#ZIP64
  
   * - `output_buffer`: Output to a buffer instead of a file. The buffer must be
   *   freed manually by calling free(). This option can only be used if filename
   *   is NULL.
   *
   * - `output_buffer_size`: Used with output_buffer to get the size of the
   *   created buffer. This option can only be used if filename is NULL.
   *
   * @note In `constant_memory` mode each row of in-memory data is written to
   * disk and then freed when a new row is started via one of the
   * `worksheet_write_*()` functions. Therefore, once this option is active data
   * should be written in sequential row by row order. For this reason
   * `worksheet_merge_range()` and some other row based functionality doesn't
   * work in this mode. See @ref ww_mem_constant for more details.
   *
   * @note Also, in `constant_memory` mode the library uses temp file storage
   * for worksheet data. This can lead to an issue on OSes that map the `/tmp`
   * directory into memory since it is possible to consume the "system" memory
   * even though the "process" memory remains constant. In these cases you
   * should use an alternative temp file location by using the `tmpdir` option
   * shown above. See @ref ww_mem_temp for more details.
   *)
  lxw_workbook_options = record
    (** Optimize the workbook to use constant memory for worksheets. *)
    constant_memory: UInt8;
    (** Directory to use for the temporary files created by libxlsxwriter. *)
    tmpdir: PUTF8Char;
    (** Allow ZIP64 extensions when creating the xlsx file zip container. *)
    use_zip64: UInt8;
    (** Output buffer to use instead of writing to a file *)
    output_buffer: PPUTF8Char;
    (** Used with output_buffer to get the size of the created buffer *)
    output_buffer_size: PNativeUInt;
  end;

  (**
   * @brief Struct to represent an Excel workbook.
   *
   * The members of the lxw_workbook struct aren't modified directly. Instead
   * the workbook properties are set by calling the functions shown in
   * workbook.h.
   *)
  lxw_workbook = record
    _file: PPointer;
    sheets: Plxw_sheets;
    worksheets: Plxw_worksheets;
    chartsheets: Plxw_chartsheets;
    worksheet_names: Plxw_worksheet_names;
    chartsheet_names: Plxw_chartsheet_names;
    image_md5s: Plxw_image_md5s;
    embedded_image_md5s: Plxw_image_md5s;
    header_image_md5s: Plxw_image_md5s;
    background_md5s: Plxw_image_md5s;
    charts: Plxw_charts;
    ordered_charts: Plxw_charts;
    formats: Plxw_formats;
    defined_names: Plxw_defined_names;
    sst: Plxw_sst;
    properties: Plxw_doc_properties;
    custom_properties: Plxw_custom_properties;
    filename: PUTF8Char;
    options: lxw_workbook_options;
    num_sheets: UInt16;
    num_worksheets: UInt16;
    num_chartsheets: UInt16;
    first_sheet: UInt16;
    active_sheet: UInt16;
    num_xf_formats: UInt16;
    num_dxf_formats: UInt16;
    num_format_count: UInt16;
    drawing_count: UInt16;
    comment_count: UInt16;
    num_embedded_images: UInt32;
    window_width: UInt16;
    window_height: UInt16;
    font_count: UInt16;
    border_count: UInt16;
    fill_count: UInt16;
    optimize: UInt8;
    max_url_length: UInt16;
    read_only: UInt8;
    has_png: UInt8;
    has_jpeg: UInt8;
    has_bmp: UInt8;
    has_gif: UInt8;
    has_vml: UInt8;
    has_comments: UInt8;
    has_metadata: UInt8;
    has_embedded_images: UInt8;
    has_dynamic_functions: UInt8;
    has_embedded_image_descriptions: UInt8;
    used_xf_formats: Plxw_hash_table;
    used_dxf_formats: Plxw_hash_table;
    vba_project: PUTF8Char;
    vba_project_signature: PUTF8Char;
    vba_codename: PUTF8Char;
	use_1904_epoch: UInt8;
    default_url_format: Plxw_format;
  end;

function lxw_sst_new(): Plxw_sst; cdecl;
  external bj name _PU + 'lxw_sst_new';

procedure lxw_sst_free(sst: Plxw_sst); cdecl;
  external bj name _PU + 'lxw_sst_free';

function lxw_get_sst_index(sst: Plxw_sst; const astring: PUTF8Char; is_rich_string: UInt8): Psst_element; cdecl;
  external bj name _PU + 'lxw_get_sst_index';

procedure lxw_sst_assemble_xml_file(self: Plxw_sst); cdecl;
  external bj name _PU + 'lxw_sst_assemble_xml_file';

function lxw_hash_key_exists(lxw_hash: Plxw_hash_table; key: Pointer; key_len: NativeUInt): Plxw_hash_element; cdecl;
  external bj name _PU + 'lxw_hash_key_exists';

function lxw_insert_hash_element(lxw_hash: Plxw_hash_table; key: Pointer; value: Pointer; key_len: NativeUInt): Plxw_hash_element; cdecl;
  external bj name _PU + 'lxw_insert_hash_element';

function lxw_hash_new(num_buckets: UInt32; free_key: UInt8; free_value: UInt8): Plxw_hash_table; cdecl;
  external bj name _PU + 'lxw_hash_new';

procedure lxw_hash_free(lxw_hash: Plxw_hash_table); cdecl;
  external bj name _PU + 'lxw_hash_free';

function lxw_format_new(): Plxw_format; cdecl;
  external bj name _PU + 'lxw_format_new';

procedure lxw_format_free(format: Plxw_format); cdecl;
  external bj name _PU + 'lxw_format_free';

function lxw_format_get_xf_index(format: Plxw_format): Int32; cdecl;
  external bj name _PU + 'lxw_format_get_xf_index';

function lxw_format_get_dxf_index(format: Plxw_format): Int32; cdecl;
  external bj name _PU + 'lxw_format_get_dxf_index';

function lxw_format_get_font_key(format: Plxw_format): Plxw_font; cdecl;
  external bj name _PU + 'lxw_format_get_font_key';

function lxw_format_get_border_key(format: Plxw_format): Plxw_border; cdecl;
  external bj name _PU + 'lxw_format_get_border_key';

function lxw_format_get_fill_key(format: Plxw_format): Plxw_fill; cdecl;
  external bj name _PU + 'lxw_format_get_fill_key';

(**
 * @brief Set the font used in the cell.
 *
 * @param format    Pointer to a Format instance.
 * @param font_name Cell font name.
 *
 * Specify the font used used in the cell format:
 *
 * @code
 *     format_set_font_name(format, "Avenir Black Oblique");
 * @endcode
 *
 * @image html format_set_font_name.png
 *
 * Excel can only display fonts that are installed on the system that it is
 * running on. Therefore it is generally best to use the fonts that come as
 * standard with Excel such as Calibri, Times New Roman and Courier New.
 *
 * The default font in Excel 2007, and later, is Calibri.
 *)
procedure format_set_font_name(format: Plxw_format; const font_name: PUTF8Char); cdecl;
  external bj name _PU + 'format_set_font_name';

(**
 * @brief Set the size of the font used in the cell.
 *
 * @param format Pointer to a Format instance.
 * @param size   The cell font size.
 *
 * Set the font size of the cell format:
 *
 * @code
 *     format_set_font_size(format, 30);
 * @endcode
 *
 * @image html format_font_size.png
 *
 * Excel adjusts the height of a row to accommodate the largest font
 * size in the row. You can also explicitly specify the height of a
 * row using the worksheet_set_row() function.
 *)
procedure format_set_font_size(format: Plxw_format; size: Double); cdecl;
  external bj name _PU + 'format_set_font_size';

(**
 * @brief Set the color of the font used in the cell.
 *
 * @param format Pointer to a Format instance.
 * @param color  The cell font color.
 *
 *
 * Set the font color:
 *
 * @code
 *     format = workbook_add_format(workbook);
 *     format_set_font_color(format, LXW_COLOR_RED);
 *
 *     worksheet_write_string(worksheet, 0, 0, "Wheelbarrow", format);
 * @endcode
 *
 * @image html format_font_color.png
 *
 * The color should be an RGB integer value, see @ref working_with_colors.
 *
 * @note
 * The format_set_font_color() method is used to set the font color in a
 * cell. To set the color of a cell background use the format_set_bg_color()
 * and format_set_pattern() methods.
 *)
procedure format_set_font_color(format: Plxw_format; color: lxw_color_t); cdecl;
  external bj name _PU + 'format_set_font_color';

(**
 * @brief Turn on bold for the format font.
 *
 * @param format Pointer to a Format instance.
 *
 * Set the bold property of the font:
 *
 * @code
 *     format = workbook_add_format(workbook);
 *     format_set_bold(format);
 *
 *     worksheet_write_string(worksheet, 0, 0, "Bold Text", format);
 * @endcode
 *
 * @image html format_font_bold.png
 *)
procedure format_set_bold(format: Plxw_format); cdecl;
  external bj name _PU + 'format_set_bold';

(**
 * @brief Turn on italic for the format font.
 *
 * @param format Pointer to a Format instance.
 *
 * Set the italic property of the font:
 *
 * @code
 *     format = workbook_add_format(workbook);
 *     format_set_italic(format);
 *
 *     worksheet_write_string(worksheet, 0, 0, "Italic Text", format);
 * @endcode
 *
 * @image html format_font_italic.png
 *)
procedure format_set_italic(format: Plxw_format); cdecl;
  external bj name _PU + 'format_set_italic';

(**
 * @brief Turn on underline for the format:
 *
 * @param format Pointer to a Format instance.
 * @param style Underline style.
 *
 * Set the underline property of the format:
 *
 * @code
 *     format_set_underline(format, LXW_UNDERLINE_SINGLE);
 * @endcode
 *
 * @image html format_font_underlined.png
 *
 * The available underline styles are:
 *
 * - #LXW_UNDERLINE_SINGLE
 * - #LXW_UNDERLINE_DOUBLE
 * - #LXW_UNDERLINE_SINGLE_ACCOUNTING
 * - #LXW_UNDERLINE_DOUBLE_ACCOUNTING
 *
 *)
procedure format_set_underline(format: Plxw_format; style: UInt8); cdecl;
  external bj name _PU + 'format_set_underline';

(**
 * @brief Set the strikeout property of the font.
 *
 * @param format Pointer to a Format instance.
 *
 * @image html format_font_strikeout.png
 *
 *)
procedure format_set_font_strikeout(format: Plxw_format); cdecl;
  external bj name _PU + 'format_set_font_strikeout';

(**
 * @brief Set the superscript/subscript property of the font.
 *
 * @param format Pointer to a Format instance.
 * @param style  Superscript or subscript style.
 *
 * Set the superscript o subscript property of the font.
 *
 * @image html format_font_script.png
 *
 * The available script styles are:
 *
 * - #LXW_FONT_SUPERSCRIPT
 * - #LXW_FONT_SUBSCRIPT
 *)
procedure format_set_font_script(format: Plxw_format; style: UInt8); cdecl;
  external bj name _PU + 'format_set_font_script';

(**
 * @brief Set the Format font family property.
 *
 * @param format Pointer to a Format instance.
 * @param value  The font family index.
 *
 * Set the font family. This is usually an integer in the range 1-4. This
 * function is implemented for completeness but is rarely used in practice.
 *
 * @code
 *     format_set_font_family(format, 178);
 * @endcode
 *
 *)
procedure format_set_font_family(format: Plxw_format; value: UInt8); cdecl;
  external bj name _PU + 'format_set_font_family';

(**
 * @brief Set the Format font character set property.
 *
 * @param format Pointer to a Format instance.
 * @param value  The font character set.
 *
 * Set the font character set property. This function is implemented for
 * completeness but is rarely used in practice.
 *
 * @code
 *     format_set_font_charset(format, 178);
 * @endcode
 *
 *)
procedure format_set_font_charset(format: Plxw_format; value: UInt8); cdecl;
  external bj name _PU + 'format_set_font_charset';

(**
 * @brief Set the number format for a cell.
 *
 * @param format      Pointer to a Format instance.
 * @param num_format The cell number format string.
 *
 * This method is used to define the numerical format of a number in
 * Excel. It controls whether a number is displayed as an integer, a
 * floating point number, a date, a currency value or some other user
 * defined format.
 *
 * The numerical format of a cell can be specified by using a format
 * string:
 *
 * @code
 *     format = workbook_add_format(workbook);
 *     format_set_num_format(format, "d mmm yyyy");
 * @endcode
 *
 * Format strings can control any aspect of number formatting allowed by Excel:
 *
 * @dontinclude format_num_format.c
 * @skipline set_num_format
 * @until 1209
 *
 * @image html format_set_num_format.png
 *
 * To set a number format that matches an Excel format category such as "Date"
 * or "Currency" see @ref ww_formats_categories.
 *
 * The number system used for dates is described in @ref working_with_dates.
 *
 * For more information on number formats in Excel refer to the
 * [Microsoft documentation on cell formats](http://office.microsoft.com/en-gb/assistance/HP051995001033.aspx).
 *)
procedure format_set_num_format(format: Plxw_format; const num_format: PUTF8Char); cdecl;
  external bj name _PU + 'format_set_num_format';

(**
 * @brief Set the Excel built-in number format for a cell.
 *
 * @param format Pointer to a Format instance.
 * @param index  The built-in number format index for the cell.
 *
 * This function is similar to format_set_num_format() except that it takes an
 * index to a limited number of Excel's built-in number formats instead of a
 * user defined format string:
 *
 * @code
 *     format = workbook_add_format(workbook);
 *     format_set_num_format_index(format, 0x0F); // d-mmm-yy
 * @endcode
 *
 * @note
 * Unless you need to specifically access one of Excel's built-in number
 * formats the format_set_num_format() function above is a better
 * solution. The format_set_num_format_index() function is mainly included for
 * backward compatibility and completeness.
 *
 * The Excel built-in number formats as shown in the table below:
 *
 *   | Index | Index | Format String                                        |
 *   | ----- | ----- | ---------------------------------------------------- |
 *   | 0     | 0x00  | `General`                                            |
 *   | 1     | 0x01  | `0`                                                  |
 *   | 2     | 0x02  | `0.00`                                               |
 *   | 3     | 0x03  | `#,##0`                                              |
 *   | 4     | 0x04  | `#,##0.00`                                           |
 *   | 5     | 0x05  | `($#,##0_);($#,##0)`                                 |
 *   | 6     | 0x06  | `($#,##0_);[Red]($#,##0)`                            |
 *   | 7     | 0x07  | `($#,##0.00_);($#,##0.00)`                           |
 *   | 8     | 0x08  | `($#,##0.00_);[Red]($#,##0.00)`                      |
 *   | 9     | 0x09  | `0%`                                                 |
 *   | 10    | 0x0a  | `0.00%`                                              |
 *   | 11    | 0x0b  | `0.00E+00`                                           |
 *   | 12    | 0x0c  | `# ?/?`                                              |
 *   | 13    | 0x0d  | `# ??/??`                                            |
 *   | 14    | 0x0e  | `m/d/yy`                                             |
 *   | 15    | 0x0f  | `d-mmm-yy`                                           |
 *   | 16    | 0x10  | `d-mmm`                                              |
 *   | 17    | 0x11  | `mmm-yy`                                             |
 *   | 18    | 0x12  | `h:mm AM/PM`                                         |
 *   | 19    | 0x13  | `h:mm:ss AM/PM`                                      |
 *   | 20    | 0x14  | `h:mm`                                               |
 *   | 21    | 0x15  | `h:mm:ss`                                            |
 *   | 22    | 0x16  | `m/d/yy h:mm`                                        |
 *   | ...   | ...   | ...                                                  |
 *   | 37    | 0x25  | `(#,##0_);(#,##0)`                                   |
 *   | 38    | 0x26  | `(#,##0_);[Red](#,##0)`                              |
 *   | 39    | 0x27  | `(#,##0.00_);(#,##0.00)`                             |
 *   | 40    | 0x28  | `(#,##0.00_);[Red](#,##0.00)`                        |
 *   | 41    | 0x29  | `_(* #,##0_);_(* (#,##0);_(* "-"_);_(@_)`            |
 *   | 42    | 0x2a  | `_($* #,##0_);_($* (#,##0);_($* "-"_);_(@_)`         |
 *   | 43    | 0x2b  | `_(* #,##0.00_);_(* (#,##0.00);_(* "-"??_);_(@_)`    |
 *   | 44    | 0x2c  | `_($* #,##0.00_);_($* (#,##0.00);_($* "-"??_);_(@_)` |
 *   | 45    | 0x2d  | `mm:ss`                                              |
 *   | 46    | 0x2e  | `[h]:mm:ss`                                          |
 *   | 47    | 0x2f  | `mm:ss.0`                                            |
 *   | 48    | 0x30  | `##0.0E+0`                                           |
 *   | 49    | 0x31  | `@`                                                  |
 *
 * @note
 *  -  Numeric formats 23 to 36 are not documented by Microsoft and may differ
 *     in international versions. The listed date and currency formats may also
 *     vary depending on system settings.
 *  - The dollar sign in the above format appears as the defined local currency
 *    symbol.
 *  - These formats can also be set via format_set_num_format().
 *  - See also @ref ww_formats_categories.
 *)
procedure format_set_num_format_index(format: Plxw_format; index: UInt8); cdecl;
  external bj name _PU + 'format_set_num_format_index';

(**
 * @brief Set the cell unlocked state.
 *
 * @param format Pointer to a Format instance.
 *
 * This property can be used to allow modification of a cell in a protected
 * worksheet. In Excel, cell locking is turned on by default for all
 * cells. However, it only has an effect if the worksheet has been protected
 * using the worksheet worksheet_protect() function:
 *
 * @code
 *     format = workbook_add_format(workbook);
 *     format_set_unlocked(format);
 *
 *     // Enable worksheet protection, without password or options.
 *     worksheet_protect(worksheet, NULL, NULL);
 *
 *     // This cell cannot be edited.
 *     worksheet_write_formula(worksheet, 0, 0, "=1+2", NULL);
 *
 *     // This cell can be edited.
 *     worksheet_write_formula(worksheet, 1, 0, "=1+2", format);
 * @endcode
 *)
procedure format_set_unlocked(format: Plxw_format); cdecl;
  external bj name _PU + 'format_set_unlocked';

(**
 * @brief Hide formulas in a cell.
 *
 * @param format Pointer to a Format instance.
 *
 * This property is used to hide a formula while still displaying its
 * result. This is generally used to hide complex calculations from end users
 * who are only interested in the result. It only has an effect if the
 * worksheet has been protected using the worksheet worksheet_protect()
 * function:
 *
 * @code
 *     format = workbook_add_format(workbook);
 *     format_set_hidden(format);
 *
 *     // Enable worksheet protection, without password or options.
 *     worksheet_protect(worksheet, NULL, NULL);
 *
 *     // The formula in this cell isn't visible.
 *     worksheet_write_formula(worksheet, 0, 0, "=1+2", format);
 * @endcode
 *)
procedure format_set_hidden(format: Plxw_format); cdecl;
  external bj name _PU + 'format_set_hidden';

(**
 * @brief Set the alignment for data in the cell.
 *
 * @param format    Pointer to a Format instance.
 * @param alignment The horizontal and or vertical alignment direction.
 *
 * This method is used to set the horizontal and vertical text alignment within a
 * cell. The following are the available horizontal alignments:
 *
 * - #LXW_ALIGN_LEFT
 * - #LXW_ALIGN_CENTER
 * - #LXW_ALIGN_RIGHT
 * - #LXW_ALIGN_FILL
 * - #LXW_ALIGN_JUSTIFY
 * - #LXW_ALIGN_CENTER_ACROSS
 * - #LXW_ALIGN_DISTRIBUTED
 *
 * The following are the available vertical alignments:
 *
 * - #LXW_ALIGN_VERTICAL_TOP
 * - #LXW_ALIGN_VERTICAL_BOTTOM
 * - #LXW_ALIGN_VERTICAL_CENTER
 * - #LXW_ALIGN_VERTICAL_JUSTIFY
 * - #LXW_ALIGN_VERTICAL_DISTRIBUTED
 *
 * As in Excel, vertical and horizontal alignments can be combined:
 *
 * @code
 *     format = workbook_add_format(workbook);
 *
 *     format_set_align(format, LXW_ALIGN_CENTER);
 *     format_set_align(format, LXW_ALIGN_VERTICAL_CENTER);
 *
 *     worksheet_set_row(0, 30);
 *     worksheet_write_string(worksheet, 0, 0, "Some Text", format);
 * @endcode
 *
 * @image html format_font_align.png
 *
 * Text can be aligned across two or more adjacent cells using the
 * center_across property. However, for genuine merged cells it is better to
 * use the worksheet_merge_range() worksheet method.
 *
 * The vertical justify option can be used to provide automatic text wrapping
 * in a cell. The height of the cell will be adjusted to accommodate the
 * wrapped text. To specify where the text wraps use the
 * format_set_text_wrap() method.
 *)
procedure format_set_align(format: Plxw_format; alignment: UInt8); cdecl;
  external bj name _PU + 'format_set_align';

(**
 * @brief Wrap text in a cell.
 *
 * Turn text wrapping on for text in a cell.
 *
 * @code
 *     format = workbook_add_format(workbook);
 *     format_set_text_wrap(format);
 *
 *     worksheet_write_string(worksheet, 0, 0, "Some long text to wrap in a cell", format);
 * @endcode
 *
 * If you wish to control where the text is wrapped you can add newline characters
 * to the string:
 *
 * @code
 *     format = workbook_add_format(workbook);
 *     format_set_text_wrap(format);
 *
 *     worksheet_write_string(worksheet, 0, 0, "It's\na bum\nwrap", format);
 * @endcode
 *
 * @image html format_font_text_wrap.png
 *
 * Excel will adjust the height of the row to accommodate the wrapped text. A
 * similar effect can be obtained without newlines using the
 * format_set_align() function with #LXW_ALIGN_VERTICAL_JUSTIFY.
 *)
procedure format_set_text_wrap(format: Plxw_format); cdecl;
  external bj name _PU + 'format_set_text_wrap';

(**
 * @brief Set the rotation of the text in a cell.
 *
 * @param format Pointer to a Format instance.
 * @param angle  Rotation angle in the range -90 to 90 and 270.
 *
 * Set the rotation of the text in a cell. The rotation can be any angle in the
 * range -90 to 90 degrees:
 *
 * @code
 *     format = workbook_add_format(workbook);
 *     format_set_rotation(format, 30);
 *
 *     worksheet_write_string(worksheet, 0, 0, "This text is rotated", format);
 * @endcode
 *
 * @image html format_font_text_rotated.png
 *
 * The angle 270 is also supported. This indicates text where the letters run from
 * top to bottom.
 *)
procedure format_set_rotation(format: Plxw_format; angle: Int16); cdecl;
  external bj name _PU + 'format_set_rotation';

(**
 * @brief Set the cell text indentation level.
 *
 * @param format Pointer to a Format instance.
 * @param level  Indentation level.
 *
 * This method can be used to indent text in a cell. The argument, which should be
 * an integer, is taken as the level of indentation:
 *
 * @code
 *     format1 = workbook_add_format(workbook);
 *     format2 = workbook_add_format(workbook);
 *
 *     format_set_indent(format1, 1);
 *     format_set_indent(format2, 2);
 *
 *     worksheet_write_string(worksheet, 0, 0, "This text is indented 1 level",  format1);
 *     worksheet_write_string(worksheet, 1, 0, "This text is indented 2 levels", format2);
 * @endcode
 *
 * @image html text_indent.png
 *
 * @note
 * Indentation is a horizontal alignment property. It will override any other
 * horizontal properties but it can be used in conjunction with vertical
 * properties.
 *)
procedure format_set_indent(format: Plxw_format; level: UInt8); cdecl;
  external bj name _PU + 'format_set_indent';

(**
 * @brief Turn on the text "shrink to fit" for a cell.
 *
 * @param format Pointer to a Format instance.
 *
 * This method can be used to shrink text so that it fits in a cell:
 *
 * @code
 *     format = workbook_add_format(workbook);
 *     format_set_shrink(format);
 *
 *     worksheet_write_string(worksheet, 0, 0, "Honey, I shrunk the text!", format);
 * @endcode
 *)
procedure format_set_shrink(format: Plxw_format); cdecl;
  external bj name _PU + 'format_set_shrink';

(**
 * @brief Set the background fill pattern for a cell
 *
 * @param format Pointer to a Format instance.
 * @param index  Pattern index.
 *
 * Set the background pattern for a cell.
 *
 * The most common pattern is a solid fill of the background color:
 *
 * @code
 *     format = workbook_add_format(workbook);
 *
 *     format_set_pattern (format, LXW_PATTERN_SOLID);
 *     format_set_bg_color(format, LXW_COLOR_YELLOW);
 * @endcode
 *
 * The available fill patterns are:
 *
 *    Fill Type                     | Define
 *    ----------------------------- | -----------------------------
 *    Solid                         | #LXW_PATTERN_SOLID
 *    Medium gray                   | #LXW_PATTERN_MEDIUM_GRAY
 *    Dark gray                     | #LXW_PATTERN_DARK_GRAY
 *    Light gray                    | #LXW_PATTERN_LIGHT_GRAY
 *    Dark horizontal line          | #LXW_PATTERN_DARK_HORIZONTAL
 *    Dark vertical line            | #LXW_PATTERN_DARK_VERTICAL
 *    Dark diagonal stripe          | #LXW_PATTERN_DARK_DOWN
 *    Reverse dark diagonal stripe  | #LXW_PATTERN_DARK_UP
 *    Dark grid                     | #LXW_PATTERN_DARK_GRID
 *    Dark trellis                  | #LXW_PATTERN_DARK_TRELLIS
 *    Light horizontal line         | #LXW_PATTERN_LIGHT_HORIZONTAL
 *    Light vertical line           | #LXW_PATTERN_LIGHT_VERTICAL
 *    Light diagonal stripe         | #LXW_PATTERN_LIGHT_DOWN
 *    Reverse light diagonal stripe | #LXW_PATTERN_LIGHT_UP
 *    Light grid                    | #LXW_PATTERN_LIGHT_GRID
 *    Light trellis                 | #LXW_PATTERN_LIGHT_TRELLIS
 *    12.5% gray                    | #LXW_PATTERN_GRAY_125
 *    6.25% gray                    | #LXW_PATTERN_GRAY_0625
 *
 *)
procedure format_set_pattern(format: Plxw_format; index: UInt8); cdecl;
  external bj name _PU + 'format_set_pattern';

(**
 * @brief Set the pattern background color for a cell.
 *
 * @param format Pointer to a Format instance.
 * @param color  The cell pattern background color.
 *
 * The format_set_bg_color() method can be used to set the background color of
 * a pattern. Patterns are defined via the format_set_pattern() method. If a
 * pattern hasn't been defined then a solid fill pattern is used as the
 * default.
 *
 * Here is an example of how to set up a solid fill in a cell:
 *
 * @code
 *     format = workbook_add_format(workbook);
 *
 *     format_set_pattern (format, LXW_PATTERN_SOLID);
 *     format_set_bg_color(format, LXW_COLOR_GREEN);
 *
 *     worksheet_write_string(worksheet, 0, 0, "Ray", format);
 * @endcode
 *
 * @image html formats_set_bg_color.png
 *
 * The color should be an RGB integer value, see @ref working_with_colors.
 *
 *)
procedure format_set_bg_color(format: Plxw_format; color: lxw_color_t); cdecl;
  external bj name _PU + 'format_set_bg_color';

(**
 * @brief Set the pattern foreground color for a cell.
 *
 * @param format Pointer to a Format instance.
 * @param color  The cell pattern foreground  color.
 *
 * The format_set_fg_color() method can be used to set the foreground color of
 * a pattern.
 *
 * The color should be an RGB integer value, see @ref working_with_colors.
 *
 *)
procedure format_set_fg_color(format: Plxw_format; color: lxw_color_t); cdecl;
  external bj name _PU + 'format_set_fg_color';

(**
 * @brief Set the cell border style.
 *
 * @param format Pointer to a Format instance.
 * @param style  Border style index.
 *
 * Set the cell border style:
 *
 * @code
 *     format_set_border(format, LXW_BORDER_THIN);
 * @endcode
 *
 * Individual border elements can be configured using the following functions with
 * the same parameters:
 *
 * - format_set_bottom()
 * - format_set_top()
 * - format_set_left()
 * - format_set_right()
 *
 * A cell border is comprised of a border on the bottom, top, left and right.
 * These can be set to the same value using format_set_border() or
 * individually using the relevant method calls shown above.
 *
 * The following border styles are available:
 *
 * - #LXW_BORDER_THIN
 * - #LXW_BORDER_MEDIUM
 * - #LXW_BORDER_DASHED
 * - #LXW_BORDER_DOTTED
 * - #LXW_BORDER_THICK
 * - #LXW_BORDER_DOUBLE
 * - #LXW_BORDER_HAIR
 * - #LXW_BORDER_MEDIUM_DASHED
 * - #LXW_BORDER_DASH_DOT
 * - #LXW_BORDER_MEDIUM_DASH_DOT
 * - #LXW_BORDER_DASH_DOT_DOT
 * - #LXW_BORDER_MEDIUM_DASH_DOT_DOT
 * - #LXW_BORDER_SLANT_DASH_DOT
 *
 *  The most commonly used style is the `thin` style.
 *)
procedure format_set_border(format: Plxw_format; style: UInt8); cdecl;
  external bj name _PU + 'format_set_border';

(**
 * @brief Set the cell bottom border style.
 *
 * @param format Pointer to a Format instance.
 * @param style  Border style index.
 *
 * Set the cell bottom border style. See format_set_border() for details on the
 * border styles.
 *)
procedure format_set_bottom(format: Plxw_format; style: UInt8); cdecl;
  external bj name _PU + 'format_set_bottom';

(**
 * @brief Set the cell top border style.
 *
 * @param format Pointer to a Format instance.
 * @param style  Border style index.
 *
 * Set the cell top border style. See format_set_border() for details on the border
 * styles.
 *)
procedure format_set_top(format: Plxw_format; style: UInt8); cdecl;
  external bj name _PU + 'format_set_top';

(**
 * @brief Set the cell left border style.
 *
 * @param format Pointer to a Format instance.
 * @param style  Border style index.
 *
 * Set the cell left border style. See format_set_border() for details on the
 * border styles.
 *)
procedure format_set_left(format: Plxw_format; style: UInt8); cdecl;
  external bj name _PU + 'format_set_left';

(**
 * @brief Set the cell right border style.
 *
 * @param format Pointer to a Format instance.
 * @param style  Border style index.
 *
 * Set the cell right border style. See format_set_border() for details on the
 * border styles.
 *)
procedure format_set_right(format: Plxw_format; style: UInt8); cdecl;
  external bj name _PU + 'format_set_right';

(**
 * @brief Set the color of the cell border.
 *
 * @param format Pointer to a Format instance.
 * @param color  The cell border color.
 *
 * Individual border elements can be configured using the following methods with
 * the same parameters:
 *
 * - format_set_bottom_color()
 * - format_set_top_color()
 * - format_set_left_color()
 * - format_set_right_color()
 *
 * Set the color of the cell borders. A cell border is comprised of a border
 * on the bottom, top, left and right. These can be set to the same color
 * using format_set_border_color() or individually using the relevant method
 * calls shown above.
 *
 * The color should be an RGB integer value, see @ref working_with_colors.
 *)
procedure format_set_border_color(format: Plxw_format; color: lxw_color_t); cdecl;
  external bj name _PU + 'format_set_border_color';

(**
 * @brief Set the color of the bottom cell border.
 *
 * @param format Pointer to a Format instance.
 * @param color  The cell border color.
 *
 * See format_set_border_color() for details on the border colors.
 *)
procedure format_set_bottom_color(format: Plxw_format; color: lxw_color_t); cdecl;
  external bj name _PU + 'format_set_bottom_color';

(**
 * @brief Set the color of the top cell border.
 *
 * @param format Pointer to a Format instance.
 * @param color  The cell border color.
 *
 * See format_set_border_color() for details on the border colors.
 *)
procedure format_set_top_color(format: Plxw_format; color: lxw_color_t); cdecl;
  external bj name _PU + 'format_set_top_color';

(**
 * @brief Set the color of the left cell border.
 *
 * @param format Pointer to a Format instance.
 * @param color  The cell border color.
 *
 * See format_set_border_color() for details on the border colors.
 *)
procedure format_set_left_color(format: Plxw_format; color: lxw_color_t); cdecl;
  external bj name _PU + 'format_set_left_color';

(**
 * @brief Set the color of the right cell border.
 *
 * @param format Pointer to a Format instance.
 * @param color  The cell border color.
 *
 * See format_set_border_color() for details on the border colors.
 *)
procedure format_set_right_color(format: Plxw_format; color: lxw_color_t); cdecl;
  external bj name _PU + 'format_set_right_color';

(**
 * @brief Set the diagonal cell border type.
 *
 * @param format Pointer to a Format instance.
 * @param type   The #lxw_format_diagonal_types diagonal border type.
 *
 * Set the diagonal cell border type:
 *
 * @code
 *     lxw_format *format1 = workbook_add_format(workbook);
 *     format_set_diag_type(  format1, LXW_DIAGONAL_BORDER_UP);
 *
 *     lxw_format *format2 = workbook_add_format(workbook);
 *     format_set_diag_type(  format2, LXW_DIAGONAL_BORDER_DOWN);
 *
 *     lxw_format *format3 = workbook_add_format(workbook);
 *     format_set_diag_type(  format3, LXW_DIAGONAL_BORDER_UP_DOWN);
 *
 *     lxw_format *format4 = workbook_add_format(workbook);
 *     format_set_diag_type(  format4, LXW_DIAGONAL_BORDER_UP_DOWN);
 *     format_set_diag_border(format4, LXW_BORDER_HAIR);
 *     format_set_diag_color( format4, LXW_COLOR_RED);
 *
 *     worksheet_write_string(worksheet, CELL("B3"),  "Text", format1);
 *     worksheet_write_string(worksheet, CELL("B6"),  "Text", format2);
 *     worksheet_write_string(worksheet, CELL("B9"),  "Text", format3);
 *     worksheet_write_string(worksheet, CELL("B12"), "Text", format4);
 * @endcode
 *
 * @image html diagonal_border.png
 *
 * The allowable border types are defined in #lxw_format_diagonal_types:
 *
 * - #LXW_DIAGONAL_BORDER_UP: Cell diagonal border from bottom left to top
 *   right.
 *
 * - #LXW_DIAGONAL_BORDER_DOWN: Cell diagonal border from top left to bottom
 *   right.
 *
 * - #LXW_DIAGONAL_BORDER_UP_DOWN: Cell diagonal border from top left to
 *   bottom right. A combination of the 2 previous types.
 *
 * If the border style isn't specified with `format_set_diag_border()` then it
 * will default to #LXW_BORDER_THIN.
 *)
procedure format_set_diag_type(format: Plxw_format; atype: UInt8); cdecl;
  external bj name _PU + 'format_set_diag_type';

(**
 * @brief Set the diagonal cell border style.
 *
 * @param format Pointer to a Format instance.
 * @param style  The #lxw_format_borders style.
 *
 * Set the diagonal border style. This should be a #lxw_format_borders value.
 * See the example above.
 *
 *)
procedure format_set_diag_border(format: Plxw_format; style: UInt8); cdecl;
  external bj name _PU + 'format_set_diag_border';

(**
 * @brief Set the diagonal cell border color.
 *
 * @param format Pointer to a Format instance.
 * @param color  The cell diagonal border color.
 *
 * Set the diagonal border color. The color should be an RGB integer value,
 * see @ref working_with_colors and the above example.
 *)
procedure format_set_diag_color(format: Plxw_format; color: lxw_color_t); cdecl;
  external bj name _PU + 'format_set_diag_color';

(**
 * @brief Turn on quote prefix for the format.
 *
 * @param format Pointer to a Format instance.
 *
 * Set the quote prefix property of a format to ensure a string is treated
 * as a string after editing. This is the same as prefixing the string with
 * a single quote in Excel. You don't need to add the quote to the
 * string but you do need to add the format.
 *
 * @code
 *     format = workbook_add_format(workbook);
 *     format_set_quote_prefix(format);
 *
 *     worksheet_write_string(worksheet, 0, 0, "=Foo", format);
 * @endcode
 *
 *)
procedure format_set_quote_prefix(format: Plxw_format); cdecl;
  external bj name _PU + 'format_set_quote_prefix';

procedure format_set_font_outline(format: Plxw_format); cdecl;
  external bj name _PU + 'format_set_font_outline';

procedure format_set_font_shadow(format: Plxw_format); cdecl;
  external bj name _PU + 'format_set_font_shadow';

procedure format_set_font_scheme(format: Plxw_format; const font_scheme: PUTF8Char); cdecl;
  external bj name _PU + 'format_set_font_scheme';

procedure format_set_font_condense(format: Plxw_format); cdecl;
  external bj name _PU + 'format_set_font_condense';

procedure format_set_font_extend(format: Plxw_format); cdecl;
  external bj name _PU + 'format_set_font_extend';

procedure format_set_reading_order(format: Plxw_format; value: UInt8); cdecl;
  external bj name _PU + 'format_set_reading_order';

procedure format_set_theme(format: Plxw_format; value: UInt8); cdecl;
  external bj name _PU + 'format_set_theme';

procedure format_set_hyperlink(format: Plxw_format); cdecl;
  external bj name _PU + 'format_set_hyperlink';

procedure format_set_color_indexed(format: Plxw_format; value: UInt8); cdecl;
  external bj name _PU + 'format_set_color_indexed';

procedure format_set_font_only(format: Plxw_format); cdecl;
  external bj name _PU + 'format_set_font_only';

function lxw_chart_new(atype: UInt8): Plxw_chart; cdecl;
  external bj name _PU + 'lxw_chart_new';

procedure lxw_chart_free(chart: Plxw_chart); cdecl;
  external bj name _PU + 'lxw_chart_free';

procedure lxw_chart_assemble_xml_file(chart: Plxw_chart); cdecl;
  external bj name _PU + 'lxw_chart_assemble_xml_file';

(**
 * @brief Add a data series to a chart.
 *
 * @param chart      Pointer to a lxw_chart instance to be configured.
 * @param categories The range of categories in the data series.
 * @param values     The range of values in the data series.
 *
 * @return A lxw_chart_series object pointer.
 *
 * In Excel a chart **series** is a collection of information that defines
 * which data is plotted such as the categories and values. It is also used to
 * define the formatting for the data.
 *
 * For an libxlsxwriter chart object the `%chart_add_series()` function is
 * used to set the categories and values of the series:
 *
 * @code
 *     chart_add_series(chart, "=Sheet1!$A$2:$A$7", "=Sheet1!$C$2:$C$7");
 * @endcode
 *
 *
 * The series parameters are:
 *
 * - `categories`: This sets the chart category labels. The category is more
 *   or less the same as the X axis. In most Excel chart types the
 *   `categories` property is optional and the chart will just assume a
 *   sequential series from `1..n`:
 *
 * @code
 *     // The NULL category will default to 1 to 5 like in Excel.
 *     chart_add_series(chart, NULL, "Sheet1!$A$1:$A$5");
 * @endcode
 *
 *  - `values`: This is the most important property of a series and is the
 *    only mandatory option for every chart object. This parameter links the
 *    chart with the worksheet data that it displays.
 *
 * The `categories` and `values` should be a string formula like
 * `"=Sheet1!$A$2:$A$7"` in the same way it is represented in Excel. This is
 * convenient when recreating a chart from an example in Excel but it is
 * trickier to generate programmatically. For these cases you can set the
 * `categories` and `values` to `NULL` and use the
 * `chart_series_set_categories()` and `chart_series_set_values()` functions:
 *
 * @code
 *     lxw_chart_series *series = chart_add_series(chart, NULL, NULL);
 *
 *     // Configure the series using a syntax that is easier to define programmatically.
 *     chart_series_set_categories(series, "Sheet1", 1, 0, 6, 0); // "=Sheet1!$A$2:$A$7"
 *     chart_series_set_values(    series, "Sheet1", 1, 2, 6, 2); // "=Sheet1!$C$2:$C$7"
 * @endcode
 *
 * As shown in the previous example the return value from
 * `%chart_add_series()` is a lxw_chart_series pointer. This can be used in
 * other functions that configure a series.
 *
 *
 * More than one series can be added to a chart. The series numbering and
 * order in the Excel chart will be the same as the order in which they are
 * added in libxlsxwriter:
 *
 * @code
 *    chart_add_series(chart, NULL, "Sheet1!$A$1:$A$5");
 *    chart_add_series(chart, NULL, "Sheet1!$B$1:$B$5");
 *    chart_add_series(chart, NULL, "Sheet1!$C$1:$C$5");
 * @endcode
 *
 * It is also possible to specify non-contiguous ranges:
 *
 * @code
 *    chart_add_series(
 *        chart,
 *        "=(Sheet1!$A$1:$A$9,Sheet1!$A$14:$A$25)",
 *        "=(Sheet1!$B$1:$B$9,Sheet1!$B$14:$B$25)"
 *    );
 * @endcode
 *
 *)
function chart_add_series(chart: Plxw_chart; const categories: PUTF8Char; const values: PUTF8Char): Plxw_chart_series; cdecl;
  external bj name _PU + 'chart_add_series';

(**
 * @brief Set a series "categories" range using row and column values.
 *
 * @param series    A series object created via `chart_add_series()`.
 * @param sheetname The name of the worksheet that contains the data range.
 * @param first_row The first row of the range. (All zero indexed.)
 * @param first_col The first column of the range.
 * @param last_row  The last row of the range.
 * @param last_col  The last col of the range.
 *
 * The `categories` and `values` of a chart data series are generally set
 * using the `chart_add_series()` function and Excel range formulas like
 * `"=Sheet1!$A$2:$A$7"`.
 *
 * The `%chart_series_set_categories()` function is an alternative method that
 * is easier to generate programmatically. It requires that you set the
 * `categories` and `values` parameters in `chart_add_series()`to `NULL` and
 * then set them using row and column values in
 * `chart_series_set_categories()` and `chart_series_set_values()`:
 *
 * @code
 *     lxw_chart_series *series = chart_add_series(chart, NULL, NULL);
 *
 *     // Configure the series ranges programmatically.
 *     chart_series_set_categories(series, "Sheet1", 1, 0, 6, 0); // "=Sheet1!$A$2:$A$7"
 *     chart_series_set_values(    series, "Sheet1", 1, 2, 6, 2); // "=Sheet1!$C$2:$C$7"
 * @endcode
 *
 *)
procedure chart_series_set_categories(series: Plxw_chart_series; const sheetname: PUTF8Char; first_row: lxw_row_t; first_col: lxw_col_t; last_row: lxw_row_t; last_col: lxw_col_t); cdecl;
  external bj name _PU + 'chart_series_set_categories';

(**
 * @brief Set a series "values" range using row and column values.
 *
 * @param series    A series object created via `chart_add_series()`.
 * @param sheetname The name of the worksheet that contains the data range.
 * @param first_row The first row of the range. (All zero indexed.)
 * @param first_col The first column of the range.
 * @param last_row  The last row of the range.
 * @param last_col  The last col of the range.
 *
 * The `categories` and `values` of a chart data series are generally set
 * using the `chart_add_series()` function and Excel range formulas like
 * `"=Sheet1!$A$2:$A$7"`.
 *
 * The `%chart_series_set_values()` function is an alternative method that is
 * easier to generate programmatically. See the documentation for
 * `chart_series_set_categories()` above.
 *)
procedure chart_series_set_values(series: Plxw_chart_series; const sheetname: PUTF8Char; first_row: lxw_row_t; first_col: lxw_col_t; last_row: lxw_row_t; last_col: lxw_col_t); cdecl;
  external bj name _PU + 'chart_series_set_values';

(**
 * @brief Set the name of a chart series range.
 *
 * @param series A series object created via `chart_add_series()`.
 * @param name   The series name.
 *
 * The `%chart_series_set_name` function is used to set the name for a chart
 * data series. The series name in Excel is displayed in the chart legend and
 * in the formula bar. The name property is optional and if it isn't supplied
 * it will default to `Series 1..n`.
 *
 * The function applies to a #lxw_chart_series object created using
 * `chart_add_series()`:
 *
 * @code
 *     lxw_chart_series *series = chart_add_series(chart, NULL, "=Sheet1!$B$2:$B$7");
 *
 *     chart_series_set_name(series, "Quarterly budget data");
 * @endcode
 *
 * The name parameter can also be a formula such as `=Sheet1!$A$1` to point to
 * a cell in the workbook that contains the name:
 *
 * @code
 *     lxw_chart_series *series = chart_add_series(chart, NULL, "=Sheet1!$B$2:$B$7");
 *
 *     chart_series_set_name(series, "=Sheet1!$B$1");
 * @endcode
 *
 * See also the `chart_series_set_name_range()` function to see how to set the
 * name formula programmatically.
 *)
procedure chart_series_set_name(series: Plxw_chart_series; const name: PUTF8Char); cdecl;
  external bj name _PU + 'chart_series_set_name';

(**
 * @brief Set a series name formula using row and column values.
 *
 * @param series    A series object created via `chart_add_series()`.
 * @param sheetname The name of the worksheet that contains the cell range.
 * @param row       The zero indexed row number of the range.
 * @param col       The zero indexed column number of the range.
 *
 * The `%chart_series_set_name_range()` function can be used to set a series
 * name range and is an alternative to using `chart_series_set_name()` and a
 * string formula:
 *
 * @code
 *     lxw_chart_series *series = chart_add_series(chart, NULL, "=Sheet1!$B$2:$B$7");
 *
 *     chart_series_set_name_range(series, "Sheet1", 0, 2); // "=Sheet1!$C$1"
 * @endcode
 *)
procedure chart_series_set_name_range(series: Plxw_chart_series; const sheetname: PUTF8Char; row: lxw_row_t; col: lxw_col_t); cdecl;
  external bj name _PU + 'chart_series_set_name_range';

(**
 * @brief Set the line properties for a chart series.
 *
 * @param series A series object created via `chart_add_series()`.
 * @param line   A #lxw_chart_line struct.
 *
 * Set the line/border properties of a chart series:
 *
 * @code
 *     lxw_chart_line line = {.color = LXW_COLOR_RED};
 *
 *     chart_series_set_line(series1, &line);
 *     chart_series_set_line(series2, &line);
 *     chart_series_set_line(series3, &line);
 * @endcode
 *
 * @image html chart_series_set_line.png
 *
 * For more information see @ref chart_lines.
 *)
procedure chart_series_set_line(series: Plxw_chart_series; line: Plxw_chart_line); cdecl;
  external bj name _PU + 'chart_series_set_line';

(**
 * @brief Set the fill properties for a chart series.
 *
 * @param series A series object created via `chart_add_series()`.
 * @param fill   A #lxw_chart_fill struct.
 *
 * Set the fill properties of a chart series:
 *
 * @code
 *     lxw_chart_fill fill1 = {.color = LXW_COLOR_RED};
 *     lxw_chart_fill fill2 = {.color = LXW_COLOR_YELLOW};
 *     lxw_chart_fill fill3 = {.color = LXW_COLOR_GREEN};
 *
 *     chart_series_set_fill(series1, &fill1);
 *     chart_series_set_fill(series2, &fill2);
 *     chart_series_set_fill(series3, &fill3);
 * @endcode
 *
 * @image html chart_series_set_fill.png
 *
 * For more information see @ref chart_fills.
 *)
procedure chart_series_set_fill(series: Plxw_chart_series; fill: Plxw_chart_fill); cdecl;
  external bj name _PU + 'chart_series_set_fill';

(**
 * @brief Invert the fill color for negative series values.
 *
 * @param series  A series object created via `chart_add_series()`.
 *
 * Invert the fill color for negative values. Usually only applicable to
 * column and bar charts.
 *
 * @code
 *     chart_series_set_invert_if_negative(series);
 * @endcode
 *
 *)
procedure chart_series_set_invert_if_negative(series: Plxw_chart_series); cdecl;
  external bj name _PU + 'chart_series_set_invert_if_negative';

(**
 * @brief Set the pattern properties for a chart series.
 *
 * @param series  A series object created via `chart_add_series()`.
 * @param pattern A #lxw_chart_pattern struct.
 *
 * Set the pattern properties of a chart series:
 *
 * @code
 *     lxw_chart_pattern pattern1 = {.type = LXW_CHART_PATTERN_SHINGLE,
 *                                   .fg_color = 0x804000,
 *                                   .bg_color = 0XC68C53};
 *
 *     lxw_chart_pattern pattern2 = {.type = LXW_CHART_PATTERN_HORIZONTAL_BRICK,
 *                                   .fg_color = 0XB30000,
 *                                   .bg_color = 0XFF6666};
 *
 *     chart_series_set_pattern(series1, &pattern1);
 *     chart_series_set_pattern(series2, &pattern2);
 *
 * @endcode
 *
 * @image html chart_pattern.png
 *
 * For more information see #lxw_chart_pattern_type and @ref chart_patterns.
 *)
procedure chart_series_set_pattern(series: Plxw_chart_series; pattern: Plxw_chart_pattern); cdecl;
  external bj name _PU + 'chart_series_set_pattern';

(**
 * @brief Set the data marker type for a series.
 *
 * @param series A series object created via `chart_add_series()`.
 * @param type   The marker type, see #lxw_chart_marker_type.
 *
 * In Excel a chart marker is used to distinguish data points in a plotted
 * series. In general only Line and Scatter and Radar chart types use
 * markers. The libxlsxwriter chart types that can have markers are:
 *
 * - #LXW_CHART_LINE
 * - #LXW_CHART_SCATTER
 * - #LXW_CHART_SCATTER_STRAIGHT
 * - #LXW_CHART_SCATTER_STRAIGHT_WITH_MARKERS
 * - #LXW_CHART_SCATTER_SMOOTH
 * - #LXW_CHART_SCATTER_SMOOTH_WITH_MARKERS
 * - #LXW_CHART_RADAR
 * - #LXW_CHART_RADAR_WITH_MARKERS
 *
 * The chart types with `MARKERS` in the name have markers with default colors
 * and shapes turned on by default but it is possible using the various
 * `chart_series_set_marker_xxx()` functions below to change these defaults. It
 * is also possible to turn on an off markers.
 *
 * The `%chart_series_set_marker_type()` function is used to specify the
 * type of the series marker:
 *
 * @code
 *     chart_series_set_marker_type(series, LXW_CHART_MARKER_DIAMOND);
 * @endcode
 *
 * @image html chart_marker1.png
 *
 * The available marker types defined by #lxw_chart_marker_type are:
 *
 * - #LXW_CHART_MARKER_AUTOMATIC
 * - #LXW_CHART_MARKER_NONE
 * - #LXW_CHART_MARKER_SQUARE
 * - #LXW_CHART_MARKER_DIAMOND
 * - #LXW_CHART_MARKER_TRIANGLE
 * - #LXW_CHART_MARKER_X
 * - #LXW_CHART_MARKER_STAR
 * - #LXW_CHART_MARKER_SHORT_DASH
 * - #LXW_CHART_MARKER_LONG_DASH
 * - #LXW_CHART_MARKER_CIRCLE
 * - #LXW_CHART_MARKER_PLUS
 *
 * The `#LXW_CHART_MARKER_NONE` type can be used to turn off default markers:
 *
 * @code
 *     chart_series_set_marker_type(series, LXW_CHART_MARKER_NONE);
 * @endcode
 *
 * @image html chart_series_set_marker_none.png
 *
 * The `#LXW_CHART_MARKER_AUTOMATIC` type is a special case which turns on a
 * marker using the default marker style for the particular series. If
 * automatic is on then other marker properties such as size, line or fill
 * cannot be set.
 *)
procedure chart_series_set_marker_type(series: Plxw_chart_series; atype: UInt8); cdecl;
  external bj name _PU + 'chart_series_set_marker_type';

(**
 * @brief Set the size of a data marker for a series.
 *
 * @param series A series object created via `chart_add_series()`.
 * @param size   The size of the marker.
 *
 * The `%chart_series_set_marker_size()` function is used to specify the
 * size of the series marker:
 *
 * @code
 *     chart_series_set_marker_type(series, LXW_CHART_MARKER_CIRCLE);
 *     chart_series_set_marker_size(series, 10);
 * @endcode
 *
 * @image html chart_series_set_marker_size.png
 *
 *)
procedure chart_series_set_marker_size(series: Plxw_chart_series; size: UInt8); cdecl;
  external bj name _PU + 'chart_series_set_marker_size';

(**
 * @brief Set the line properties for a chart series marker.
 *
 * @param series A series object created via `chart_add_series()`.
 * @param line   A #lxw_chart_line struct.
 *
 * Set the line/border properties of a chart marker:
 *
 * @code
 *     lxw_chart_line line = {.color = LXW_COLOR_BLACK};
 *     lxw_chart_fill fill = {.color = LXW_COLOR_RED};
 *
 *     chart_series_set_marker_type(series, LXW_CHART_MARKER_SQUARE);
 *     chart_series_set_marker_size(series, 8);
 *
 *     chart_series_set_marker_line(series, &line);
 *     chart_series_set_marker_fill(series, &fill);
 * @endcode
 *
 * @image html chart_marker2.png
 *
 * For more information see @ref chart_lines.
 *)
procedure chart_series_set_marker_line(series: Plxw_chart_series; line: Plxw_chart_line); cdecl;
  external bj name _PU + 'chart_series_set_marker_line';

(**
 * @brief Set the fill properties for a chart series marker.
 *
 * @param series A series object created via `chart_add_series()`.
 * @param fill   A #lxw_chart_fill struct.
 *
 * Set the fill properties of a chart marker:
 *
 * @code
 *     chart_series_set_marker_fill(series, &fill);
 * @endcode
 *
 * See the example and image above and also see @ref chart_fills.
 *)
procedure chart_series_set_marker_fill(series: Plxw_chart_series; fill: Plxw_chart_fill); cdecl;
  external bj name _PU + 'chart_series_set_marker_fill';

(**
 * @brief Set the pattern properties for a chart series marker.
 *
 * @param series  A series object created via `chart_add_series()`.
 * @param pattern A #lxw_chart_pattern struct.
 *
 * Set the pattern properties of a chart marker:
 *
 * @code
 *     chart_series_set_marker_pattern(series, &pattern);
 * @endcode
 *
 * For more information see #lxw_chart_pattern_type and @ref chart_patterns.
 *)
procedure chart_series_set_marker_pattern(series: Plxw_chart_series; pattern: Plxw_chart_pattern); cdecl;
  external bj name _PU + 'chart_series_set_marker_pattern';

(**
 * @brief Set the formatting for points in the series.
 *
 * @param series A series object created via `chart_add_series()`.
 * @param points An NULL terminated array of #lxw_chart_point pointers.
 *
 * @return A #lxw_error.
 *
 * In general formatting is applied to an entire series in a chart. However,
 * it is occasionally required to format individual points in a series. In
 * particular this is required for Pie/Doughnut charts where each segment is
 * represented by a point.
 *
 * @dontinclude chart_pie_colors.c
 * @skip Add the data series
 * @until chart_series_set_points
 *
 * @image html chart_points1.png
 *
 * @note The array of #lxw_chart_point pointers should be NULL terminated
 * as shown in the example.
 *
 * For more details see @ref chart_points
 *)
//function chart_series_set_points(series: Plxw_chart_series; points: PPlxw_chart_point): lxw_error; cdecl;
type
PPlxw_chart_point = ^Plxw_chart_point;
function chart_series_set_points(series: Plxw_chart_series; points: PPlxw_chart_point): lxw_error; cdecl;
  external bj name _PU + 'chart_series_set_points';

(**
 * @brief Smooth a line or scatter chart series.
 *
 * @param series A series object created via `chart_add_series()`.
 * @param smooth Turn off/on the line smoothing. (0/1)
 *
 * The `chart_series_set_smooth()` function is used to set the smooth property
 * of a line series. It is only applicable to the line and scatter chart
 * types:
 *
 * @code
 *     chart_series_set_smooth(series2, LXW_TRUE);
 * @endcode
 *
 * @image html chart_smooth.png
 *
 *
 *)
procedure chart_series_set_smooth(series: Plxw_chart_series; smooth: UInt8); cdecl;
  external bj name _PU + 'chart_series_set_smooth';

(**
 * @brief Add data labels to a chart series.
 *
 * @param series A series object created via `chart_add_series()`.
 *
 * The `%chart_series_set_labels()` function is used to turn on data labels
 * for a chart series. Data labels indicate the values of the plotted data
 * points.
 *
 * @code
 *     chart_series_set_labels(series);
 * @endcode
 *
 * @image html chart_data_labels1.png
 *
 * By default data labels are displayed in Excel with only the values shown:
 *
 * @image html chart_data_labels2.png
 *
 * However, it is possible to configure other display options, as shown
 * in the functions below.
 *
 * For more information see @ref chart_labels.
 *)
procedure chart_series_set_labels(series: Plxw_chart_series); cdecl;
  external bj name _PU + 'chart_series_set_labels';

(**
 * @brief Set the display options for the labels of a data series.
 *
 * @param series        A series object created via `chart_add_series()`.
 * @param show_name     Turn on/off the series name in the label caption.
 * @param show_category Turn on/off the category name in the label caption.
 * @param show_value    Turn on/off the value in the label caption.
 *
 * The `%chart_series_set_labels_options()` function is used to set the
 * parameters that are displayed in the series data label:
 *
 * @code
 *     chart_series_set_labels(series);
 *     chart_series_set_labels_options(series, LXW_TRUE, LXW_TRUE, LXW_TRUE);
 * @endcode
 *
 * @image html chart_data_labels3.png
 *
 * For more information see @ref chart_labels.
 *)
procedure chart_series_set_labels_options(series: Plxw_chart_series; show_name: UInt8; show_category: UInt8; show_value: UInt8); cdecl;
  external bj name _PU + 'chart_series_set_labels_options';

(** @brief Set the properties for data labels in a series.
 *
 * @param series      A series object created via `chart_add_series()`.
 * @param data_labels An NULL terminated array of #lxw_chart_data_label pointers.
 *
 * @return A #lxw_error.
 *
 * The `%chart_series_set_labels_custom()` function is used to set the properties
 * for data labels in a series. It can also be used to delete individual data
 * labels in a series.
 *
 * In general properties are set for all the data labels in a chart
 * series. However, it is also possible to set properties for individual data
 * labels in a series using `%chart_series_set_labels_custom()`.
 *
 * The `%chart_series_set_labels_custom()` function takes a pointer to an array
 * of #lxw_chart_data_label pointers. The list should be `NULL` terminated:
 *
 * @code
 *     // Add the series data labels.
 *     chart_series_set_labels(series);
 *
 *     // Create some custom labels.
 *     lxw_chart_data_label data_label1 = {.value = "Jan"};
 *     lxw_chart_data_label data_label2 = {.value = "Feb"};
 *     lxw_chart_data_label data_label3 = {.value = "Mar"};
 *     lxw_chart_data_label data_label4 = {.value = "Apr"};
 *     lxw_chart_data_label data_label5 = {.value = "May"};
 *     lxw_chart_data_label data_label6 = {.value = "Jun"};
 *
 *     // Create an array of label pointers. NULL indicates the end of the array.
 *     lxw_chart_data_label *data_labels[] = {
 *         &data_label1,
 *         &data_label2,
 *         &data_label3,
 *         &data_label4,
 *         &data_label5,
 *         &data_label6,
 *         NULL
 *     };
 *
 *     // Set the custom labels.
 *     chart_series_set_labels_custom(series, data_labels);
 * @endcode
 *
 * @image html chart_data_labels18.png
 *
 * @note The array of #lxw_chart_point pointers should be NULL terminated as
 * shown in the example. Any #lxw_chart_data_label items set to a default
 * initialization or omitted from the list will be assigned the default data
 * label value.
 *
 * For more details see @ref chart_custom_labels.
 *)
type
  PPlxw_chart_data_label = ^Plxw_chart_data_label;
function chart_series_set_labels_custom(series: Plxw_chart_series; data_labels: PPlxw_chart_data_label): lxw_error; cdecl;
  external bj name _PU + 'chart_series_set_labels_custom';

(**
 * @brief Set the separator for the data label captions.
 *
 * @param series    A series object created via `chart_add_series()`.
 * @param separator The separator for the data label options:
 *                  #lxw_chart_label_separator.
 *
 * The `%chart_series_set_labels_separator()` function is used to change the
 * separator between multiple data label items. The default options is a comma
 * separator as shown in the previous example.
 *
 * The available options are:
 *
 * - #LXW_CHART_LABEL_SEPARATOR_SEMICOLON: semicolon separator.
 * - #LXW_CHART_LABEL_SEPARATOR_PERIOD: a period (dot) separator.
 * - #LXW_CHART_LABEL_SEPARATOR_NEWLINE: a newline separator.
 * - #LXW_CHART_LABEL_SEPARATOR_SPACE: a space separator.
 *
 * For example:
 *
 * @code
 *     chart_series_set_labels(series);
 *     chart_series_set_labels_options(series, LXW_TRUE, LXW_TRUE, LXW_TRUE);
 *     chart_series_set_labels_separator(series, LXW_CHART_LABEL_SEPARATOR_NEWLINE);
 * @endcode
 *
 * @image html chart_data_labels4.png
 *
 * For more information see @ref chart_labels.
 *)
procedure chart_series_set_labels_separator(series: Plxw_chart_series; separator: UInt8); cdecl;
  external bj name _PU + 'chart_series_set_labels_separator';

(**
 * @brief Set the data label position for a series.
 *
 * @param series   A series object created via `chart_add_series()`.
 * @param position The data label position: #lxw_chart_label_position.
 *
 * The `%chart_series_set_labels_position()` function sets the position of
 * the labels in the data series:
 *
 * @code
 *     chart_series_set_labels(series);
 *     chart_series_set_labels_position(series, LXW_CHART_LABEL_POSITION_ABOVE);
 * @endcode
 *
 * @image html chart_data_labels5.png
 *
 * In Excel the allowable data label positions vary for different chart
 * types. The allowable, and default, positions are:
 *
 * | Position                              | Line, Scatter | Bar, Column   | Pie, Doughnut | Area, Radar   |
 * | :------------------------------------ | :------------ | :------------ | :------------ | :------------ |
 * | #LXW_CHART_LABEL_POSITION_CENTER      | Yes           | Yes           | Yes           | Yes (default) |
 * | #LXW_CHART_LABEL_POSITION_RIGHT       | Yes (default) |               |               |               |
 * | #LXW_CHART_LABEL_POSITION_LEFT        | Yes           |               |               |               |
 * | #LXW_CHART_LABEL_POSITION_ABOVE       | Yes           |               |               |               |
 * | #LXW_CHART_LABEL_POSITION_BELOW       | Yes           |               |               |               |
 * | #LXW_CHART_LABEL_POSITION_INSIDE_BASE |               | Yes           |               |               |
 * | #LXW_CHART_LABEL_POSITION_INSIDE_END  |               | Yes           | Yes           |               |
 * | #LXW_CHART_LABEL_POSITION_OUTSIDE_END |               | Yes (default) | Yes           |               |
 * | #LXW_CHART_LABEL_POSITION_BEST_FIT    |               |               | Yes (default) |               |
 *
 *
 * For more information see @ref chart_labels.
 *)
procedure chart_series_set_labels_position(series: Plxw_chart_series; position: UInt8); cdecl;
  external bj name _PU + 'chart_series_set_labels_position';

(**
 * @brief Set leader lines for Pie and Doughnut charts.
 *
 * @param series A series object created via `chart_add_series()`.
 *
 * The `%chart_series_set_labels_leader_line()` function  is used to turn on
 * leader lines for the data label of a series. It is mainly used for pie
 * or doughnut charts:
 *
 * @code
 *     chart_series_set_labels(series);
 *     chart_series_set_labels_leader_line(series);
 * @endcode
 *
 * @note Even when leader lines are turned on they aren't automatically
 *       visible in Excel or XlsxWriter. Due to an Excel limitation
 *       (or design) leader lines only appear if the data label is moved
 *       manually or if the data labels are very close and need to be
 *       adjusted automatically.
 *
 * For more information see @ref chart_labels.
 *)
procedure chart_series_set_labels_leader_line(series: Plxw_chart_series); cdecl;
  external bj name _PU + 'chart_series_set_labels_leader_line';

(**
 * @brief Set the legend key for a data label in a chart series.
 *
 * @param series A series object created via `chart_add_series()`.
 *
 * The `%chart_series_set_labels_legend()` function is used to set the
 * legend key for a data series:
 *
 * @code
 *     chart_series_set_labels(series);
 *     chart_series_set_labels_legend(series);
 * @endcode
 *
 * @image html chart_data_labels6.png
 *
 * For more information see @ref chart_labels.
 *)
procedure chart_series_set_labels_legend(series: Plxw_chart_series); cdecl;
  external bj name _PU + 'chart_series_set_labels_legend';

(**
 * @brief Set the percentage for a Pie/Doughnut data point.
 *
 * @param series A series object created via `chart_add_series()`.
 *
 * The `%chart_series_set_labels_percentage()` function is used to turn on
 * the display of data labels as a percentage for a series. It is mainly
 * used for pie charts:
 *
 * @code
 *     chart_series_set_labels(series);
 *     chart_series_set_labels_options(series, LXW_FALSE, LXW_FALSE, LXW_FALSE);
 *     chart_series_set_labels_percentage(series);
 * @endcode
 *
 * @image html chart_data_labels7.png
 *
 * For more information see @ref chart_labels.
 *)
procedure chart_series_set_labels_percentage(series: Plxw_chart_series); cdecl;
  external bj name _PU + 'chart_series_set_labels_percentage';

(**
 * @brief Set the number format for chart data labels in a series.
 *
 * @param series     A series object created via `chart_add_series()`.
 * @param num_format The number format string.
 *
 * The `%chart_series_set_labels_num_format()` function is used to set the
 * number format for data labels:
 *
 * @code
 *     chart_series_set_labels(series);
 *     chart_series_set_labels_num_format(series, "$0.00");
 * @endcode
 *
 * @image html chart_data_labels8.png
 *
 * The number format is similar to the Worksheet Cell Format num_format,
 * see `format_set_num_format()`.
 *
 * For more information see @ref chart_labels.
 *)
procedure chart_series_set_labels_num_format(series: Plxw_chart_series; const num_format: PUTF8Char); cdecl;
  external bj name _PU + 'chart_series_set_labels_num_format';

(**
 * @brief Set the font properties for chart data labels in a series
 *
 * @param series A series object created via `chart_add_series()`.
 * @param font   A pointer to a chart #lxw_chart_font font struct.
 *
 *
 * The `%chart_series_set_labels_font()` function is used to set the font
 * for data labels:
 *
 * @code
 *     lxw_chart_font font = {.name = "Consolas", .color = LXW_COLOR_RED};
 *
 *     chart_series_set_labels(series);
 *     chart_series_set_labels_font(series, &font);
 * @endcode
 *
 * @image html chart_data_labels9.png
 *
 * For more information see @ref chart_fonts and @ref chart_labels.
 *
 *)
procedure chart_series_set_labels_font(series: Plxw_chart_series; font: Plxw_chart_font); cdecl;
  external bj name _PU + 'chart_series_set_labels_font';

(**
 * @brief Set the line properties for the data labels in a chart series.
 *
 * @param series A series object created via `chart_add_series()`.
 * @param line   A #lxw_chart_line struct.
 *
 * Set the line/border properties of the data labels in a chart series:
 *
 * @code
 *     lxw_chart_line line = {.color = LXW_COLOR_RED};
 *     lxw_chart_fill fill = {.color = LXW_COLOR_YELLOW};
 *
 *     chart_series_set_labels_line(series, &line);
 *     chart_series_set_labels_fill(series, &fill);
 *
 * @endcode
 *
 * @image html chart_data_labels24.png
 *
 * For more information see @ref chart_lines and @ref chart_labels.
 *)
procedure chart_series_set_labels_line(series: Plxw_chart_series; line: Plxw_chart_line); cdecl;
  external bj name _PU + 'chart_series_set_labels_line';

(**
 * @brief Set the fill properties for the data labels in a chart series.
 *
 * @param series A series object created via `chart_add_series()`.
 * @param fill   A #lxw_chart_fill struct.
 *
 * Set the fill properties of the data labels in a chart series:
 *
 * @code
 *     lxw_chart_fill fill = {.color = LXW_COLOR_YELLOW};
 *
 *     chart_series_set_labels_fill(series, &fill);
 * @endcode
 *
 * See the example and image above and also see @ref chart_fills and
 * @ref chart_labels.
 *)
procedure chart_series_set_labels_fill(series: Plxw_chart_series; fill: Plxw_chart_fill); cdecl;
  external bj name _PU + 'chart_series_set_labels_fill';

(**
 * @brief Set the pattern properties for the data labels in a chart series.
 *
 * @param series  A series object created via `chart_add_series()`.
 * @param pattern A #lxw_chart_pattern struct.
 *
 * Set the pattern properties of the data labels in a chart series:
 *
 * @code
 *     chart_series_set_labels_pattern(series, &pattern);
 * @endcode
 *
 * For more information see #lxw_chart_pattern_type and @ref chart_patterns.
 *)
procedure chart_series_set_labels_pattern(series: Plxw_chart_series; pattern: Plxw_chart_pattern); cdecl;
  external bj name _PU + 'chart_series_set_labels_pattern';

(**
 * @brief Turn on a trendline for a chart data series.
 *
 * @param series A series object created via `chart_add_series()`.
 * @param type   The type of trendline: #lxw_chart_trendline_type.
 * @param value  The order/period value for polynomial and moving average
 *               trendlines.
 *
 * A trendline can be added to a chart series to indicate trends in the data
 * such as a moving average or a polynomial fit. The trendlines types are
 * shown in the following Excel dialog:
 *
 * @image html chart_trendline0.png
 *
 * The `%chart_series_set_trendline()` function turns on these trendlines for
 * a data series:
 *
 * @code
 *     chart = workbook_add_chart(workbook, LXW_CHART_LINE);
 *     series = chart_add_series(chart, NULL, "Sheet1!$A$1:$A$6");
 *
 *     chart_series_set_trendline(series, LXW_CHART_TRENDLINE_TYPE_LINEAR, 0);
 * @endcode
 *
 * @image html chart_trendline2.png
 *
 * The `value` parameter corresponds to *order* for a polynomial trendline
 * and *period* for a Moving Average trendline. It both cases it must be >= 2.
 * The `value` parameter  is ignored for all other trendlines:
 *
 * @code
 *     chart_series_set_trendline(series, LXW_CHART_TRENDLINE_TYPE_AVERAGE, 2);
 * @endcode
 *
 * @image html chart_trendline3.png
 *
 * The allowable values for the the trendline `type` are:
 *
 * - #LXW_CHART_TRENDLINE_TYPE_LINEAR: Linear trendline.
 * - #LXW_CHART_TRENDLINE_TYPE_LOG: Logarithm trendline.
 * - #LXW_CHART_TRENDLINE_TYPE_POLY: Polynomial trendline. The `value`
 *   parameter corresponds to *order*.
 * - #LXW_CHART_TRENDLINE_TYPE_POWER: Power trendline.
 * - #LXW_CHART_TRENDLINE_TYPE_EXP: Exponential trendline.
 * - #LXW_CHART_TRENDLINE_TYPE_AVERAGE: Moving Average trendline. The `value`
 *   parameter corresponds to *period*.
 *
 * Other trendline options, such as those shown in the following Excel
 * dialog, can be set using the functions below.
 *
 * @image html chart_trendline1.png
 *
 * For more information see @ref chart_trendlines.
 *)
procedure chart_series_set_trendline(series: Plxw_chart_series; atype: UInt8; value: UInt8); cdecl;
  external bj name _PU + 'chart_series_set_trendline';

(**
 * @brief Set the trendline forecast for a chart data series.
 *
 * @param series   A series object created via `chart_add_series()`.
 * @param forward  The forward period.
 * @param backward The backwards period.
 *
 * The `%chart_series_set_trendline_forecast()` function sets the forward
 * and backward forecast periods for the trendline:
 *
 * @code
 *     chart_series_set_trendline(series, LXW_CHART_TRENDLINE_TYPE_LINEAR, 0);
 *     chart_series_set_trendline_forecast(series, 0.5, 0.5);
 * @endcode
 *
 * @image html chart_trendline4.png
 *
 * @note This feature isn't available for Moving Average in Excel.
 *
 * For more information see @ref chart_trendlines.
 *)
procedure chart_series_set_trendline_forecast(series: Plxw_chart_series; aforward: Double; backward: Double); cdecl;
  external bj name _PU + 'chart_series_set_trendline_forecast';

(**
 * @brief Display the equation of a trendline for a chart data series.
 *
 * @param series A series object created via `chart_add_series()`.
 *
 * The `%chart_series_set_trendline_equation()` function displays the
 * equation of the trendline on the chart:
 *
 * @code
 *     chart_series_set_trendline(series, LXW_CHART_TRENDLINE_TYPE_LINEAR, 0);
 *     chart_series_set_trendline_equation(series);
 * @endcode
 *
 * @image html chart_trendline5.png
 *
 * @note This feature isn't available for Moving Average in Excel.
 *
 * For more information see @ref chart_trendlines.
 *)
procedure chart_series_set_trendline_equation(series: Plxw_chart_series); cdecl;
  external bj name _PU + 'chart_series_set_trendline_equation';

(**
 * @brief Display the R squared value of a trendline for a chart data series.
 *
 * @param series A series object created via `chart_add_series()`.
 *
 * The `%chart_series_set_trendline_r_squared()` function displays the
 * R-squared value for the trendline on the chart:
 *
 * @code
 *     chart_series_set_trendline(series, LXW_CHART_TRENDLINE_TYPE_LINEAR, 0);
 *     chart_series_set_trendline_r_squared(series);
 * @endcode
 *
 * @image html chart_trendline6.png
 *
 * @note This feature isn't available for Moving Average in Excel.
 *
 * For more information see @ref chart_trendlines.
 *)
procedure chart_series_set_trendline_r_squared(series: Plxw_chart_series); cdecl;
  external bj name _PU + 'chart_series_set_trendline_r_squared';

(**
 * @brief Set the trendline Y-axis intercept for a chart data series.
 *
 * @param series    A series object created via `chart_add_series()`.
 * @param intercept Y-axis intercept value.
 *
 * The `%chart_series_set_trendline_intercept()` function sets the Y-axis
 * intercept for the trendline:
 *
 * @code
 *     chart_series_set_trendline(series, LXW_CHART_TRENDLINE_TYPE_LINEAR, 0);
 *     chart_series_set_trendline_equation(series);
 *     chart_series_set_trendline_intercept(series, 0.8);
 * @endcode
 *
 * @image html chart_trendline7.png
 *
 * As can be seen from the equation on the chart the intercept point
 * (when X=0) is the same as the value set in the equation.
 *
 * @note The intercept feature is only available in Excel for Exponential,
 *       Linear and Polynomial trendline types.
 *
 * For more information see @ref chart_trendlines.
 *)
procedure chart_series_set_trendline_intercept(series: Plxw_chart_series; intercept: Double); cdecl;
  external bj name _PU + 'chart_series_set_trendline_intercept';

(**
 * @brief Set the trendline name for a chart data series.
 *
 * @param series A series object created via `chart_add_series()`.
 * @param name   The name of the trendline to display in the legend.
 *
 * The `%chart_series_set_trendline_name()` function sets the name of the
 * trendline that is displayed in the chart legend. In the examples above
 * the trendlines are displayed with default names like "Linear (Series 1)"
 * and "2 per Mov. Avg. (Series 1)". If these names are too verbose or not
 * descriptive enough you can set your own trendline name:
 *
 * @code
 *     chart_series_set_trendline(series, LXW_CHART_TRENDLINE_TYPE_LINEAR, 0);
 *     chart_series_set_trendline_name(series, "My trendline");
 * @endcode
 *
 * @image html chart_trendline8.png
 *
 * It is often preferable to turn off the trendline caption in the legend.
 * This is down in Excel by deleting the trendline name from the legend.
 * In libxlsxwriter this is done using the `chart_legend_delete_series()`
 * function to delete the zero based series numbers:
 *
 * @code
 *     chart_series_set_trendline(series, LXW_CHART_TRENDLINE_TYPE_LINEAR, 0);
 *
 *     // Delete the series name for the second series (=1 in zero base).
 *     // The -1 value indicates the end of the array of values.
 *     int16_t names[] = {1, -1};
 *     chart_legend_delete_series(chart, names);
 * @endcode
 *
 * @image html chart_trendline9.png
 *
 * For more information see @ref chart_trendlines.
 *)
procedure chart_series_set_trendline_name(series: Plxw_chart_series; const name: PUTF8Char); cdecl;
  external bj name _PU + 'chart_series_set_trendline_name';

(**
 * @brief Set the trendline line properties for a chart data series.
 *
 * @param series A series object created via `chart_add_series()`.
 * @param line   A #lxw_chart_line struct.
 *
 * The `%chart_series_set_trendline_line()` function is used to set the line
 * properties of a trendline:
 *
 * @code
 *     lxw_chart_line line = {.color     = LXW_COLOR_RED,
 *                            .dash_type = LXW_CHART_LINE_DASH_LONG_DASH};
 *
 *     chart_series_set_trendline(series, LXW_CHART_TRENDLINE_TYPE_LINEAR, 0);
 *     chart_series_set_trendline_line(series, &line);
 * @endcode
 *
 * @image html chart_trendline10.png
 *
 * For more information see @ref chart_trendlines and @ref chart_lines.
 *)
procedure chart_series_set_trendline_line(series: Plxw_chart_series; line: Plxw_chart_line); cdecl;
  external bj name _PU + 'chart_series_set_trendline_line';

(**
 * @brief           Get a pointer to X or Y error bars from a chart series.
 *
 * @param series    A series object created via `chart_add_series()`.
 * @param axis_type The axis type (X or Y): #lxw_chart_error_bar_axis.
 *
 * The `%chart_series_get_error_bars()` function returns a pointer to the
 * error bars of a series based on the type of #lxw_chart_error_bar_axis:
 *
 * @code
 *     lxw_series_error_bars *x_error_bars;
 *     lxw_series_error_bars *y_error_bars;
 *
 *     x_error_bars = chart_series_get_error_bars(series, LXW_CHART_ERROR_BAR_AXIS_X);
 *     y_error_bars = chart_series_get_error_bars(series, LXW_CHART_ERROR_BAR_AXIS_Y);
 *
 *     // Use the error bar pointers.
 *     chart_series_set_error_bars(x_error_bars,
 *                                 LXW_CHART_ERROR_BAR_TYPE_STD_DEV, 1);
 *
 *     chart_series_set_error_bars(y_error_bars,
 *                                 LXW_CHART_ERROR_BAR_TYPE_STD_ERROR, 0);
 * @endcode
 *
 * Note, the series error bars can also be accessed directly:
 *
 * @code
 *     // Equivalent to the above example, without function calls.
 *     chart_series_set_error_bars(series->x_error_bars,
 *                                 LXW_CHART_ERROR_BAR_TYPE_STD_DEV, 1);
 *
 *     chart_series_set_error_bars(series->y_error_bars,
 *                                 LXW_CHART_ERROR_BAR_TYPE_STD_ERROR, 0);
 * @endcode
 *
 * @return Pointer to the series error bars, or NULL if not found.
 *)
function chart_series_get_error_bars(series: Plxw_chart_series; axis_type: lxw_chart_error_bar_axis): Plxw_series_error_bars; cdecl;
  external bj name _PU + 'chart_series_get_error_bars';

(**
 * Set the X or Y error bars for a chart series.
 *
 * @param error_bars A pointer to the series X or Y error bars.
 * @param type       The type of error bar: #lxw_chart_error_bar_type.
 * @param value      The error value.
 *
 * Error bars can be added to a chart series to indicate error bounds in the
 * data. The error bars can be vertical `y_error_bars` (the most common type)
 * or horizontal `x_error_bars` (for Bar and Scatter charts only).
 *
 * @image html chart_error_bars0.png
 *
 * The `%chart_series_set_error_bars()` function sets the error bar type
 * and value associated with the type:
 *
 * @code
 *     lxw_chart_series *series = chart_add_series(chart,
 *                                                 "=Sheet1!$A$1:$A$5",
 *                                                 "=Sheet1!$B$1:$B$5");
 *
 *     chart_series_set_error_bars(series->y_error_bars,
 *                                 LXW_CHART_ERROR_BAR_TYPE_STD_ERROR, 0);
 * @endcode
 *
 * @image html chart_error_bars1.png
 *
 * The error bar types that be used are:
 *
 * - #LXW_CHART_ERROR_BAR_TYPE_STD_ERROR: Standard error.
 * - #LXW_CHART_ERROR_BAR_TYPE_FIXED: Fixed value.
 * - #LXW_CHART_ERROR_BAR_TYPE_PERCENTAGE: Percentage.
 * - #LXW_CHART_ERROR_BAR_TYPE_STD_DEV: Standard deviation(s).
 *
 * @note Custom error bars are not currently supported.
 *
 * All error bar types, apart from Standard error, should have a valid
 * value to set the error range:
 *
 * @code
 *     chart_series_set_error_bars(series1->y_error_bars,
 *                                 LXW_CHART_ERROR_BAR_TYPE_FIXED, 2);
 *
 *     chart_series_set_error_bars(series2->y_error_bars,
 *                                 LXW_CHART_ERROR_BAR_TYPE_PERCENTAGE, 5);
 *
 *     chart_series_set_error_bars(series3->y_error_bars,
 *                                 LXW_CHART_ERROR_BAR_TYPE_STD_DEV, 1);
 * @endcode
 *
 * For the Standard error type the value is ignored.
 *
 * For more information see @ref chart_error_bars.
 *)
procedure chart_series_set_error_bars(error_bars: Plxw_series_error_bars; atype: UInt8; value: Double); cdecl;
  external bj name _PU + 'chart_series_set_error_bars';

(**
 * @brief Set the direction (up, down or both) of the error bars for a chart
 *        series.
 *
 * @param error_bars A pointer to the series X or Y error bars.
 * @param direction  The bar direction: #lxw_chart_error_bar_direction.
 *
 * The `%chart_series_set_error_bars_direction()` function sets the
 * direction of the error bars:
 *
 * @code
 *     chart_series_set_error_bars(series->y_error_bars,
 *                                 LXW_CHART_ERROR_BAR_TYPE_STD_ERROR, 0);
 *
 *     chart_series_set_error_bars_direction(series->y_error_bars,
 *                                           LXW_CHART_ERROR_BAR_DIR_PLUS);
 * @endcode
 *
 * @image html chart_error_bars2.png
 *
 * The valid directions are:
 *
 * - #LXW_CHART_ERROR_BAR_DIR_BOTH: Error bar extends in both directions.
 *   The default.
 * - #LXW_CHART_ERROR_BAR_DIR_PLUS: Error bar extends in positive direction.
 * - #LXW_CHART_ERROR_BAR_DIR_MINUS: Error bar extends in negative direction.
 *
 * For more information see @ref chart_error_bars.
 *)
procedure chart_series_set_error_bars_direction(error_bars: Plxw_series_error_bars; direction: UInt8); cdecl;
  external bj name _PU + 'chart_series_set_error_bars_direction';

(**
 * @brief Set the end cap type for the error bars of a chart series.
 *
 * @param error_bars A pointer to the series X or Y error bars.
 * @param endcap     The error bar end cap type: #lxw_chart_error_bar_cap .
 *
 * The `%chart_series_set_error_bars_endcap()` function sets the end cap
 * type for the error bars:
 *
 * @code
 *     chart_series_set_error_bars(series->y_error_bars,
 *                                 LXW_CHART_ERROR_BAR_TYPE_STD_ERROR, 0);
 *
 *     chart_series_set_error_bars_endcap(series->y_error_bars,
                                          LXW_CHART_ERROR_BAR_NO_CAP);
 * @endcode
 *
 * @image html chart_error_bars3.png
 *
 * The valid values are:
 *
 * - #LXW_CHART_ERROR_BAR_END_CAP: Flat end cap. The default.
 * - #LXW_CHART_ERROR_BAR_NO_CAP: No end cap.
 *
 * For more information see @ref chart_error_bars.
 *)
procedure chart_series_set_error_bars_endcap(error_bars: Plxw_series_error_bars; endcap: UInt8); cdecl;
  external bj name _PU + 'chart_series_set_error_bars_endcap';

(**
 * @brief Set the line properties for a chart series error bars.
 *
 * @param error_bars A pointer to the series X or Y error bars.
 * @param line       A #lxw_chart_line struct.
 *
 * The `%chart_series_set_error_bars_line()` function sets the line
 * properties for the error bars:
 *
 * @code
 *     lxw_chart_line line = {.color     = LXW_COLOR_RED,
 *                            .dash_type = LXW_CHART_LINE_DASH_ROUND_DOT};
 *
 *     chart_series_set_error_bars(series->y_error_bars,
 *                                 LXW_CHART_ERROR_BAR_TYPE_STD_ERROR, 0);
 *
 *     chart_series_set_error_bars_line(series->y_error_bars, &line);
 * @endcode
 *
 * @image html chart_error_bars4.png
 *
 * For more information see @ref chart_lines and @ref chart_error_bars.
 *)
procedure chart_series_set_error_bars_line(error_bars: Plxw_series_error_bars; line: Plxw_chart_line); cdecl;
  external bj name _PU + 'chart_series_set_error_bars_line';

(**
 * @brief           Get an axis pointer from a chart.
 *
 * @param chart     Pointer to a lxw_chart instance to be configured.
 * @param axis_type The axis type (X or Y): #lxw_chart_axis_type.
 *
 * The `%chart_axis_get()` function returns a pointer to a chart axis based
 * on the  #lxw_chart_axis_type:
 *
 * @code
 *     lxw_chart_axis *x_axis = chart_axis_get(chart, LXW_CHART_AXIS_TYPE_X);
 *     lxw_chart_axis *y_axis = chart_axis_get(chart, LXW_CHART_AXIS_TYPE_Y);
 *
 *     // Use the axis pointer in other functions.
 *     chart_axis_major_gridlines_set_visible(x_axis, LXW_TRUE);
 *     chart_axis_major_gridlines_set_visible(y_axis, LXW_TRUE);
 * @endcode
 *
 * Note, the axis pointer can also be accessed directly:
 *
 * @code
 *     // Equivalent to the above example, without function calls.
 *     chart_axis_major_gridlines_set_visible(chart->x_axis, LXW_TRUE);
 *     chart_axis_major_gridlines_set_visible(chart->y_axis, LXW_TRUE);
 * @endcode
 *
 * @return Pointer to the chart axis, or NULL if not found.
 *)
function chart_axis_get(chart: Plxw_chart; axis_type: lxw_chart_axis_type): Plxw_chart_axis; cdecl;
  external bj name _PU + 'chart_axis_get';

(**
 * @brief Set the name caption of the an axis.
 *
 * @param axis A pointer to a chart #lxw_chart_axis object.
 * @param name The name caption of the axis.
 *
 * The `%chart_axis_set_name()` function sets the name (also known as title or
 * caption) for an axis. It can be used for the X or Y axes. The name is
 * displayed below an X axis and to the side of a Y axis.
 *
 * @code
 *     chart_axis_set_name(chart->x_axis, "Earnings per Quarter");
 *     chart_axis_set_name(chart->y_axis, "US Dollars (Millions)");
 * @endcode
 *
 * @image html chart_axis_set_name.png
 *
 * The name parameter can also be a formula such as `=Sheet1!$A$1` to point to
 * a cell in the workbook that contains the name:
 *
 * @code
 *     chart_axis_set_name(chart->x_axis, "=Sheet1!$B$1");
 * @endcode
 *
 * See also the `chart_axis_set_name_range()` function to see how to set the
 * name formula programmatically.
 *
 * **Axis types**: This function is applicable to to all axes types.
 *                 See @ref ww_charts_axes.
 *)
procedure chart_axis_set_name(axis: Plxw_chart_axis; const name: PUTF8Char); cdecl;
  external bj name _PU + 'chart_axis_set_name';

(**
 * @brief Set a chart axis name formula using row and column values.
 *
 * @param axis      A pointer to a chart #lxw_chart_axis object.
 * @param sheetname The name of the worksheet that contains the cell range.
 * @param row       The zero indexed row number of the range.
 * @param col       The zero indexed column number of the range.
 *
 * The `%chart_axis_set_name_range()` function can be used to set an axis name
 * range and is an alternative to using `chart_axis_set_name()` and a string
 * formula:
 *
 * @code
 *     chart_axis_set_name_range(chart->x_axis, "Sheet1", 1, 0);
 *     chart_axis_set_name_range(chart->y_axis, "Sheet1", 2, 0);
 * @endcode
 *
 * **Axis types**: This function is applicable to to all axes types.
 *                 See @ref ww_charts_axes.
 *)
procedure chart_axis_set_name_range(axis: Plxw_chart_axis; const sheetname: PUTF8Char; row: lxw_row_t; col: lxw_col_t); cdecl;
  external bj name _PU + 'chart_axis_set_name_range';

(**
 * @brief Set the manual position of the chart axis name.
 *
 * @param axis   A pointer to a chart #lxw_chart_axis object.
 * @param layout A pointer to a chart #lxw_chart_layout struct.
 *
 * This function is used to simulate setting the manual position of a chart
 * axis name. See @ref chart_layout for more information.
 *)
procedure chart_axis_set_name_layout(axis: Plxw_chart_axis; layout: Plxw_chart_layout); cdecl;
  external bj name _PU + 'chart_axis_set_name_layout';

(**
 * @brief Set the font properties for a chart axis name.
 *
 * @param axis A pointer to a chart #lxw_chart_axis object.
 * @param font A pointer to a chart #lxw_chart_font font struct.
 *
 * The `%chart_axis_set_name_font()` function is used to set the font of an
 * axis name:
 *
 * @code
 *     lxw_chart_font font = {.bold = LXW_TRUE, .color = LXW_COLOR_BLUE};
 *
 *     chart_axis_set_name(chart->x_axis, "Yearly data");
 *     chart_axis_set_name_font(chart->x_axis, &font);
 * @endcode
 *
 * @image html chart_axis_set_name_font.png
 *
 * For more information see @ref chart_fonts.
 *
 * **Axis types**: This function is applicable to to all axes types.
 *                 See @ref ww_charts_axes.
 *)
procedure chart_axis_set_name_font(axis: Plxw_chart_axis; font: Plxw_chart_font); cdecl;
  external bj name _PU + 'chart_axis_set_name_font';

(**
 * @brief Set the font properties for the numbers of a chart axis.
 *
 * @param axis A pointer to a chart #lxw_chart_axis object.
 * @param font A pointer to a chart #lxw_chart_font font struct.
 *
 * The `%chart_axis_set_num_font()` function is used to set the font of the
 * numbers on an axis:
 *
 * @code
 *     lxw_chart_font font = {.bold = LXW_TRUE, .color = LXW_COLOR_BLUE};
 *
 *     chart_axis_set_num_font(chart->x_axis, &font1);
 * @endcode
 *
 * @image html chart_axis_set_num_font.png
 *
 * For more information see @ref chart_fonts.
 *
 * **Axis types**: This function is applicable to to all axes types.
 *                 See @ref ww_charts_axes.
 *)
procedure chart_axis_set_num_font(axis: Plxw_chart_axis; font: Plxw_chart_font); cdecl;
  external bj name _PU + 'chart_axis_set_num_font';

(**
 * @brief Set the number format for a chart axis.
 *
 * @param axis       A pointer to a chart #lxw_chart_axis object.
 * @param num_format The number format string.
 *
 * The `%chart_axis_set_num_format()` function is used to set the format of
 * the numbers on an axis:
 *
 * @code
 *     chart_axis_set_num_format(chart->x_axis, "0.00%");
 *     chart_axis_set_num_format(chart->y_axis, "$#,##0.00");
 * @endcode
 *
 * The number format is similar to the Worksheet Cell Format num_format,
 * see `format_set_num_format()`.
 *
 * @image html chart_axis_num_format.png
 *
 * **Axis types**: This function is applicable to to all axes types.
 *                 See @ref ww_charts_axes.
 *)
procedure chart_axis_set_num_format(axis: Plxw_chart_axis; const num_format: PUTF8Char); cdecl;
  external bj name _PU + 'chart_axis_set_num_format';

(**
 * @brief Set the line properties for a chart axis.
 *
 * @param axis A pointer to a chart #lxw_chart_axis object.
 * @param line A #lxw_chart_line struct.
 *
 * Set the line properties of a chart axis:
 *
 * @code
 *     // Hide the Y axis.
 *     lxw_chart_line line = {.none = LXW_TRUE};
 *
 *     chart_axis_set_line(chart->y_axis, &line);
 * @endcode
 *
 * @image html chart_axis_set_line.png
 *
 * For more information see @ref chart_lines.
 *
 * **Axis types**: This function is applicable to to all axes types.
 *                 See @ref ww_charts_axes.
 *)
procedure chart_axis_set_line(axis: Plxw_chart_axis; line: Plxw_chart_line); cdecl;
  external bj name _PU + 'chart_axis_set_line';

(**
 * @brief Set the fill properties for a chart axis.
 *
 * @param axis A pointer to a chart #lxw_chart_axis object.
 * @param fill A #lxw_chart_fill struct.
 *
 * Set the fill properties of a chart axis:
 *
 * @code
 *     lxw_chart_fill fill = {.color = LXW_COLOR_YELLOW};
 *
 *     chart_axis_set_fill(chart->y_axis, &fill);
 * @endcode
 *
 * @image html chart_axis_set_fill.png
 *
 * For more information see @ref chart_fills.
 *
 * **Axis types**: This function is applicable to to all axes types.
 *                 See @ref ww_charts_axes.
 *)
procedure chart_axis_set_fill(axis: Plxw_chart_axis; fill: Plxw_chart_fill); cdecl;
  external bj name _PU + 'chart_axis_set_fill';

(**
 * @brief Set the pattern properties for a chart axis.
 *
 * @param axis    A pointer to a chart #lxw_chart_axis object.
 * @param pattern A #lxw_chart_pattern struct.
 *
 * Set the pattern properties of a chart axis:
 *
 * @code
 *     chart_axis_set_pattern(chart->y_axis, &pattern);
 * @endcode
 *
 * For more information see #lxw_chart_pattern_type and @ref chart_patterns.
 *
 * **Axis types**: This function is applicable to to all axes types.
 *                 See @ref ww_charts_axes.
 *)
procedure chart_axis_set_pattern(axis: Plxw_chart_axis; pattern: Plxw_chart_pattern); cdecl;
  external bj name _PU + 'chart_axis_set_pattern';

(**
 * @brief Reverse the order of the axis categories or values.
 *
 * @param axis A pointer to a chart #lxw_chart_axis object.
 *
 * Reverse the order of the axis categories or values:
 *
 * @code
 *     chart_axis_set_reverse(chart->x_axis);
 * @endcode
 *
 * @image html chart_reverse.png
 *
 * **Axis types**: This function is applicable to to all axes types.
 *                 See @ref ww_charts_axes.
 *)
procedure chart_axis_set_reverse(axis: Plxw_chart_axis); cdecl;
  external bj name _PU + 'chart_axis_set_reverse';

(**
 * @brief Set the position that the axis will cross the opposite axis.
 *
 * @param axis  A pointer to a chart #lxw_chart_axis object.
 * @param value The category or value that the axis crosses at.
 *
 * Set the position that the axis will cross the opposite axis:
 *
 * @code
 *     chart_axis_set_crossing(chart->x_axis, 3);
 *     chart_axis_set_crossing(chart->y_axis, 8);
 * @endcode
 *
 * @image html chart_crossing1.png
 *
 * If crossing is omitted (the default) the crossing will be set automatically
 * by Excel based on the chart data.
 *
 * **Axis types**: This function is applicable to to all axes types.
 *                 See @ref ww_charts_axes.
 *)
procedure chart_axis_set_crossing(axis: Plxw_chart_axis; value: Double); cdecl;
  external bj name _PU + 'chart_axis_set_crossing';

(**
 * @brief Set the opposite axis crossing position as the axis maximum.
 *
 * @param axis  A pointer to a chart #lxw_chart_axis object.
 *
 * Set the position that the opposite axis will cross as the axis maximum.
 * The default axis crossing position is generally the axis minimum so this
 * function can be used to reverse the location of the axes without reversing
 * the number sequence:
 *
 * @code
 *     chart_axis_set_crossing_max(chart->x_axis);
 *     chart_axis_set_crossing_max(chart->y_axis);
 * @endcode
 *
 * @image html chart_crossing2.png
 *
 * **Axis types**: This function is applicable to to all axes types.
 *                 See @ref ww_charts_axes.
 *)
procedure chart_axis_set_crossing_max(axis: Plxw_chart_axis); cdecl;
  external bj name _PU + 'chart_axis_set_crossing_max';

(**
 * @brief Set the opposite axis crossing position as the axis minimum.
 *
 * @param axis  A pointer to a chart #lxw_chart_axis object.
 *
 * Set the position that the opposite axis will cross as the axis minimum.
 * The default axis crossing position is generally the axis minimum so this
 * function can be used to reverse the location of the axes without reversing
 * the number sequence:
 *
 * @code
 *     chart_axis_set_crossing_min(chart->x_axis);
 *     chart_axis_set_crossing_min(chart->y_axis);
 * @endcode
 *
 * **Axis types**: This function is applicable to to all axes types.
 *                 See @ref ww_charts_axes.
 *)
procedure chart_axis_set_crossing_min(axis: Plxw_chart_axis); cdecl;
  external bj name _PU + 'chart_axis_set_crossing_min';

(**
 * @brief Turn off/hide an axis.
 *
 * @param axis A pointer to a chart #lxw_chart_axis object.
 *
 * Turn off, hide, a chart axis:
 *
 * @code
 *     chart_axis_off(chart->x_axis);
 * @endcode
 *
 * @image html chart_axis_off.png
 *
 * **Axis types**: This function is applicable to to all axes types.
 *                 See @ref ww_charts_axes.
 *)
procedure chart_axis_off(axis: Plxw_chart_axis); cdecl;
  external bj name _PU + 'chart_axis_off';

(**
 * @brief Position a category axis on or between the axis tick marks.
 *
 * @param axis     A pointer to a chart #lxw_chart_axis object.
 * @param position A #lxw_chart_axis_tick_position value.
 *
 * Position a category axis horizontally on, or between, the axis tick marks.
 *
 * There are two allowable values:
 *
 * - #LXW_CHART_AXIS_POSITION_ON_TICK
 * - #LXW_CHART_AXIS_POSITION_BETWEEN
 *
 * @code
 *     chart_axis_set_position(chart->x_axis, LXW_CHART_AXIS_POSITION_BETWEEN);
 * @endcode
 *
 * @image html chart_axis_set_position.png
 *
 * **Axis types**: This function is applicable to category axes only.
 *                 See @ref ww_charts_axes.
 *)
procedure chart_axis_set_position(axis: Plxw_chart_axis; position: UInt8); cdecl;
  external bj name _PU + 'chart_axis_set_position';

(**
 * @brief Position the axis labels.
 *
 * @param axis     A pointer to a chart #lxw_chart_axis object.
 * @param position A #lxw_chart_axis_label_position value.
 *
 * Position the axis labels for the chart. The labels are the numbers, or
 * strings or dates, on the axis that indicate the categories or values of
 * the axis.
 *
 * For example:
 *
 * @code
 *     chart_axis_set_label_position(chart->x_axis, LXW_CHART_AXIS_LABEL_POSITION_HIGH);
 *     chart_axis_set_label_position(chart->y_axis, LXW_CHART_AXIS_LABEL_POSITION_HIGH);
 * @endcode
 *
 * @image html chart_label_position2.png
 *
 * The allowable values:
 *
 * - #LXW_CHART_AXIS_LABEL_POSITION_NEXT_TO - The default.
 * - #LXW_CHART_AXIS_LABEL_POSITION_HIGH - Also right for vertical axes.
 * - #LXW_CHART_AXIS_LABEL_POSITION_LOW - Also left for vertical axes.
 * - #LXW_CHART_AXIS_LABEL_POSITION_NONE
 *
 * @image html chart_label_position1.png
 *
 * The #LXW_CHART_AXIS_LABEL_POSITION_NONE turns off the axis labels. This
 * is slightly different from `chart_axis_off()` which also turns off the
 * labels but also turns off tick marks.
 *
 * **Axis types**: This function is applicable to to all axes types.
 *                 See @ref ww_charts_axes.
 *)
procedure chart_axis_set_label_position(axis: Plxw_chart_axis; position: UInt8); cdecl;
  external bj name _PU + 'chart_axis_set_label_position';

(**
 * @brief Set the alignment of the axis labels.
 *
 * @param axis  A pointer to a chart #lxw_chart_axis object.
 * @param align A #lxw_chart_axis_label_alignment value.
 *
 * Position the category axis labels for the chart. The labels are the
 * numbers, or strings or dates, on the axis that indicate the categories
 * of the axis.
 *
 * The allowable values:
 *
 * - #LXW_CHART_AXIS_LABEL_ALIGN_CENTER - Align label center (default).
 * - #LXW_CHART_AXIS_LABEL_ALIGN_LEFT - Align label left.
 * - #LXW_CHART_AXIS_LABEL_ALIGN_RIGHT - Align label right.
 *
 * @code
 *     chart_axis_set_label_align(chart->x_axis, LXW_CHART_AXIS_LABEL_ALIGN_RIGHT);
 * @endcode
 *
 * **Axis types**: This function is applicable to category axes only.
 *                 See @ref ww_charts_axes.
 *)
procedure chart_axis_set_label_align(axis: Plxw_chart_axis; align: UInt8); cdecl;
  external bj name _PU + 'chart_axis_set_label_align';

(**
 * @brief Set the minimum value for a chart axis.
 *
 * @param axis A pointer to a chart #lxw_chart_axis object.
 * @param min  Minimum value for chart axis. Value axes only.
 *
 * Set the minimum value for the axis range.
 *
 * @code
 *     chart_axis_set_min(chart->y_axis, -4);
 *     chart_axis_set_max(chart->y_axis, 21);
 * @endcode
 *
 * @image html chart_max_min.png
 *
 * **Axis types**: This function is applicable to value and date axes only.
 *                 See @ref ww_charts_axes.
 *)
procedure chart_axis_set_min(axis: Plxw_chart_axis; min: Double); cdecl;
  external bj name _PU + 'chart_axis_set_min';

(**
 * @brief Set the maximum value for a chart axis.
 *
 * @param axis A pointer to a chart #lxw_chart_axis object.
 * @param max  Maximum value for chart axis. Value axes only.
 *
 * Set the maximum value for the axis range.
 *
 * @code
 *     chart_axis_set_min(chart->y_axis, -4);
 *     chart_axis_set_max(chart->y_axis, 21);
 * @endcode
 *
 * See the above image.
 *
 * **Axis types**: This function is applicable to value and date axes only.
 *                 See @ref ww_charts_axes.
 *)
procedure chart_axis_set_max(axis: Plxw_chart_axis; max: Double); cdecl;
  external bj name _PU + 'chart_axis_set_max';

(**
 * @brief Set the log base of the axis range.
 *
 * @param axis     A pointer to a chart #lxw_chart_axis object.
 * @param log_base The log base for value axis. Value axes only.
 *
 * Set the log base for the axis:
 *
 * @code
 *     chart_axis_set_log_base(chart->y_axis, 10);
 * @endcode
 *
 * @image html chart_log_base.png
 *
 * The allowable range of values for the log base in Excel is between 2 and
 * 1000.
 *
 * **Axis types**: This function is applicable to value axes only.
 *                 See @ref ww_charts_axes.
 *)
procedure chart_axis_set_log_base(axis: Plxw_chart_axis; log_base: UInt16); cdecl;
  external bj name _PU + 'chart_axis_set_log_base';

(**
 * @brief Set the major axis tick mark type.
 *
 * @param axis A pointer to a chart #lxw_chart_axis object.
 * @param type The tick mark type, defined by #lxw_chart_tick_mark.
 *
 * Set the type of the major axis tick mark:
 *
 * @code
 *     chart_axis_set_major_tick_mark(chart->x_axis, LXW_CHART_AXIS_TICK_MARK_CROSSING);
 *     chart_axis_set_minor_tick_mark(chart->x_axis, LXW_CHART_AXIS_TICK_MARK_INSIDE);
 *
 *     chart_axis_set_major_tick_mark(chart->x_axis, LXW_CHART_AXIS_TICK_MARK_OUTSIDE);
 *     chart_axis_set_minor_tick_mark(chart->y_axis, LXW_CHART_AXIS_TICK_MARK_INSIDE);
 *
 *     // Hide the default gridlines so the tick marks are visible.
 *     chart_axis_major_gridlines_set_visible(chart->y_axis, LXW_FALSE);
 * @endcode
 *
 * @image html chart_tick_marks.png
 *
 * The tick mark types are:
 *
 * - #LXW_CHART_AXIS_TICK_MARK_NONE
 * - #LXW_CHART_AXIS_TICK_MARK_INSIDE
 * - #LXW_CHART_AXIS_TICK_MARK_OUTSIDE
 * - #LXW_CHART_AXIS_TICK_MARK_CROSSING
 *
 * **Axis types**: This function is applicable to to all axes types.
 *                 See @ref ww_charts_axes.
 *)
procedure chart_axis_set_major_tick_mark(axis: Plxw_chart_axis; atype: UInt8); cdecl;
  external bj name _PU + 'chart_axis_set_major_tick_mark';

(**
 * @brief Set the minor axis tick mark type.
 *
 * @param axis A pointer to a chart #lxw_chart_axis object.
 * @param type The tick mark type, defined by #lxw_chart_tick_mark.
 *
 * Set the type of the minor axis tick mark:
 *
 * @code
 *     chart_axis_set_minor_tick_mark(chart->x_axis, LXW_CHART_AXIS_TICK_MARK_INSIDE);
 * @endcode
 *
 * See the image and example above.
 *
 * **Axis types**: This function is applicable to to all axes types.
 *                 See @ref ww_charts_axes.
 *)
procedure chart_axis_set_minor_tick_mark(axis: Plxw_chart_axis; atype: UInt8); cdecl;
  external bj name _PU + 'chart_axis_set_minor_tick_mark';

(**
 * @brief Set the interval between category values.
 *
 * @param axis A pointer to a chart #lxw_chart_axis object.
 * @param unit The interval between the categories.
 *
 * Set the interval between the category values. The default interval is 1
 * which gives the intervals shown in the charts above:
 *
 *     1, 2, 3, 4, 5, etc.
 *
 * Setting it to 2 gives:
 *
 *     1, 3, 5, 7, etc.
 *
 * For example:
 *
 * @code
 *     chart_axis_set_interval_unit(chart->x_axis, 2);
 * @endcode
 *
 * @image html chart_set_interval1.png
 *
 * **Axis types**: This function is applicable to category and date axes only.
 *                 See @ref ww_charts_axes.
 *)
procedure chart_axis_set_interval_unit(axis: Plxw_chart_axis; aunit: UInt16); cdecl;
  external bj name _PU + 'chart_axis_set_interval_unit';

(**
 * @brief Set the interval between category tick marks.
 *
 * @param axis A pointer to a chart #lxw_chart_axis object.
 * @param unit The interval between the category ticks.
 *
 * Set the interval between the category tick marks. The default interval is 1
 * between each category but it can be set to other integer values:
 *
 * @code
 *     chart_axis_set_interval_tick(chart->x_axis, 2);
 * @endcode
 *
 * @image html chart_set_interval2.png
 *
 * **Axis types**: This function is applicable to category and date axes only.
 *                 See @ref ww_charts_axes.
 *)
procedure chart_axis_set_interval_tick(axis: Plxw_chart_axis; aunit: UInt16); cdecl;
  external bj name _PU + 'chart_axis_set_interval_tick';

(**
 * @brief Set the increment of the major units in the axis.
 *
 * @param axis A pointer to a chart #lxw_chart_axis object.
 * @param unit The increment of the major units.
 *
 * Set the increment of the major units in the axis range.
 *
 * @code
 *     // Turn on the minor gridline (it is off by default).
 *     chart_axis_minor_gridlines_set_visible(chart->y_axis, LXW_TRUE);
 *
 *     chart_axis_set_major_unit(chart->y_axis, 4);
 *     chart_axis_set_minor_unit(chart->y_axis, 2);
 * @endcode
 *
 * @image html chart_set_major_units.png
 *
 * **Axis types**: This function is applicable to value and date axes only.
 *                 See @ref ww_charts_axes.
 *)
procedure chart_axis_set_major_unit(axis: Plxw_chart_axis; aunit: Double); cdecl;
  external bj name _PU + 'chart_axis_set_major_unit';

(**
 * @brief Set the increment of the minor units in the axis.
 *
 * @param axis A pointer to a chart #lxw_chart_axis object.
 * @param unit The increment of the minor units.
 *
 * Set the increment of the minor units in the axis range.
 *
 * @code
 *     chart_axis_set_minor_unit(chart->y_axis, 2);
 * @endcode
 *
 * See the image above
 *
 * **Axis types**: This function is applicable to value and date axes only.
 *                 See @ref ww_charts_axes.
 *)
procedure chart_axis_set_minor_unit(axis: Plxw_chart_axis; aunit: Double); cdecl;
  external bj name _PU + 'chart_axis_set_minor_unit';

(**
 * @brief Set the display units for a value axis.
 *
 * @param axis  A pointer to a chart #lxw_chart_axis object.
 * @param units The display units: #lxw_chart_axis_display_unit.
 *
 * Set the display units for the axis. This can be useful if the axis numbers
 * are very large but you don't want to represent them in scientific notation:
 *
 * @code
 *     chart_axis_set_display_units(chart->x_axis, LXW_CHART_AXIS_UNITS_THOUSANDS);
 *     chart_axis_set_display_units(chart->y_axis, LXW_CHART_AXIS_UNITS_MILLIONS);
 * @endcode
 *
 * @image html chart_display_units.png
 *
 * **Axis types**: This function is applicable to value axes only.
 *                 See @ref ww_charts_axes.
 *)
procedure chart_axis_set_display_units(axis: Plxw_chart_axis; units: UInt8); cdecl;
  external bj name _PU + 'chart_axis_set_display_units';

(**
 * @brief Turn on/off the display units for a value axis.

 * @param axis    A pointer to a chart #lxw_chart_axis object.
 * @param visible Turn off/on the display units. (0/1)
 *
 * Turn on or off the display units for the axis. This option is set on
 * automatically by `chart_axis_set_display_units()`.
 *
 * @code
 *     chart_axis_set_display_units_visible(chart->y_axis, LXW_TRUE);
 * @endcode
 *
 * **Axis types**: This function is applicable to value axes only.
 *                 See @ref ww_charts_axes.
 *)
procedure chart_axis_set_display_units_visible(axis: Plxw_chart_axis; visible: UInt8); cdecl;
  external bj name _PU + 'chart_axis_set_display_units_visible';

(**
 * @brief Turn on/off the major gridlines for an axis.
 *
 * @param axis    A pointer to a chart #lxw_chart_axis object.
 * @param visible Turn off/on the major gridline. (0/1)
 *
 * Turn on or off the major gridlines for an X or Y axis. In most Excel charts
 * the Y axis major gridlines are on by default and the X axis major
 * gridlines are off by default.
 *
 * Example:
 *
 * @code
 *     // Reverse the normal visible/hidden gridlines for a column chart.
 *     chart_axis_major_gridlines_set_visible(chart->x_axis, LXW_TRUE);
 *     chart_axis_major_gridlines_set_visible(chart->y_axis, LXW_FALSE);
 * @endcode
 *
 * @image html chart_gridline1.png
 *
 * **Axis types**: This function is applicable to to all axes types.
 *                 See @ref ww_charts_axes.
 *)
procedure chart_axis_major_gridlines_set_visible(axis: Plxw_chart_axis; visible: UInt8); cdecl;
  external bj name _PU + 'chart_axis_major_gridlines_set_visible';

(**
 * @brief Turn on/off the minor gridlines for an axis.
 *
 * @param axis    A pointer to a chart #lxw_chart_axis object.
 * @param visible Turn off/on the minor gridline. (0/1)
 *
 * Turn on or off the minor gridlines for an X or Y axis. In most Excel charts
 * the X and Y axis minor gridlines are off by default.
 *
 * Example, turn on all major and minor gridlines:
 *
 * @code
 *     chart_axis_major_gridlines_set_visible(chart->x_axis, LXW_TRUE);
 *     chart_axis_minor_gridlines_set_visible(chart->x_axis, LXW_TRUE);
 *     chart_axis_major_gridlines_set_visible(chart->y_axis, LXW_TRUE);
 *     chart_axis_minor_gridlines_set_visible(chart->y_axis, LXW_TRUE);
 * @endcode
 *
 * @image html chart_gridline2.png
 *
 * **Axis types**: This function is applicable to to all axes types.
 *                 See @ref ww_charts_axes.
 *)
procedure chart_axis_minor_gridlines_set_visible(axis: Plxw_chart_axis; visible: UInt8); cdecl;
  external bj name _PU + 'chart_axis_minor_gridlines_set_visible';

(**
 * @brief Set the line properties for the chart axis major gridlines.
 *
 * @param axis A pointer to a chart #lxw_chart_axis object.
 * @param line A #lxw_chart_line struct.
 *
 * Format the line properties of the major gridlines of a chart:
 *
 * @code
 *     lxw_chart_line line1 = {.color = LXW_COLOR_RED,
 *                             .width = 0.5,
 *                             .dash_type = LXW_CHART_LINE_DASH_SQUARE_DOT};
 *
 *     lxw_chart_line line2 = {.color = LXW_COLOR_YELLOW};
 *
 *     lxw_chart_line line3 = {.width = 1.25,
 *                             .dash_type = LXW_CHART_LINE_DASH_DASH};
 *
 *     lxw_chart_line line4 = {.color =  0x00B050};
 *
 *     chart_axis_major_gridlines_set_line(chart->x_axis, &line1);
 *     chart_axis_minor_gridlines_set_line(chart->x_axis, &line2);
 *     chart_axis_major_gridlines_set_line(chart->y_axis, &line3);
 *     chart_axis_minor_gridlines_set_line(chart->y_axis, &line4);
 * @endcode
 *
 * @image html chart_gridline3.png
 *
 * For more information see @ref chart_lines.
 *
 * **Axis types**: This function is applicable to to all axes types.
 *                 See @ref ww_charts_axes.
 *)
procedure chart_axis_major_gridlines_set_line(axis: Plxw_chart_axis; line: Plxw_chart_line); cdecl;
  external bj name _PU + 'chart_axis_major_gridlines_set_line';

(**
 * @brief Set the line properties for the chart axis minor gridlines.
 *
 * @param axis A pointer to a chart #lxw_chart_axis object.
 * @param line A #lxw_chart_line struct.
 *
 * Format the line properties of the minor gridlines of a chart, see the
 * example above.
 *
 * For more information see @ref chart_lines.
 *
 * **Axis types**: This function is applicable to to all axes types.
 *                 See @ref ww_charts_axes.
 *)
procedure chart_axis_minor_gridlines_set_line(axis: Plxw_chart_axis; line: Plxw_chart_line); cdecl;
  external bj name _PU + 'chart_axis_minor_gridlines_set_line';

(**
 * @brief Set the title of the chart.
 *
 * @param chart Pointer to a lxw_chart instance to be configured.
 * @param name  The chart title name.
 *
 * The `%chart_title_set_name()` function sets the name (title) for the
 * chart. The name is displayed above the chart.
 *
 * @code
 *     chart_title_set_name(chart, "Year End Results");
 * @endcode
 *
 * @image html chart_title_set_name.png
 *
 * The name parameter can also be a formula such as `=Sheet1!$A$1` to point to
 * a cell in the workbook that contains the name:
 *
 * @code
 *     chart_title_set_name(chart, "=Sheet1!$B$1");
 * @endcode
 *
 * See also the `chart_title_set_name_range()` function to see how to set the
 * name formula programmatically.
 *
 * The Excel default is to have no chart title.
 *)
procedure chart_title_set_name(chart: Plxw_chart; const name: PUTF8Char); cdecl;
  external bj name _PU + 'chart_title_set_name';

(**
 * @brief Set a chart title formula using row and column values.
 *
 * @param chart     Pointer to a lxw_chart instance to be configured.
 * @param sheetname The name of the worksheet that contains the cell range.
 * @param row       The zero indexed row number of the range.
 * @param col       The zero indexed column number of the range.
 *
 * The `%chart_title_set_name_range()` function can be used to set a chart
 * title range and is an alternative to using `chart_title_set_name()` and a
 * string formula:
 *
 * @code
 *     chart_title_set_name_range(chart, "Sheet1", 1, 0);
 * @endcode
 *)
procedure chart_title_set_name_range(chart: Plxw_chart; const sheetname: PUTF8Char; row: lxw_row_t; col: lxw_col_t); cdecl;
  external bj name _PU + 'chart_title_set_name_range';

(**
 * @brief  Set the font properties for a chart title.
 *
 * @param chart Pointer to a lxw_chart instance to be configured.
 * @param font  A pointer to a chart #lxw_chart_font font struct.
 *
 * The `%chart_title_set_name_font()` function is used to set the font of a
 * chart title:
 *
 * @code
 *     lxw_chart_font font = {.color = LXW_COLOR_BLUE};
 *
 *     chart_title_set_name(chart, "Year End Results");
 *     chart_title_set_name_font(chart, &font);
 * @endcode
 *
 * @image html chart_title_set_name_font.png
 *
 * In Excel a chart title font is bold by default (as shown in the image
 * above). To turn off bold in the font you cannot use #LXW_FALSE (0) since
 * that is indistinguishable from an uninitialized value. Instead you should
 * use #LXW_EXPLICIT_FALSE:
 *
 * @code
 *     lxw_chart_font font = {.bold = LXW_EXPLICIT_FALSE, .color = LXW_COLOR_BLUE};
 *
 *     chart_title_set_name(chart, "Year End Results");
 *     chart_title_set_name_font(chart, &font);
 * @endcode
 *
 * @image html chart_title_set_name_font2.png
 *
 * For more information see @ref chart_fonts.
 *)
procedure chart_title_set_name_font(chart: Plxw_chart; font: Plxw_chart_font); cdecl;
  external bj name _PU + 'chart_title_set_name_font';

(**
 * @brief Turn off an automatic chart title.
 *
 * @param chart  Pointer to a lxw_chart instance to be configured.
 *
 * In general in Excel a chart title isn't displayed unless the user
 * explicitly adds one. However, Excel adds an automatic chart title to charts
 * with a single series and a user defined series name. The
 * `chart_title_off()` function allows you to turn off this automatic chart
 * title:
 *
 * @code
 *     chart_title_off(chart);
 * @endcode
 *)
procedure chart_title_off(chart: Plxw_chart); cdecl;
  external bj name _PU + 'chart_title_off';

(**
 * @brief Set the manual position of the chart title.
 *
 * @param chart  Pointer to a lxw_chart instance to be configured.
 * @param layout A pointer to a chart #lxw_chart_layout struct.
 *
 * This function is used to simulate setting the manual position of the chart
 * title. See @ref chart_layout for more information.
 *)
procedure chart_title_set_layout(chart: Plxw_chart; layout: Plxw_chart_layout); cdecl;
  external bj name _PU + 'chart_title_set_layout';

(**
 * @brief Allow the chart title to overlay the chart.
 *
 * @param chart   Pointer to a lxw_chart instance to be configured.
 * @param overlay Turn off/on the overlay. (0/1)
 *
 * This option allows the chart title to overlay the chart when the
 * `chart_title_set_layout()` function.
 *)
procedure chart_title_set_overlay(chart: Plxw_chart; overlay: UInt8); cdecl;
  external bj name _PU + 'chart_title_set_overlay';

(**
 * @brief Set the position of the chart legend.
 *
 * @param chart    Pointer to a lxw_chart instance to be configured.
 * @param position The #lxw_chart_legend_position value for the legend.
 *
 * The `%chart_legend_set_position()` function is used to set the chart
 * legend to one of the #lxw_chart_legend_position values:
 *
 *     LXW_CHART_LEGEND_NONE
 *     LXW_CHART_LEGEND_RIGHT
 *     LXW_CHART_LEGEND_LEFT
 *     LXW_CHART_LEGEND_TOP
 *     LXW_CHART_LEGEND_BOTTOM
 *     LXW_CHART_LEGEND_TOP_RIGHT
 *     LXW_CHART_LEGEND_OVERLAY_RIGHT
 *     LXW_CHART_LEGEND_OVERLAY_LEFT
 *     LXW_CHART_LEGEND_OVERLAY_TOP_RIGHT
 *
 * For example:
 *
 * @code
 *     chart_legend_set_position(chart, LXW_CHART_LEGEND_BOTTOM);
 * @endcode
 *
 * @image html chart_legend_bottom.png
 *
 * This function can also be used to turn off a chart legend:
 *
 * @code
 *     chart_legend_set_position(chart, LXW_CHART_LEGEND_NONE);
 * @endcode
 *
 * @image html chart_legend_none.png
 *
 *)
procedure chart_legend_set_position(chart: Plxw_chart; position: UInt8); cdecl;
  external bj name _PU + 'chart_legend_set_position';

(**
 * @brief Set the manual layout of the chart legend.
 *
 * @param chart  Pointer to a lxw_chart instance to be configured.
 * @param layout A pointer to a chart #lxw_chart_layout struct.
 *
 * This function is used to simulate setting the manual position of the chart
 * legend. See @ref chart_layout for more information.
 *)
procedure chart_legend_set_layout(chart: Plxw_chart; layout: Plxw_chart_layout); cdecl;
  external bj name _PU + 'chart_legend_set_layout';

(**
 * @brief Set the font properties for a chart legend.
 *
 * @param chart Pointer to a lxw_chart instance to be configured.
 * @param font  A pointer to a chart #lxw_chart_font font struct.
 *
 * The `%chart_legend_set_font()` function is used to set the font of a
 * chart legend:
 *
 * @code
 *     lxw_chart_font font = {.bold = LXW_TRUE, .color = LXW_COLOR_BLUE};
 *
 *     chart_legend_set_font(chart, &font);
 * @endcode
 *
 * @image html chart_legend_set_font.png
 *
 * For more information see @ref chart_fonts.
 *)
procedure chart_legend_set_font(chart: Plxw_chart; font: Plxw_chart_font); cdecl;
  external bj name _PU + 'chart_legend_set_font';

(**
 * @brief Remove one or more series from the the legend.
 *
 * @param chart         Pointer to a lxw_chart instance to be configured.
 * @param delete_series An array of zero-indexed values to delete from series.
 *
 * @return A #lxw_error.
 *
 * The `%chart_legend_delete_series()` function allows you to remove/hide one
 * or more series in a chart legend (the series will still display on the chart).
 *
 * This function takes an array of one or more zero indexed series
 * numbers. The array should be terminated with -1.
 *
 * For example to remove the first and third zero-indexed series from the
 * legend of a chart with 3 series:
 *
 * @code
 *     int16_t series[] = {0, 2, -1};
 *
 *     chart_legend_delete_series(chart, series);
 * @endcode
 *
 * @image html chart_legend_delete.png
 *)
function chart_legend_delete_series(chart: Plxw_chart; delete_series: PInt16): lxw_error; cdecl;
  external bj name _PU + 'chart_legend_delete_series';

(**
 * @brief Set the line properties for a chartarea.
 *
 * @param chart Pointer to a lxw_chart instance to be configured.
 * @param line  A #lxw_chart_line struct.
 *
 * Set the line/border properties of a chartarea. In Excel the chartarea
 * is the background area behind the chart:
 *
 * @code
 *     lxw_chart_line line = {.none  = LXW_TRUE};
 *     lxw_chart_fill fill = {.color = LXW_COLOR_RED};
 *
 *     chart_chartarea_set_line(chart, &line);
 *     chart_chartarea_set_fill(chart, &fill);
 * @endcode
 *
 * @image html chart_chartarea.png
 *
 * For more information see @ref chart_lines.
 *)
procedure chart_chartarea_set_line(chart: Plxw_chart; line: Plxw_chart_line); cdecl;
  external bj name _PU + 'chart_chartarea_set_line';

(**
 * @brief Set the fill properties for a chartarea.
 *
 * @param chart Pointer to a lxw_chart instance to be configured.
 * @param fill  A #lxw_chart_fill struct.
 *
 * Set the fill properties of a chartarea:
 *
 * @code
 *     chart_chartarea_set_fill(chart, &fill);
 * @endcode
 *
 * See the example and image above.
 *
 * For more information see @ref chart_fills.
 *)
procedure chart_chartarea_set_fill(chart: Plxw_chart; fill: Plxw_chart_fill); cdecl;
  external bj name _PU + 'chart_chartarea_set_fill';

(**
 * @brief Set the pattern properties for a chartarea.
 *
 * @param chart   Pointer to a lxw_chart instance to be configured.
 * @param pattern A #lxw_chart_pattern struct.
 *
 * Set the pattern properties of a chartarea:
 *
 * @code
 *     chart_chartarea_set_pattern(series1, &pattern);
 * @endcode
 *
 * For more information see #lxw_chart_pattern_type and @ref chart_patterns.
 *)
procedure chart_chartarea_set_pattern(chart: Plxw_chart; pattern: Plxw_chart_pattern); cdecl;
  external bj name _PU + 'chart_chartarea_set_pattern';

(**
 * @brief Set the line properties for a plotarea.
 *
 * @param chart Pointer to a lxw_chart instance to be configured.
 * @param line  A #lxw_chart_line struct.
 *
 * Set the line/border properties of a plotarea. In Excel the plotarea is
 * the area between the axes on which the chart series are plotted:
 *
 * @code
 *     lxw_chart_line line = {.color     = LXW_COLOR_RED,
 *                            .width     = 2,
 *                            .dash_type = LXW_CHART_LINE_DASH_DASH};
 *     lxw_chart_fill fill = {.color     = 0xFFFFC2};
 *
 *     chart_plotarea_set_line(chart, &line);
 *     chart_plotarea_set_fill(chart, &fill);
 *
 * @endcode
 *
 * @image html chart_plotarea.png
 *
 * For more information see @ref chart_lines.
 *)
procedure chart_plotarea_set_line(chart: Plxw_chart; line: Plxw_chart_line); cdecl;
  external bj name _PU + 'chart_plotarea_set_line';

(**
 * @brief Set the fill properties for a plotarea.
 *
 * @param chart Pointer to a lxw_chart instance to be configured.
 * @param fill  A #lxw_chart_fill struct.
 *
 * Set the fill properties of a plotarea:
 *
 * @code
 *     chart_plotarea_set_fill(chart, &fill);
 * @endcode
 *
 * See the example and image above.
 *
 * For more information see @ref chart_fills.
 *)
procedure chart_plotarea_set_fill(chart: Plxw_chart; fill: Plxw_chart_fill); cdecl;
  external bj name _PU + 'chart_plotarea_set_fill';

(**
 * @brief Set the pattern properties for a plotarea.
 *
 * @param chart   Pointer to a lxw_chart instance to be configured.
 * @param pattern A #lxw_chart_pattern struct.
 *
 * Set the pattern properties of a plotarea:
 *
 * @code
 *     chart_plotarea_set_pattern(series1, &pattern);
 * @endcode
 *
 * For more information see #lxw_chart_pattern_type and @ref chart_patterns.
 *)
procedure chart_plotarea_set_pattern(chart: Plxw_chart; pattern: Plxw_chart_pattern); cdecl;
  external bj name _PU + 'chart_plotarea_set_pattern';

(**
 * @brief Set the manual layout of the chart plotarea.
 *
 * @param chart  Pointer to a lxw_chart instance to be configured.
 * @param layout A pointer to a chart #lxw_chart_layout struct.
 *
 * This function is used to simulate setting the manual position of the chart
 * plotarea. See @ref chart_layout for more information.
 *)
procedure chart_plotarea_set_layout(chart: Plxw_chart; layout: Plxw_chart_layout); cdecl;
  external bj name _PU + 'chart_plotarea_set_layout';

(**
 * @brief Set the chart style type.
 *
 * @param chart    Pointer to a lxw_chart instance to be configured.
 * @param style_id An index representing the chart style, 1 - 48.
 *
 * The `%chart_set_style()` function is used to set the style of the chart to
 * one of the 48 built-in styles available on the "Design" tab in Excel 2007:
 *
 * @code
 *     chart_set_style(chart, 37)
 * @endcode
 *
 * @image html chart_style.png
 *
 * The style index number is counted from 1 on the top left in the Excel
 * dialog. The default style is 2.
 *
 * **Note:**
 *
 * In Excel 2013 the Styles section of the "Design" tab in Excel shows what
 * were referred to as "Layouts" in previous versions of Excel. These layouts
 * are not defined in the file format. They are a collection of modifications
 * to the base chart type. They can not be defined by the `chart_set_style()``
 * function.
 *
 *)
procedure chart_set_style(chart: Plxw_chart; style_id: UInt8); cdecl;
  external bj name _PU + 'chart_set_style';

(**
 * @brief Turn on a data table below the horizontal axis.
 *
 * @param chart Pointer to a lxw_chart instance to be configured.
 *
 * The `%chart_set_table()` function adds a data table below the horizontal
 * axis with the data used to plot the chart:
 *
 * @code
 *     // Turn on the data table with default options.
 *     chart_set_table(chart);
 * @endcode
 *
 * @image html chart_data_table1.png
 *
 * The data table can only be shown with Bar, Column, Line and Area charts.
 *
 *)
procedure chart_set_table(chart: Plxw_chart); cdecl;
  external bj name _PU + 'chart_set_table';

(**
 * @brief Turn on/off grid options for a chart data table.
 *
 * @param chart       Pointer to a lxw_chart instance to be configured.
 * @param horizontal  Turn on/off the horizontal grid lines in the table.
 * @param vertical    Turn on/off the vertical grid lines in the table.
 * @param outline     Turn on/off the outline lines in the table.
 * @param legend_keys Turn on/off the legend keys in the table.
 *
 * The `%chart_set_table_grid()` function turns on/off grid options for a
 * chart data table. The data table grid options in Excel are shown in the
 * dialog below:
 *
 * @image html chart_data_table3.png
 *
 * These options can be passed to the `%chart_set_table_grid()` function.
 * The values for a default chart are:
 *
 * - `horizontal`: On.
 * - `vertical`: On.
 * - `outline`:  On.
 * - `legend_keys`: Off.
 *
 * Example:
 *
 * @code
 *     // Turn on the data table with default options.
 *     chart_set_table(chart);
 *
 *     // Turn on all grid lines and the grid legend.
 *     chart_set_table_grid(chart, LXW_TRUE, LXW_TRUE, LXW_TRUE, LXW_TRUE);
 *
 *     // Turn off the legend since it is show in the table.
 *     chart_legend_set_position(chart, LXW_CHART_LEGEND_NONE);
 *
 * @endcode
 *
 * @image html chart_data_table2.png
 *
 * The data table can only be shown with Bar, Column, Line and Area charts.
 *
 *)
procedure chart_set_table_grid(chart: Plxw_chart; horizontal: UInt8; vertical: UInt8; outline: UInt8; legend_keys: UInt8); cdecl;
  external bj name _PU + 'chart_set_table_grid';

procedure chart_set_table_font(chart: Plxw_chart; font: Plxw_chart_font); cdecl;
  external bj name _PU + 'chart_set_table_font';

(**
 * @brief Turn on up-down bars for the chart.
 *
 * @param chart Pointer to a lxw_chart instance to be configured.
 *
 * The `%chart_set_up_down_bars()` function adds Up-Down bars to Line charts
 * to indicate the difference between the first and last data series:
 *
 * @code
 *     chart_set_up_down_bars(chart);
 * @endcode
 *
 * @image html chart_data_tools4.png
 *
 * Up-Down bars are only available in Line charts. By default Up-Down bars are
 * black and white like in the above example. To format the border or fill
 * of the bars see the `chart_set_up_down_bars_format()` function below.
 *)
procedure chart_set_up_down_bars(chart: Plxw_chart); cdecl;
  external bj name _PU + 'chart_set_up_down_bars';

(**
 * @brief Turn on up-down bars for the chart, with formatting.
 *
 * @param chart         Pointer to a lxw_chart instance to be configured.
 * @param up_bar_line   A #lxw_chart_line struct for the up-bar border.
 * @param up_bar_fill   A #lxw_chart_fill struct for the up-bar fill.
 * @param down_bar_line A #lxw_chart_line struct for the down-bar border.
 * @param down_bar_fill A #lxw_chart_fill struct for the down-bar fill.
 *
 * The `%chart_set_up_down_bars_format()` function adds Up-Down bars to Line
 * charts to indicate the difference between the first and last data series.
 * It also allows the up and down bars to be formatted:
 *
 * @code
 *     lxw_chart_line line      = {.color = LXW_COLOR_BLACK};
 *     lxw_chart_fill up_fill   = {.color = 0x00B050};
 *     lxw_chart_fill down_fill = {.color = LXW_COLOR_RED};
 *
 *     chart_set_up_down_bars_format(chart, &line, &up_fill, &line, &down_fill);
 * @endcode
 *
 * @image html chart_up_down_bars.png
 *
 * Up-Down bars are only available in Line charts.
 * For more format information  see @ref chart_lines and @ref chart_fills.
 *)
procedure chart_set_up_down_bars_format(chart: Plxw_chart; up_bar_line: Plxw_chart_line; up_bar_fill: Plxw_chart_fill; down_bar_line: Plxw_chart_line; down_bar_fill: Plxw_chart_fill); cdecl;
  external bj name _PU + 'chart_set_up_down_bars_format';

(**
 * @brief Turn on and format Drop Lines for a chart.
 *
 * @param chart Pointer to a lxw_chart instance to be configured.
 * @param line  A #lxw_chart_line struct.
 *
 * The `%chart_set_drop_lines()` function adds Drop Lines to charts to
 * show the Category value of points in the data:
 *
 * @code
 *     chart_set_drop_lines(chart, NULL);
 * @endcode
 *
 * @image html chart_data_tools6.png
 *
 * It is possible to format the Drop Line line properties if required:
 *
 * @code
 *     lxw_chart_line line = {.color     = LXW_COLOR_RED,
 *                            .dash_type = LXW_CHART_LINE_DASH_SQUARE_DOT};
 *
 *     chart_set_drop_lines(chart, &line);
 * @endcode
 *
 * Drop Lines are only available in Line and Area charts.
 * For more format information see @ref chart_lines.
 *)
procedure chart_set_drop_lines(chart: Plxw_chart; line: Plxw_chart_line); cdecl;
  external bj name _PU + 'chart_set_drop_lines';

(**
 * @brief Turn on and format high-low Lines for a chart.
 *
 * @param chart Pointer to a lxw_chart instance to be configured.
 * @param line  A #lxw_chart_line struct.
 *
 * The `%chart_set_high_low_lines()` function adds High-Low Lines to charts
 * to show the Category value of points in the data:
 *
 * @code
 *     chart_set_high_low_lines(chart, NULL);
 * @endcode
 *
 * @image html chart_data_tools5.png
 *
 * It is possible to format the High-Low Line line properties if required:
 *
 * @code
 *     lxw_chart_line line = {.color     = LXW_COLOR_RED,
 *                            .dash_type = LXW_CHART_LINE_DASH_SQUARE_DOT};
 *
 *     chart_set_high_low_lines(chart, &line);
 * @endcode
 *
 * High-Low Lines are only available in Line charts.
 * For more format information see @ref chart_lines.
 *)
procedure chart_set_high_low_lines(chart: Plxw_chart; line: Plxw_chart_line); cdecl;
  external bj name _PU + 'chart_set_high_low_lines';

(**
 * @brief Set the overlap between series in a Bar/Column chart.
 *
 * @param chart   Pointer to a lxw_chart instance to be configured.
 * @param overlap The overlap between the series. -100 to 100.
 *
 * The `%chart_set_series_overlap()` function sets the overlap between series
 * in Bar and Column charts.
 *
 * @code
 *     chart_set_series_overlap(chart, -50);
 * @endcode
 *
 * @image html chart_overlap.png
 *
 * The overlap value must be in the range `0 <= overlap <= 500`.
 * The default value is 0.
 *
 * This option is only available for Bar/Column charts.
 *)
procedure chart_set_series_overlap(chart: Plxw_chart; overlap: Int8); cdecl;
  external bj name _PU + 'chart_set_series_overlap';

(**
 * @brief Set the gap between series in a Bar/Column chart.
 *
 * @param chart Pointer to a lxw_chart instance to be configured.
 * @param gap   The gap between the series.  0 to 500.
 *
 * The `%chart_set_series_gap()` function sets the gap between series in
 * Bar and Column charts.
 *
 * @code
 *     chart_set_series_gap(chart, 400);
 * @endcode
 *
 * @image html chart_gap.png
 *
 * The gap value must be in the range `0 <= gap <= 500`. The default value
 * is 150.
 *
 * This option is only available for Bar/Column charts.
 *)
procedure chart_set_series_gap(chart: Plxw_chart; gap: UInt16); cdecl;
  external bj name _PU + 'chart_set_series_gap';

(**
 * @brief Set the option for displaying blank data in a chart.
 *
 * @param chart    Pointer to a lxw_chart instance to be configured.
 * @param option The display option. A #lxw_chart_blank option.
 *
 * The `%chart_show_blanks_as()` function controls how blank data is displayed
 * in a chart:
 *
 * @code
 *     chart_show_blanks_as(chart, LXW_CHART_BLANKS_AS_CONNECTED);
 * @endcode
 *
 * The `option` parameter can have one of the following values:
 *
 * - #LXW_CHART_BLANKS_AS_GAP: Show empty chart cells as gaps in the data.
 *   This is the default option for Excel charts.
 * - #LXW_CHART_BLANKS_AS_ZERO: Show empty chart cells as zeros.
 * - #LXW_CHART_BLANKS_AS_CONNECTED: Show empty chart cells as connected.
 *   Only for charts with lines.
 *)
procedure chart_show_blanks_as(chart: Plxw_chart; option: UInt8); cdecl;
  external bj name _PU + 'chart_show_blanks_as';

(**
 * @brief Display data on charts from hidden rows or columns.
 *
 * @param chart Pointer to a lxw_chart instance to be configured.
 *
 * Display data that is in hidden rows or columns on the chart:
 *
 * @code
 *     chart_show_hidden_data(chart);
 * @endcode
 *)
procedure chart_show_hidden_data(chart: Plxw_chart); cdecl;
  external bj name _PU + 'chart_show_hidden_data';

(**
 * @brief Set the Pie/Doughnut chart rotation.
 *
 * @param chart    Pointer to a lxw_chart instance to be configured.
 * @param rotation The angle of rotation.
 *
 * The `chart_set_rotation()` function is used to set the rotation of the
 * first segment of a Pie/Doughnut chart. This has the effect of rotating
 * the entire chart:
 *
 * @code
 *     chart_set_rotation(chart, 28);
 * @endcode
 *
 * The angle of rotation must be in the range `0 <= rotation <= 360`.
 *
 * This option is only available for Pie/Doughnut charts.
 *
 *)
procedure chart_set_rotation(chart: Plxw_chart; rotation: UInt16); cdecl;
  external bj name _PU + 'chart_set_rotation';

(**
 * @brief Set the Doughnut chart hole size.
 *
 * @param chart Pointer to a lxw_chart instance to be configured.
 * @param size  The hole size as a percentage.
 *
 * The `chart_set_hole_size()` function is used to set the hole size of a
 * Doughnut chart:
 *
 * @code
 *     chart_set_hole_size(chart, 33);
 * @endcode
 *
 * The hole size must be in the range `10 <= size <= 90`.
 *
 * This option is only available for Doughnut charts.
 *
 *)
procedure chart_set_hole_size(chart: Plxw_chart; size: UInt8); cdecl;
  external bj name _PU + 'chart_set_hole_size';

function lxw_chart_add_data_cache(range: Plxw_series_range; data: PUInt8; rows: UInt16; cols: UInt8; col: UInt8): lxw_error; cdecl;
  external bj name _PU + 'lxw_chart_add_data_cache';

function lxw_drawing_new(): Plxw_drawing; cdecl;
  external bj name _PU + 'lxw_drawing_new';

procedure lxw_drawing_free(drawing: Plxw_drawing); cdecl;
  external bj name _PU + 'lxw_drawing_free';

procedure lxw_drawing_assemble_xml_file(self: Plxw_drawing); cdecl;
  external bj name _PU + 'lxw_drawing_assemble_xml_file';

procedure lxw_free_drawing_object(drawing_object: Plxw_drawing_object); cdecl;
  external bj name _PU + 'lxw_free_drawing_object';

procedure lxw_add_drawing_object(drawing: Plxw_drawing; drawing_object: Plxw_drawing_object); cdecl;
  external bj name _PU + 'lxw_add_drawing_object';

function lxw_styles_new(): Plxw_styles; cdecl;
  external bj name _PU + 'lxw_styles_new';

procedure lxw_styles_free(styles: Plxw_styles); cdecl;
  external bj name _PU + 'lxw_styles_free';

procedure lxw_styles_assemble_xml_file(self: Plxw_styles); cdecl;
  external bj name _PU + 'lxw_styles_assemble_xml_file';

procedure lxw_styles_write_string_fragment(self: Plxw_styles; const astring: PUTF8Char); cdecl;
  external bj name _PU + 'lxw_styles_write_string_fragment';

procedure lxw_styles_write_rich_font(styles: Plxw_styles; format: Plxw_format); cdecl;
  external bj name _PU + 'lxw_styles_write_rich_font';

function lxw_new_attribute_str(const key: PUTF8Char; const value: PUTF8Char): Pxml_attribute; cdecl;
  external bj name _PU + 'lxw_new_attribute_str';

function lxw_new_attribute_int(const key: PUTF8Char; value: Int32): Pxml_attribute; cdecl;
  external bj name _PU + 'lxw_new_attribute_int';

function lxw_new_attribute_dbl(const key: PUTF8Char; value: Double): Pxml_attribute; cdecl;
  external bj name _PU + 'lxw_new_attribute_dbl';

(**
 * Create the XML declaration in an XML file.
 *
 * @param xmlfile A FILE pointer to the output XML file.
 *)
procedure lxw_xml_declaration(xmlfile: PPointer); cdecl;
  external bj name _PU + 'lxw_xml_declaration';

(**
 * Write an XML start tag with optional attributes.
 *
 * @param xmlfile    A FILE pointer to the output XML file.
 * @param tag        The XML tag to write.
 * @param attributes An optional list of attributes to add to the tag.
 *)
procedure lxw_xml_start_tag(xmlfile: PPointer; const tag: PUTF8Char; attributes: Pxml_attribute_list); cdecl;
  external bj name _PU + 'lxw_xml_start_tag';

(**
 * Write an XML start tag with optional un-encoded attributes.
 * This is a minor optimization for attributes that don't need encoding.
 *
 * @param xmlfile    A FILE pointer to the output XML file.
 * @param tag        The XML tag to write.
 * @param attributes An optional list of attributes to add to the tag.
 *)
procedure lxw_xml_start_tag_unencoded(xmlfile: PPointer; const tag: PUTF8Char; attributes: Pxml_attribute_list); cdecl;
  external bj name _PU + 'lxw_xml_start_tag_unencoded';

(**
 * Write an XML end tag.
 *
 * @param xmlfile    A FILE pointer to the output XML file.
 * @param tag        The XML tag to write.
 *)
procedure lxw_xml_end_tag(xmlfile: PPointer; const tag: PUTF8Char); cdecl;
  external bj name _PU + 'lxw_xml_end_tag';

(**
 * Write an XML empty tag with optional attributes.
 *
 * @param xmlfile    A FILE pointer to the output XML file.
 * @param tag        The XML tag to write.
 * @param attributes An optional list of attributes to add to the tag.
 *)
procedure lxw_xml_empty_tag(xmlfile: PPointer; const tag: PUTF8Char; attributes: Pxml_attribute_list); cdecl;
  external bj name _PU + 'lxw_xml_empty_tag';

(**
 * Write an XML empty tag with optional un-encoded attributes.
 * This is a minor optimization for attributes that don't need encoding.
 *
 * @param xmlfile    A FILE pointer to the output XML file.
 * @param tag        The XML tag to write.
 * @param attributes An optional list of attributes to add to the tag.
 *)
procedure lxw_xml_empty_tag_unencoded(xmlfile: PPointer; const tag: PUTF8Char; attributes: Pxml_attribute_list); cdecl;
  external bj name _PU + 'lxw_xml_empty_tag_unencoded';

(**
 * Write an XML element containing data and optional attributes.
 *
 * @param xmlfile    A FILE pointer to the output XML file.
 * @param tag        The XML tag to write.
 * @param data       The data section of the XML element.
 * @param attributes An optional list of attributes to add to the tag.
 *)
procedure lxw_xml_data_element(xmlfile: PPointer; const tag: PUTF8Char; const data: PUTF8Char; attributes: Pxml_attribute_list); cdecl;
  external bj name _PU + 'lxw_xml_data_element';

procedure lxw_xml_rich_si_element(xmlfile: PPointer; const astring: PUTF8Char); cdecl;
  external bj name _PU + 'lxw_xml_rich_si_element';

function lxw_has_control_characters(const astring: PUTF8Char): UInt8; cdecl;
  external bj name _PU + 'lxw_has_control_characters';

function lxw_escape_control_characters(const astring: PUTF8Char): PUTF8Char; cdecl;
  external bj name _PU + 'lxw_escape_control_characters';

function lxw_escape_url_characters(const astring: PUTF8Char; escape_hash: UInt8): PUTF8Char; cdecl;
  external bj name _PU + 'lxw_escape_url_characters';

function lxw_escape_data(const data: PUTF8Char): PUTF8Char; cdecl;
  external bj name _PU + 'lxw_escape_data';

(**
 * @brief Retrieve the library version.
 *
 * @return The "X.Y.Z" version string.
 *
 * Get the library version as a "X.Y.Z" version string
 *
 *  @code
 *      printf("Libxlsxwriter version = %s\n", lxw_version());
 *  @endcode
 *
 *)
function lxw_version(): PUTF8Char; cdecl;
  external bj name _PU + 'lxw_version';

(**
 * @brief Retrieve the library version ID.
 *
 * @return The version ID.
 *
 * Get the library version such as "X.Y.Z" as a XYZ integer.
 *
 *  @code
 *      printf("Libxlsxwriter version id = %d\n", lxw_version_id());
 *  @endcode
 *
 *)
function lxw_version_id(): UInt16; cdecl;
  external bj name _PU + 'lxw_version_id';

(**
 * @brief Converts a libxlsxwriter error number to a string.
 *
 * The `%lxw_strerror` function converts a libxlsxwriter error number defined
 * by #lxw_error to a pointer to a string description of the error.
 * Similar to the standard library strerror(3) function.
 *
 * For example:
 *
 * @code
 *     lxw_error error = workbook_close(workbook);
 *
 *     if (error)
 *         printf("Error in workbook_close().\n"
 *                "Error %d = %s\n", error, lxw_strerror(error));
 * @endcode
 *
 * This would produce output like the following if the target file wasn't
 * writable:
 *
 *     Error in workbook_close().
 *     Error 2 = Error creating output xlsx file. Usually a permissions error.
 *
 * @param error_num The error number returned by a libxlsxwriter function.
 *
 * @return A pointer to a statically allocated string. Do not free.
 *)
function lxw_strerror(error_num: lxw_error): PUTF8Char; cdecl;
  external bj name _PU + 'lxw_strerror';

function lxw_quote_sheetname(const str: PUTF8Char): PUTF8Char; cdecl;
  external bj name _PU + 'lxw_quote_sheetname';

procedure lxw_col_to_name(col_name: PUTF8Char; col_num: lxw_col_t; aabsolute: UInt8); cdecl;
  external bj name _PU + 'lxw_col_to_name';

procedure lxw_rowcol_to_cell(cell_name: PUTF8Char; row: lxw_row_t; col: lxw_col_t); cdecl;
  external bj name _PU + 'lxw_rowcol_to_cell';

procedure lxw_rowcol_to_cell_abs(cell_name: PUTF8Char; row: lxw_row_t; col: lxw_col_t; abs_row: UInt8; abs_col: UInt8); cdecl;
  external bj name _PU + 'lxw_rowcol_to_cell_abs';

procedure lxw_rowcol_to_range(range: PUTF8Char; first_row: lxw_row_t; first_col: lxw_col_t; last_row: lxw_row_t; last_col: lxw_col_t); cdecl;
  external bj name _PU + 'lxw_rowcol_to_range';

procedure lxw_rowcol_to_range_abs(range: PUTF8Char; first_row: lxw_row_t; first_col: lxw_col_t; last_row: lxw_row_t; last_col: lxw_col_t); cdecl;
  external bj name _PU + 'lxw_rowcol_to_range_abs';

procedure lxw_rowcol_to_formula_abs(formula: PUTF8Char; const sheetname: PUTF8Char; first_row: lxw_row_t; first_col: lxw_col_t; last_row: lxw_row_t; last_col: lxw_col_t); cdecl;
  external bj name _PU + 'lxw_rowcol_to_formula_abs';

function lxw_name_to_row(const row_str: PUTF8Char): UInt32; cdecl;
  external bj name _PU + 'lxw_name_to_row';

function lxw_name_to_col(const col_str: PUTF8Char): UInt16; cdecl;
  external bj name _PU + 'lxw_name_to_col';

function lxw_name_to_row_2(const row_str: PUTF8Char): UInt32; cdecl;
  external bj name _PU + 'lxw_name_to_row_2';

function lxw_name_to_col_2(const col_str: PUTF8Char): UInt16; cdecl;
  external bj name _PU + 'lxw_name_to_col_2';

(**
 * @brief Converts a #lxw_datetime to an Excel datetime number.
 *
 * @param datetime A pointer to a #lxw_datetime struct.
 *
 * @return A double representing an Excel datetime.
 *
 * The `%lxw_datetime_to_excel_datetime()` function converts a datetime in
 * #lxw_datetime to an Excel datetime number:
 *
 * @code
 *     lxw_datetime datetime = {2013, 2, 28, 12, 0, 0.0};
 *
 *     double excel_datetime = lxw_datetime_to_excel_date(&datetime);
 * @endcode
 *
 * See @ref working_with_dates for more details on the Excel datetime format.
 *)
function lxw_datetime_to_excel_datetime(datetime: Plxw_datetime): Double; cdecl;
  external bj name _PU + 'lxw_datetime_to_excel_datetime';

function lxw_datetime_to_excel_date_with_epoch(datetime: Plxw_datetime; use_1904_epoch: UInt8): Double; cdecl;
  external bj name _PU + 'lxw_datetime_to_excel_date_with_epoch';

(**
 * @brief Validate a #lxw_datetime struct.
 *
 * Validates a #lxw_datetime struct to ensure its fields are within acceptable
 * ranges for Excel dates and times.
 *
 * The members of the #lxw_datetime struct and the range of their values are:
 *
 * Member   | Value
 * -------- | -----------
 * year     | 1900 - 9999
 * month    | 1 - 12
 * day      | 1 - 31
 * hour     | 0 - 23
 * min      | 0 - 59
 * sec      | 0 - 59.999
 *
 * @param datetime A pointer to a #lxw_datetime struct.
 *
 * @return A #lxw_error code. Either #LXW_NO_ERROR or
 *         #LXW_ERROR_DATETIME_VALIDATION if a field is out of range.
 *)
function lxw_datetime_validate(datetime: Plxw_datetime): lxw_error; cdecl;
  external bj name _PU + 'lxw_datetime_validate';

(**
 * @brief Converts a unix datetime to an Excel datetime number.
 *
 * @param unixtime Unix time (seconds since 1970-01-01)
 *
 * @return A double representing an Excel datetime.
 *
 * The `%lxw_unixtime_to_excel_date()` function converts a unix datetime to
 * an Excel datetime number:
 *
 * @code
 *     double excel_datetime = lxw_unixtime_to_excel_date(946684800);
 * @endcode
 *
 * See @ref working_with_dates for more details.
 *)
function lxw_unixtime_to_excel_date(unixtime: Int64): Double; cdecl;
  external bj name _PU + 'lxw_unixtime_to_excel_date';

(**
 * @brief Converts a #lxw_datetime to an Excel datetime number with 1900/1904
 * epoch.
 *
 * This function is similar to `lxw_datetime_to_excel_datetime()` but it allows
 * you to specify whether to use the 1900 or 1904 epoch. See also the
 * `workbook_use_1904_epoch()` function.
 *
 * @param datetime A pointer to a #lxw_datetime struct.
 * @param use_1904_epoch A flag to indicate whether to use the 1904 epoch (true)
 *        or the 1900 epoch (false).
 *
 *)
function lxw_unixtime_to_excel_date_with_epoch(unixtime: Int64; use_1904_epoch: UInt8): Double; cdecl;
  external bj name _PU + 'lxw_unixtime_to_excel_date_with_epoch';

function lxw_strdup(const str: PUTF8Char): PUTF8Char; cdecl;
  external bj name _PU + 'lxw_strdup';

function lxw_strdup_formula(const formula: PUTF8Char): PUTF8Char; cdecl;
  external bj name _PU + 'lxw_strdup_formula';

function lxw_utf8_strlen(const str: PUTF8Char): NativeUInt; cdecl;
  external bj name _PU + 'lxw_utf8_strlen';

procedure lxw_str_tolower(str: PUTF8Char); cdecl;
  external bj name _PU + 'lxw_str_tolower';

function lxw_str_is_empty(const str: PUTF8Char): UInt8; cdecl;
  external bj name _PU + 'lxw_str_is_empty';

function lxw_tmpfile(const tmpdir: PUTF8Char): PPointer; cdecl;
  external bj name _PU + 'lxw_tmpfile';

function lxw_get_filehandle(buf: PPUTF8Char; size: PNativeUInt; const tmpdir: PUTF8Char): PPointer; cdecl;
  external bj name _PU + 'lxw_get_filehandle';

function lxw_fopen(const filename: PUTF8Char; const mode: PUTF8Char): PPointer; cdecl;
  external bj name _PU + 'lxw_fopen';

function lxw_hash_password(const password: PUTF8Char): UInt16; cdecl;
  external bj name _PU + 'lxw_hash_password';

function lxw_relationships_new(): Plxw_relationships; cdecl;
  external bj name _PU + 'lxw_relationships_new';

procedure lxw_free_relationships(relationships: Plxw_relationships); cdecl;
  external bj name _PU + 'lxw_free_relationships';

procedure lxw_relationships_assemble_xml_file(self: Plxw_relationships); cdecl;
  external bj name _PU + 'lxw_relationships_assemble_xml_file';

procedure lxw_add_document_relationship(self: Plxw_relationships; const atype: PUTF8Char; const target: PUTF8Char); cdecl;
  external bj name _PU + 'lxw_add_document_relationship';

procedure lxw_add_package_relationship(self: Plxw_relationships; const atype: PUTF8Char; const target: PUTF8Char); cdecl;
  external bj name _PU + 'lxw_add_package_relationship';

procedure lxw_add_ms_package_relationship(self: Plxw_relationships; const atype: PUTF8Char; const target: PUTF8Char); cdecl;
  external bj name _PU + 'lxw_add_ms_package_relationship';

procedure lxw_add_worksheet_relationship(self: Plxw_relationships; const atype: PUTF8Char; const target: PUTF8Char; const target_mode: PUTF8Char); cdecl;
  external bj name _PU + 'lxw_add_worksheet_relationship';

procedure lxw_add_rich_value_relationship(self: Plxw_relationships); cdecl;
  external bj name _PU + 'lxw_add_rich_value_relationship';

(**
 * @brief Write a number to a worksheet cell.
 *
 * @param worksheet Pointer to a lxw_worksheet instance to be updated.
 * @param row       The zero indexed row number.
 * @param col       The zero indexed column number.
 * @param number    The number to write to the cell.
 * @param format    A pointer to a Format instance or NULL.
 *
 * @return A #lxw_error code.
 *
 * The `worksheet_write_number()` function writes numeric types to the cell
 * specified by `row` and `column`:
 *
 * @code
 *     worksheet_write_number(worksheet, 0, 0, 123456, NULL);
 *     worksheet_write_number(worksheet, 1, 0, 2.3451, NULL);
 * @endcode
 *
 * @image html write_number01.png
 *
 * The native data type for all numbers in Excel is a IEEE-754 64-bit
 * double-precision floating point, which is also the default type used by
 * `%worksheet_write_number`.
 *
 * The `format` parameter is used to apply formatting to the cell. This
 * parameter can be `NULL` to indicate no formatting or it can be a
 * @ref format.h "Format" object.
 *
 * @code
 *     lxw_format *format = workbook_add_format(workbook);
 *     format_set_num_format(format, "$#,##0.00");
 *
 *     worksheet_write_number(worksheet, 0, 0, 1234.567, format);
 * @endcode
 *
 * @image html write_number02.png
 *
 * @note Excel doesn't support `NaN`, `Inf` or `-Inf` as a number value. If
 * you are writing data that contains these values then your application
 * should convert them to a string or handle them in some other way.
 *
 *)
function worksheet_write_number(worksheet: Plxw_worksheet; row: lxw_row_t; col: lxw_col_t; number: Double; format: Plxw_format): lxw_error; cdecl;
  external bj name _PU + 'worksheet_write_number';

(**
 * @brief Write a string to a worksheet cell.
 *
 * @param worksheet Pointer to a lxw_worksheet instance to be updated.
 * @param row       The zero indexed row number.
 * @param col       The zero indexed column number.
 * @param string    String to write to cell.
 * @param format    A pointer to a Format instance or NULL.
 *
 * @return A #lxw_error code.
 *
 * The `%worksheet_write_string()` function writes a string to the cell
 * specified by `row` and `column`:
 *
 * @code
 *     worksheet_write_string(worksheet, 0, 0, "This phrase is English!", NULL);
 * @endcode
 *
 * @image html write_string01.png
 *
 * The `format` parameter is used to apply formatting to the cell. This
 * parameter can be `NULL` to indicate no formatting or it can be a
 * @ref format.h "Format" object:
 *
 * @code
 *     lxw_format *format = workbook_add_format(workbook);
 *     format_set_bold(format);
 *
 *     worksheet_write_string(worksheet, 0, 0, "This phrase is Bold!", format);
 * @endcode
 *
 * @image html write_string02.png
 *
 * Unicode strings are supported in UTF-8 encoding. This generally requires
 * that your source file is UTF-8 encoded or that the data has been read from
 * a UTF-8 source:
 *
 * @code
 *    worksheet_write_string(worksheet, 0, 0, "   !", NULL);
 * @endcode
 *
 * @image html write_string03.png
 *
 *)
function worksheet_write_string(worksheet: Plxw_worksheet; row: lxw_row_t; col: lxw_col_t; const astring: PUTF8Char; format: Plxw_format): lxw_error; cdecl;
  external bj name _PU + 'worksheet_write_string';

(**
 * @brief Write a formula to a worksheet cell.
 *
 * @param worksheet Pointer to a lxw_worksheet instance to be updated.
 * @param row       The zero indexed row number.
 * @param col       The zero indexed column number.
 * @param formula   Formula string to write to cell.
 * @param format    A pointer to a Format instance or NULL.
 *
 * @return A #lxw_error code.
 *
 * The `%worksheet_write_formula()` function writes a formula or function to
 * the cell specified by `row` and `column`:
 *
 * @code
 *  worksheet_write_formula(worksheet, 0, 0, "=B3 + 6",                    NULL);
 *  worksheet_write_formula(worksheet, 1, 0, "=SIN(PI()/4)",               NULL);
 *  worksheet_write_formula(worksheet, 2, 0, "=SUM(A1:A2)",                NULL);
 *  worksheet_write_formula(worksheet, 3, 0, "=IF(A3>1,\"Yes\", \"No\")",  NULL);
 *  worksheet_write_formula(worksheet, 4, 0, "=AVERAGE(1, 2, 3, 4)",       NULL);
 *  worksheet_write_formula(worksheet, 5, 0, "=DATEVALUE(\"1-Jan-2013\")", NULL);
 * @endcode
 *
 * @image html write_formula01.png
 *
 * The `format` parameter is used to apply formatting to the cell. This
 * parameter can be `NULL` to indicate no formatting or it can be a
 * @ref format.h "Format" object.
 *
 * Libxlsxwriter doesn't calculate the value of a formula and instead stores a
 * default value of `0`. The correct formula result is displayed in Excel, as
 * shown in the example above, since it recalculates the formulas when it loads
 * the file. For cases where this is an issue see the
 * `worksheet_write_formula_num()` function and the discussion in that section.
 *
 * Formulas must be written with the US style separator/range operator which
 * is a comma (not semi-colon). Therefore a formula with multiple values
 * should be written as follows:
 *
 * @code
 *     // OK.
 *     worksheet_write_formula(worksheet, 0, 0, "=SUM(1, 2, 3)", NULL);
 *
 *     // NO. Error on load.
 *     worksheet_write_formula(worksheet, 1, 0, "=SUM(1; 2; 3)", NULL);
 * @endcode
 *
 * See also @ref working_with_formulas.
 *)
function worksheet_write_formula(worksheet: Plxw_worksheet; row: lxw_row_t; col: lxw_col_t; const formula: PUTF8Char; format: Plxw_format): lxw_error; cdecl;
  external bj name _PU + 'worksheet_write_formula';

(**
 * @brief Write an array formula to a worksheet cell.
 *
 * @param worksheet Pointer to a lxw_worksheet instance to be updated.
 * @param first_row The first row of the range. (All zero indexed.)
 * @param first_col The first column of the range.
 * @param last_row  The last row of the range.
 * @param last_col  The last col of the range.
 * @param formula   Array formula to write to cell.
 * @param format    A pointer to a Format instance or NULL.
 *
 * @return A #lxw_error code.
 *
 * The `%worksheet_write_array_formula()` function writes an array formula to
 * a cell range. In Excel an array formula is a formula that performs a
 * calculation on a set of values.
 *
 * In Excel an array formula is indicated by a pair of braces around the
 * formula: `{=SUM(A1:B1*A2:B2)}`.
 *
 * Array formulas can return a single value or a range or values. For array
 * formulas that return a range of values you must specify the range that the
 * return values will be written to. This is why this function has `first_`
 * and `last_` row/column parameters. The RANGE() macro can also be used to
 * specify the range:
 *
 * @code
 *     worksheet_write_array_formula(worksheet, 4, 0, 6, 0,     "{=TREND(C5:C7,B5:B7)}", NULL);
 *
 *     // Same as above using the RANGE() macro.
 *     worksheet_write_array_formula(worksheet, RANGE("A5:A7"), "{=TREND(C5:C7,B5:B7)}", NULL);
 * @endcode
 *
 * If the array formula returns a single value then the `first_` and `last_`
 * parameters should be the same:
 *
 * @code
 *     worksheet_write_array_formula(worksheet, 1, 0, 1, 0,     "{=SUM(B1:C1*B2:C2)}", NULL);
 *     worksheet_write_array_formula(worksheet, RANGE("A2:A2"), "{=SUM(B1:C1*B2:C2)}", NULL);
 * @endcode
 *
 *)
function worksheet_write_array_formula(worksheet: Plxw_worksheet; first_row: lxw_row_t; first_col: lxw_col_t; last_row: lxw_row_t; last_col: lxw_col_t; const formula: PUTF8Char; format: Plxw_format): lxw_error; cdecl;
  external bj name _PU + 'worksheet_write_array_formula';

(**
 * @brief Write an Excel 365 dynamic array formula to a worksheet range.
 *
 * @param worksheet Pointer to a lxw_worksheet instance to be updated.
 * @param first_row The first row of the range. (All zero indexed.)
 * @param first_col The first column of the range.
 * @param last_row  The last row of the range.
 * @param last_col  The last col of the range.
 * @param formula   Dynamic Array formula to write to cell.
 * @param format    A pointer to a Format instance or NULL.
 *
 * @return A #lxw_error code.
 *
 *
 * The `%worksheet_write_dynamic_array_formula()` function writes an Excel 365
 * dynamic array formula to a cell range. Some examples of functions that
 * return dynamic arrays are:
 *
 * - `FILTER`
 * - `RANDARRAY`
 * - `SEQUENCE`
 * - `SORTBY`
 * - `SORT`
 * - `UNIQUE`
 * - `XLOOKUP`
 * - `XMATCH`
 *
 * Dynamic array formulas and their usage in libxlsxwriter is explained in
 * detail @ref ww_formulas_dynamic_arrays. The following is a example usage:
 *
 * @code
 *     worksheet_write_dynamic_array_formula(worksheet, 1, 5, 1, 5,
 *                                           "=_xlfn._xlws.FILTER(A1:D17,C1:C17=K2)",
 *                                           NULL);
 * @endcode
 *
 * This formula gives the results shown in the image below.
 *
 * @image html dynamic_arrays02.png
 *
 * The need for the `_xlfn._xlws.` prefix in the formula is explained in @ref
 * ww_formulas_future.
 *)
function worksheet_write_dynamic_array_formula(worksheet: Plxw_worksheet; first_row: lxw_row_t; first_col: lxw_col_t; last_row: lxw_row_t; last_col: lxw_col_t; const formula: PUTF8Char; format: Plxw_format): lxw_error; cdecl;
  external bj name _PU + 'worksheet_write_dynamic_array_formula';

(**
 * @brief Write an Excel 365 dynamic array formula to a worksheet cell.
 *
 * @param worksheet Pointer to a lxw_worksheet instance to be updated.
 * @param row       The zero indexed row number.
 * @param col       The zero indexed column number.
 * @param formula   Formula string to write to cell.
 * @param format    A pointer to a Format instance or NULL.
 *
 * @return A #lxw_error code.
 *
 * The `%worksheet_write_dynamic_formula()` function is similar to the
 * `worksheet_write_dynamic_array_formula()` function, shown above, except
 * that it writes a dynamic array formula to a single cell, rather than a
 * range. This is a syntactic shortcut since the array range isn't generally
 * known for a dynamic range and specifying the initial cell is sufficient for
 * Excel, as shown in the example below:
 *
 * @code
 *     worksheet_write_dynamic_formula(worksheet, 7, 1,
 *                                     "=_xlfn._xlws.SORT(_xlfn.UNIQUE(B2:B17))",
 *                                     NULL);
 * @endcode
 *
 * This formula gives the following result:
 *
 * @image html dynamic_arrays01.png
 *
 * The need for the `_xlfn.` and `_xlfn._xlws.` prefixes in the formula is
 * explained in @ref ww_formulas_future.
 *)
function worksheet_write_dynamic_formula(worksheet: Plxw_worksheet; row: lxw_row_t; col: lxw_col_t; const formula: PUTF8Char; format: Plxw_format): lxw_error; cdecl;
  external bj name _PU + 'worksheet_write_dynamic_formula';

function worksheet_write_array_formula_num(worksheet: Plxw_worksheet; first_row: lxw_row_t; first_col: lxw_col_t; last_row: lxw_row_t; last_col: lxw_col_t; const formula: PUTF8Char; format: Plxw_format; result: Double): lxw_error; cdecl;
  external bj name _PU + 'worksheet_write_array_formula_num';

function worksheet_write_dynamic_array_formula_num(worksheet: Plxw_worksheet; first_row: lxw_row_t; first_col: lxw_col_t; last_row: lxw_row_t; last_col: lxw_col_t; const formula: PUTF8Char; format: Plxw_format; result: Double): lxw_error; cdecl;
  external bj name _PU + 'worksheet_write_dynamic_array_formula_num';

function worksheet_write_dynamic_formula_num(worksheet: Plxw_worksheet; row: lxw_row_t; col: lxw_col_t; const formula: PUTF8Char; format: Plxw_format; result: Double): lxw_error; cdecl;
  external bj name _PU + 'worksheet_write_dynamic_formula_num';

(**
 * @brief Write a date or time to a worksheet cell.
 *
 * @param worksheet Pointer to a lxw_worksheet instance to be updated.
 * @param row       The zero indexed row number.
 * @param col       The zero indexed column number.
 * @param datetime  The datetime to write to the cell.
 * @param format    A pointer to a Format instance or NULL.
 *
 * @return A #lxw_error code.
 *
 * The `%worksheet_write_datetime()` function can be used to write a date or
 * time to the cell specified by `row` and `column`:
 *
 * @dontinclude dates_and_times02.c
 * @skip include
 * @until num_format
 * @skip Feb
 * @until }
 *
 * The `format` parameter should be used to apply formatting to the cell using
 * a @ref format.h "Format" object as shown above. Without a date format the
 * datetime will appear as a number only.
 *
 * See @ref working_with_dates for more information about handling dates and
 * times in libxlsxwriter.
 *)
function worksheet_write_datetime(worksheet: Plxw_worksheet; row: lxw_row_t; col: lxw_col_t; datetime: Plxw_datetime; format: Plxw_format): lxw_error; cdecl;
  external bj name _PU + 'worksheet_write_datetime';

(**
 * @brief Write a Unix datetime to a worksheet cell.
 *
 * @param worksheet Pointer to a lxw_worksheet instance to be updated.
 * @param row       The zero indexed row number.
 * @param col       The zero indexed column number.
 * @param unixtime  The Unix datetime to write to the cell.
 * @param format    A pointer to a Format instance or NULL.
 *
 * @return A #lxw_error code.
 *
 * The `%worksheet_write_unixtime()` function can be used to write dates and
 * times in Unix date format to the cell specified by `row` and
 * `column`. [Unix Time](https://en.wikipedia.org/wiki/Unix_time) which is a
 * common integer time format. It is defined as the number of seconds since
 * the Unix epoch (1970-01-01 00:00 UTC). Negative values can also be used for
 * dates prior to 1970:
 *
 * @dontinclude dates_and_times03.c
 * @skip 1970
 * @until 2208988800
 *
 * The `format` parameter should be used to apply formatting to the cell using
 * a @ref format.h "Format" object as shown above. Without a date format the
 * datetime will appear as a number only.
 *
 * The output from this code sample is:
 *
 * @image html date_example03.png
 *
 * Unixtime is generally represented with a 32 bit `time_t` type which has a
 * range of approximately 1900-12-14 to 2038-01-19. To access the full Excel
 * date range of 1900-01-01 to 9999-12-31 this function uses a 64 bit
 * parameter.
 *
 * See @ref working_with_dates for more information about handling dates and
 * times in libxlsxwriter.
 *)
function worksheet_write_unixtime(worksheet: Plxw_worksheet; row: lxw_row_t; col: lxw_col_t; unixtime: Int64; format: Plxw_format): lxw_error; cdecl;
  external bj name _PU + 'worksheet_write_unixtime';

(**
 *
 * @param worksheet Pointer to a lxw_worksheet instance to be updated.
 * @param row       The zero indexed row number.
 * @param col       The zero indexed column number.
 * @param url       The url to write to the cell.
 * @param format    A pointer to a Format instance or NULL.
 *
 * @return A #lxw_error code.
 *
 *
 * The `%worksheet_write_url()` function is used to write a URL/hyperlink to a
 * worksheet cell specified by `row` and `column`.
 *
 * @code
 *     worksheet_write_url(worksheet, 0, 0, "http://libxlsxwriter.github.io", NULL);
 * @endcode
 *
 * @image html hyperlinks_short.png
 *
 * The `format` parameter is used to apply formatting to the cell. This
 * parameter can be `NULL`, in which case the default Excel blue underlined
 * hyperlink style will be used. If required a user defined @ref format.h
 * "Format" object can be used:
 * underline:
 *
 * @code
 *    lxw_format *url_format   = workbook_add_format(workbook);
 *
 *    format_set_underline (url_format, LXW_UNDERLINE_SINGLE);
 *    format_set_font_color(url_format, LXW_COLOR_RED);
 *
 * @endcode
 *
 * The usual web style URI's are supported: `%http://`, `%https://`, `%ftp://`
 * and `mailto:` :
 *
 * @code
 *     worksheet_write_url(worksheet, 0, 0, "ftp://www.python.org/",     NULL);
 *     worksheet_write_url(worksheet, 1, 0, "http://www.python.org/",    NULL);
 *     worksheet_write_url(worksheet, 2, 0, "https://www.python.org/",   NULL);
 *     worksheet_write_url(worksheet, 3, 0, "mailto:jmcnamara@cpan.org", NULL);
 *
 * @endcode
 *
 * An Excel hyperlink is comprised of two elements: the displayed string and
 * the non-displayed link. By default the displayed string is the same as the
 * link. However, it is possible to overwrite it with any other
 * `libxlsxwriter` type using the appropriate `worksheet_write_*()`
 * function. The most common case is to overwrite the displayed link text with
 * another string. To do this we must also match the default URL format using
 * `workbook_get_default_url_format()`:
 *
 * @code
 *     // Write a hyperlink with the default blue underline format.
 *     worksheet_write_url(worksheet, 2, 0, "http://libxlsxwriter.github.io", NULL);
 *
 *     // Get the default url format.
 *     lxw_format *url_format = workbook_get_default_url_format(workbook);
 *
 *     // Overwrite the hyperlink with a user defined string and default format.
 *     worksheet_write_string(worksheet, 2, 0, "Read the documentation.", url_format);
 * @endcode
 *
 * @image html hyperlinks_short2.png
 *
 * Two local URIs are supported: `internal:` and `external:`. These are used
 * for hyperlinks to internal worksheet references or external workbook and
 * worksheet references:
 *
 * @code
 *     worksheet_write_url(worksheet, 0, 0, "internal:Sheet2!A1",                NULL);
 *     worksheet_write_url(worksheet, 1, 0, "internal:Sheet2!B2",                NULL);
 *     worksheet_write_url(worksheet, 2, 0, "internal:Sheet2!A1:B2",             NULL);
 *     worksheet_write_url(worksheet, 3, 0, "internal:'Sales Data'!A1",          NULL);
 *     worksheet_write_url(worksheet, 4, 0, "external:c:\\temp\\foo.xlsx",       NULL);
 *     worksheet_write_url(worksheet, 5, 0, "external:c:\\foo.xlsx#Sheet2!A1",   NULL);
 *     worksheet_write_url(worksheet, 6, 0, "external:..\\foo.xlsx",             NULL);
 *     worksheet_write_url(worksheet, 7, 0, "external:..\\foo.xlsx#Sheet2!A1",   NULL);
 *     worksheet_write_url(worksheet, 8, 0, "external:\\\\NET\\share\\foo.xlsx", NULL);
 *
 * @endcode
 *
 * Worksheet references are typically of the form `Sheet1!A1`. You can also
 * link to a worksheet range using the standard Excel notation:
 * `Sheet1!A1:B2`.
 *
 * In external links the workbook and worksheet name must be separated by the
 * `#` character:
 *
 * @code
 *     worksheet_write_url(worksheet, 0, 0, "external:c:\\foo.xlsx#Sheet2!A1",   NULL);
 * @endcode
 *
 * You can also link to a named range in the target worksheet: For example say
 * you have a named range called `my_name` in the workbook `c:\temp\foo.xlsx`
 * you could link to it as follows:
 *
 * @code
 *     worksheet_write_url(worksheet, 0, 0, "external:c:\\temp\\foo.xlsx#my_name", NULL);
 *
 * @endcode
 *
 * Excel requires that worksheet names containing spaces or non alphanumeric
 * characters are single quoted as follows:
 *
 * @code
 *     worksheet_write_url(worksheet, 0, 0, "internal:'Sales Data'!A1", NULL);
 * @endcode
 *
 * Links to network files are also supported. Network files normally begin
 * with two back slashes as follows `\\NETWORK\etc`. In order to represent
 * this in a C string literal the backslashes should be escaped:
 * @code
 *     worksheet_write_url(worksheet, 0, 0, "external:\\\\NET\\share\\foo.xlsx", NULL);
 * @endcode
 *
 *
 * Alternatively, you can use Unix style forward slashes. These are
 * translated internally to backslashes:
 *
 * @code
 *     worksheet_write_url(worksheet, 0, 0, "external:c:/temp/foo.xlsx",     NULL);
 *     worksheet_write_url(worksheet, 1, 0, "external://NET/share/foo.xlsx", NULL);
 *
 * @endcode
 *
 *
 * **Note:**
 *
 *    libxlsxwriter will escape the following characters in URLs as required
 *    by Excel: `\s " < > \ [ ]  ^ { }`. Existing URL `%%xx` style escapes in
 *    the string are ignored to allow for user-escaped strings.
 *
 * **Note:**
 *
 *    The maximum allowable URL length in recent versions of Excel is 2079
 *    characters. In older versions of Excel (and libxlsxwriter <= 0.8.8) the
 *    limit was 255 characters.
 *)
function worksheet_write_url(worksheet: Plxw_worksheet; row: lxw_row_t; col: lxw_col_t; const url: PUTF8Char; format: Plxw_format): lxw_error; cdecl;
  external bj name _PU + 'worksheet_write_url';

function worksheet_write_url_opt(worksheet: Plxw_worksheet; row_num: lxw_row_t; col_num: lxw_col_t; const url: PUTF8Char; format: Plxw_format; const astring: PUTF8Char; const tooltip: PUTF8Char): lxw_error; cdecl;
  external bj name _PU + 'worksheet_write_url_opt';

(**
 * @brief Write a formatted boolean worksheet cell.
 *
 * @param worksheet Pointer to a lxw_worksheet instance to be updated.
 * @param row       The zero indexed row number.
 * @param col       The zero indexed column number.
 * @param value     The boolean value to write to the cell.
 * @param format    A pointer to a Format instance or NULL.
 *
 * @return A #lxw_error code.
 *
 * Write an Excel boolean to the cell specified by `row` and `column`:
 *
 * @code
 *     worksheet_write_boolean(worksheet, 2, 2, 0, my_format);
 * @endcode
 *
 *)
function worksheet_write_boolean(worksheet: Plxw_worksheet; row: lxw_row_t; col: lxw_col_t; value: Integer; format: Plxw_format): lxw_error; cdecl;
  external bj name _PU + 'worksheet_write_boolean';

(**
 * @brief Write a formatted blank worksheet cell.
 *
 * @param worksheet Pointer to a lxw_worksheet instance to be updated.
 * @param row       The zero indexed row number.
 * @param col       The zero indexed column number.
 * @param format    A pointer to a Format instance or NULL.
 *
 * @return A #lxw_error code.
 *
 * Write a blank cell specified by `row` and `column`:
 *
 * @code
 *     worksheet_write_blank(worksheet, 1, 1, border_format);
 * @endcode
 *
 * This function is used to add formatting to a cell which doesn't contain a
 * string or number value.
 *
 * Excel differentiates between an "Empty" cell and a "Blank" cell. An Empty
 * cell is a cell which doesn't contain data or formatting whilst a Blank cell
 * doesn't contain data but does contain formatting. Excel stores Blank cells
 * but ignores Empty cells.
 *
 * As such, if you write an empty cell without formatting it is ignored.
 *
 *)
function worksheet_write_blank(worksheet: Plxw_worksheet; row: lxw_row_t; col: lxw_col_t; format: Plxw_format): lxw_error; cdecl;
  external bj name _PU + 'worksheet_write_blank';

(**
 * @brief Write a formula to a worksheet cell with a user defined numeric
 *        result.
 *
 * @param worksheet Pointer to a lxw_worksheet instance to be updated.
 * @param row       The zero indexed row number.
 * @param col       The zero indexed column number.
 * @param formula   Formula string to write to cell.
 * @param format    A pointer to a Format instance or NULL.
 * @param result    A user defined numeric result for the formula.
 *
 * @return A #lxw_error code.
 *
 * The `%worksheet_write_formula_num()` function writes a formula or Excel
 * function to the cell specified by `row` and `column` with a user defined
 * numeric result:
 *
 * @code
 *     // Required as a workaround only.
 *     worksheet_write_formula_num(worksheet, 0, 0, "=1 + 2", NULL, 3);
 * @endcode
 *
 * Libxlsxwriter doesn't calculate the value of a formula and instead stores
 * the value `0` as the formula result. It then sets a global flag in the XLSX
 * file to say that all formulas and functions should be recalculated when the
 * file is opened.
 *
 * This is the method recommended in the Excel documentation and in general it
 * works fine with spreadsheet applications.
 *
 * However, applications that don't have a facility to calculate formulas,
 * such as Excel Viewer, or some mobile applications will only display the `0`
 * results.
 *
 * If required, the `%worksheet_write_formula_num()` function can be used to
 * specify a formula and its result.
 *
 * This function is rarely required and is only provided for compatibility
 * with some third party applications. For most applications the
 * worksheet_write_formula() function is the recommended way of writing
 * formulas.
 *
 * See also @ref working_with_formulas.
 *)
function worksheet_write_formula_num(worksheet: Plxw_worksheet; row: lxw_row_t; col: lxw_col_t; const formula: PUTF8Char; format: Plxw_format; result: Double): lxw_error; cdecl;
  external bj name _PU + 'worksheet_write_formula_num';

(**
 * @brief Write a formula to a worksheet cell with a user defined string
 *        result.
 *
 * @param worksheet Pointer to a lxw_worksheet instance to be updated.
 * @param row       The zero indexed row number.
 * @param col       The zero indexed column number.
 * @param formula   Formula string to write to cell.
 * @param format    A pointer to a Format instance or NULL.
 * @param result    A user defined string result for the formula.
 *
 * @return A #lxw_error code.
 *
 * The `%worksheet_write_formula_str()` function writes a formula or Excel
 * function to the cell specified by `row` and `column` with a user defined
 * string result:
 *
 * @code
 *     // The example formula is A & B -> AB.
 *     worksheet_write_formula_str(worksheet, 0, 0, "=\"A\" & \"B\"", NULL, "AB");
 * @endcode
 *
 * The `%worksheet_write_formula_str()` function is similar to the
 * `%worksheet_write_formula_num()` function except it writes a string result
 * instead or a numeric result. See `worksheet_write_formula_num()`  for more
 * details on why/when these functions are required.
 *
 * One place where the `%worksheet_write_formula_str()` function may be required
 * is to specify an empty result which will force a recalculation of the formula
 * when loaded in LibreOffice.
 *
 * @code
 *     worksheet_write_formula_str(worksheet, 0, 0, "=Sheet1!$A$1", NULL, "");
 * @endcode
 *
 * See the FAQ @ref faq_formula_zero.
 *
 * See also @ref working_with_formulas.
 *)
function worksheet_write_formula_str(worksheet: Plxw_worksheet; row: lxw_row_t; col: lxw_col_t; const formula: PUTF8Char; format: Plxw_format; const result: PUTF8Char): lxw_error; cdecl;
  external bj name _PU + 'worksheet_write_formula_str';

(**
 * @brief Write a "Rich" multi-format string to a worksheet cell.
 *
 * @param worksheet   Pointer to a lxw_worksheet instance to be updated.
 * @param row         The zero indexed row number.
 * @param col         The zero indexed column number.
 * @param rich_string An array of format/string lxw_rich_string_tuple fragments.
 * @param format      A pointer to a Format instance or NULL.
 *
 * @return A #lxw_error code.
 *
 * The `%worksheet_write_rich_string()` function is used to write strings with
 * multiple formats. For example to write the string 'This is **bold**
 * and this is *italic*' you would use the following:
 *
 * @code
 *     lxw_format *bold = workbook_add_format(workbook);
 *     format_set_bold(bold);
 *
 *     lxw_format *italic = workbook_add_format(workbook);
 *     format_set_italic(italic);
 *
 *     lxw_rich_string_tuple fragment11 = {.format = NULL,   .string = "This is "     };
 *     lxw_rich_string_tuple fragment12 = {.format = bold,   .string = "bold"         };
 *     lxw_rich_string_tuple fragment13 = {.format = NULL,   .string = " and this is "};
 *     lxw_rich_string_tuple fragment14 = {.format = italic, .string = "italic"       };
 *
 *     lxw_rich_string_tuple *rich_string1[] = {&fragment11, &fragment12,
 *                                              &fragment13, &fragment14, NULL};
 *
 *     worksheet_write_rich_string(worksheet, CELL("A1"), rich_string1, NULL);
 *
 * @endcode
 *
 * @image html rich_strings_small.png
 *
 * The basic rule is to break the string into fragments and put a lxw_format
 * object before the fragment that you want to format. So if we look at the
 * above example again:
 *
 * This is **bold** and this is *italic*
 *
 * The would be broken down into 4 fragments:
 *
 *      default: |This is |
 *      bold:    |bold|
 *      default: | and this is |
 *      italic:  |italic|
 *
 * This in then converted to the lxw_rich_string_tuple fragments shown in the
 * example above. For the default format we use `NULL`.
 *
 * The fragments are passed to `%worksheet_write_rich_string()` as a `NULL`
 * terminated array:
 *
 * @code
 *     lxw_rich_string_tuple *rich_string1[] = {&fragment11, &fragment12,
 *                                              &fragment13, &fragment14, NULL};
 *
 *     worksheet_write_rich_string(worksheet, CELL("A1"), rich_string1, NULL);
 *
 * @endcode
 *
 * **Note**:
 * Excel doesn't allow the use of two consecutive formats in a rich string or
 * an empty string fragment. For either of these conditions a warning is
 * raised and the input to `%worksheet_write_rich_string()` is ignored.
 *
 *)
type
  PPlxw_rich_string_tuple = ^Plxw_rich_string_tuple;
function worksheet_write_rich_string(worksheet: Plxw_worksheet; row: lxw_row_t; col: lxw_col_t; rich_string: PPlxw_rich_string_tuple; format: Plxw_format): lxw_error; cdecl;
  external bj name _PU + 'worksheet_write_rich_string';

(**
 * @brief Write a comment to a worksheet cell.
 *
 * @param worksheet   Pointer to a lxw_worksheet instance to be updated.
 * @param row         The zero indexed row number.
 * @param col         The zero indexed column number.
 * @param string      The comment string to be written.
 *
 * @return A #lxw_error code.
 *
 * The `%worksheet_write_comment()` function is used to add a comment to a
 * cell. A comment is indicated in Excel by a small red triangle in the upper
 * right-hand corner of the cell. Moving the cursor over the red triangle will
 * reveal the comment.
 *
 * The following example shows how to add a comment to a cell:
 *
 * @code
 *     worksheet_write_comment(worksheet, 0, 0, "This is a comment");
 * @endcode
 *
 * @image html comments1.png
 *
 * See also @ref working_with_comments
 *
 *)
function worksheet_write_comment(worksheet: Plxw_worksheet; row: lxw_row_t; col: lxw_col_t; const astring: PUTF8Char): lxw_error; cdecl;
  external bj name _PU + 'worksheet_write_comment';

(**
 * @brief Write a comment to a worksheet cell with options.
 *
 * @param worksheet   Pointer to a lxw_worksheet instance to be updated.
 * @param row         The zero indexed row number.
 * @param col         The zero indexed column number.
 * @param string      The comment string to be written.
 * @param options     #lxw_comment_options to control position and format
 *                    of the comment.
 *
 * @return A #lxw_error code.
 *
 * The `%worksheet_write_comment_opt()` function is used to add a comment to a
 * cell with option that control the position, format and metadata of the
 * comment. A comment is indicated in Excel by a small red triangle in the
 * upper right-hand corner of the cell. Moving the cursor over the red
 * triangle will reveal the comment.
 *
 * The following example shows how to add a comment to a cell with options:
 *
 * @code
 *     lxw_comment_options options = {.visible = LXW_COMMENT_DISPLAY_VISIBLE};
 *
 *     worksheet_write_comment_opt(worksheet, CELL("C6"), "Hello.", &options);
 * @endcode
 *
 * The following options are available in #lxw_comment_options:
 *
 * - `author`
 * - `visible`
 * - `width`
 * - `height`
 * - `x_scale`
 * - `y_scale`
 * - `color`
 * - `font_name`
 * - `font_size`
 * - `start_row`
 * - `start_col`
 * - `x_offset`
 * - `y_offset`
 *
 * @image html comments2.png
 *
 * Comment options are explained in detail in the @ref ww_comments_properties
 * section of the docs.
 *)
function worksheet_write_comment_opt(worksheet: Plxw_worksheet; row: lxw_row_t; col: lxw_col_t; const astring: PUTF8Char; options: Plxw_comment_options): lxw_error; cdecl;
  external bj name _PU + 'worksheet_write_comment_opt';

(**
 * @brief Set the properties for a row of cells.
 *
 * @param worksheet Pointer to a lxw_worksheet instance to be updated.
 * @param row       The zero indexed row number.
 * @param height    The row height, in character units.
 * @param format    A pointer to a Format instance or NULL.
 *
 * @return A #lxw_error code.
 *
 * The `%worksheet_set_row()` function is used to change the default
 * properties of a row. The most common use for this function is to change the
 * height of a row:
 *
 * @code
 *     // Set the height of Row 1 to 20.
 *     worksheet_set_row(worksheet, 0, 20, NULL);
 * @endcode
 *
 * The height is specified in character units. To specify the height in pixels
 * use the `worksheet_set_row_pixels()` function.
 *
 * The other common use for `%worksheet_set_row()` is to set the a @ref
 * format.h "Format" for all cells in the row:
 *
 * @code
 *     lxw_format *bold = workbook_add_format(workbook);
 *     format_set_bold(bold);
 *
 *     // Set the header row to bold.
 *     worksheet_set_row(worksheet, 0, 15, bold);
 * @endcode
 *
 * If you wish to set the format of a row without changing the height you can
 * pass the default row height of #LXW_DEF_ROW_HEIGHT = 15:
 *
 * @code
 *     worksheet_set_row(worksheet, 0, LXW_DEF_ROW_HEIGHT, format);
 *     worksheet_set_row(worksheet, 0, 15, format); // Same as above.
 * @endcode
 *
 * The `format` parameter will be applied to any cells in the row that don't
 * have a format. As with Excel the row format is overridden by an explicit
 * cell format. For example:
 *
 * @code
 *     // Row 1 has format1.
 *     worksheet_set_row(worksheet, 0, 15, format1);
 *
 *     // Cell A1 in Row 1 defaults to format1.
 *     worksheet_write_string(worksheet, 0, 0, "Hello", NULL);
 *
 *     // Cell B1 in Row 1 keeps format2.
 *     worksheet_write_string(worksheet, 0, 1, "Hello", format2);
 * @endcode
 *
 *)
function worksheet_set_row(worksheet: Plxw_worksheet; row: lxw_row_t; height: Double; format: Plxw_format): lxw_error; cdecl;
  external bj name _PU + 'worksheet_set_row';

(**
 * @brief Set the properties for a row of cells.
 *
 * @param worksheet Pointer to a lxw_worksheet instance to be updated.
 * @param row       The zero indexed row number.
 * @param height    The row height.
 * @param format    A pointer to a Format instance or NULL.
 * @param options   Optional row parameters: hidden, level, collapsed.
 *
 * @return A #lxw_error code.
 *
 * The `%worksheet_set_row_opt()` function  is the same as
 *  `worksheet_set_row()` with an additional `options` parameter.
 *
 * The `options` parameter is a #lxw_row_col_options struct. It has the
 * following members:
 *
 * - `hidden`
 * - `level`
 * - `collapsed`
 *
 * The `"hidden"` option is used to hide a row. This can be used, for
 * example, to hide intermediary steps in a complicated calculation:
 *
 * @code
 *     lxw_row_col_options options1 = {.hidden = 1, .level = 0, .collapsed = 0};
 *
 *     // Hide the fourth and fifth (zero indexed) rows.
 *     worksheet_set_row_opt(worksheet, 3,  LXW_DEF_ROW_HEIGHT, NULL, &options1);
 *     worksheet_set_row_opt(worksheet, 4,  LXW_DEF_ROW_HEIGHT, NULL, &options1);
 *
 * @endcode
 *
 * @image html hide_row_col2.png
 *
 * The `"hidden"`, `"level"`,  and `"collapsed"`, options can also be used to
 * create Outlines and Grouping. See @ref working_with_outlines.
 *
 * @code
 *     // The option structs with the outline level set.
 *     lxw_row_col_options options1 = {.hidden = 0, .level = 2, .collapsed = 0};
 *     lxw_row_col_options options2 = {.hidden = 0, .level = 1, .collapsed = 0};
 *
 *
 *     // Set the row options with the outline level.
 *     worksheet_set_row_opt(worksheet, 1,  LXW_DEF_ROW_HEIGHT, NULL, &options1);
 *     worksheet_set_row_opt(worksheet, 2,  LXW_DEF_ROW_HEIGHT, NULL, &options1);
 *     worksheet_set_row_opt(worksheet, 3,  LXW_DEF_ROW_HEIGHT, NULL, &options1);
 *     worksheet_set_row_opt(worksheet, 4,  LXW_DEF_ROW_HEIGHT, NULL, &options1);
 *     worksheet_set_row_opt(worksheet, 5,  LXW_DEF_ROW_HEIGHT, NULL, &options2);
 *
 *     worksheet_set_row_opt(worksheet, 6,  LXW_DEF_ROW_HEIGHT, NULL, &options1);
 *     worksheet_set_row_opt(worksheet, 7,  LXW_DEF_ROW_HEIGHT, NULL, &options1);
 *     worksheet_set_row_opt(worksheet, 8,  LXW_DEF_ROW_HEIGHT, NULL, &options1);
 *     worksheet_set_row_opt(worksheet, 9,  LXW_DEF_ROW_HEIGHT, NULL, &options1);
 *     worksheet_set_row_opt(worksheet, 10, LXW_DEF_ROW_HEIGHT, NULL, &options2);
 * @endcode
 *
 * @image html outline1.png
 *
 *)
function worksheet_set_row_opt(worksheet: Plxw_worksheet; row: lxw_row_t; height: Double; format: Plxw_format; options: Plxw_row_col_options): lxw_error; cdecl;
  external bj name _PU + 'worksheet_set_row_opt';

(**
 * @brief Set the properties for a row of cells, with the height in pixels.
 *
 * @param worksheet Pointer to a lxw_worksheet instance to be updated.
 * @param row       The zero indexed row number.
 * @param pixels    The row height in pixels.
 * @param format    A pointer to a Format instance or NULL.
 *
 * @return A #lxw_error code.
 *
 * The `%worksheet_set_row_pixels()` function is the same as the
 * `worksheet_set_row()` function except that the height can be set in pixels
 *
 * @code
 *     // Set the height of Row 1 to 20 pixels.
 *     worksheet_set_row_pixels(worksheet, 0, 20, NULL);
 * @endcode
 *
 * If you wish to set the format of a row without changing the height you can
 * pass the default row height in pixels: #LXW_DEF_ROW_HEIGHT_PIXELS.
 *)
function worksheet_set_row_pixels(worksheet: Plxw_worksheet; row: lxw_row_t; pixels: UInt32; format: Plxw_format): lxw_error; cdecl;
  external bj name _PU + 'worksheet_set_row_pixels';

(**
 * @brief Set the properties for a row of cells, with the height in pixels.
 *
 * @param worksheet Pointer to a lxw_worksheet instance to be updated.
 * @param row       The zero indexed row number.
 * @param pixels    The row height in pixels.
 * @param format    A pointer to a Format instance or NULL.
 * @param options   Optional row parameters: hidden, level, collapsed.
 *
 * @return A #lxw_error code.
 *
 * The `%worksheet_set_row_pixels_opt()` function is the same as the
 * `worksheet_set_row_opt()` function except that the height can be set in
 * pixels.
 *
 *)
function worksheet_set_row_pixels_opt(worksheet: Plxw_worksheet; row: lxw_row_t; pixels: UInt32; format: Plxw_format; options: Plxw_row_col_options): lxw_error; cdecl;
  external bj name _PU + 'worksheet_set_row_pixels_opt';

(**
 * @brief Set the properties for one or more columns of cells.
 *
 * @param worksheet Pointer to a lxw_worksheet instance to be updated.
 * @param first_col The zero indexed first column.
 * @param last_col  The zero indexed last column.
 * @param width     The width of the column(s).
 * @param format    A pointer to a Format instance or NULL.
 *
 * @return A #lxw_error code.
 *
 * The `%worksheet_set_column()` function can be used to change the default
 * properties of a single column or a range of columns:
 *
 * @code
 *     // Width of columns B:D set to 30.
 *     worksheet_set_column(worksheet, 1, 3, 30, NULL);
 *
 * @endcode
 *
 * If `%worksheet_set_column()` is applied to a single column the value of
 * `first_col` and `last_col` should be the same:
 *
 * @code
 *     // Width of column B set to 30.
 *     worksheet_set_column(worksheet, 1, 1, 30, NULL);
 *
 * @endcode
 *
 * It is also possible, and generally clearer, to specify a column range using
 * the form of `COLS()` macro:
 *
 * @code
 *     worksheet_set_column(worksheet, 4, 4, 20, NULL);
 *     worksheet_set_column(worksheet, 5, 8, 30, NULL);
 *
 *     // Same as the examples above but clearer.
 *     worksheet_set_column(worksheet, COLS("E:E"), 20, NULL);
 *     worksheet_set_column(worksheet, COLS("F:H"), 30, NULL);
 *
 * @endcode
 *
 * The `width` parameter sets the column width in the same units used by Excel
 * which is: the number of characters in the default font. The default width
 * is 8.43 in the default font of Calibri 11. The actual relationship between
 * a string width and a column width in Excel is complex. See the
 * [following explanation of column widths](https://support.microsoft.com/en-us/kb/214123)
 * from the Microsoft support documentation for more details. To set the width
 * in pixels use the `worksheet_set_column_pixels()` function.
 *
 * There is no way to specify "AutoFit" for a column in the Excel file
 * format. This feature is only available at runtime from within Excel. It is
 * possible to simulate "AutoFit" in your application by tracking the maximum
 * width of the data in the column as your write it and then adjusting the
 * column width at the end.
 *
 * As usual the @ref format.h `format` parameter is optional. If you wish to
 * set the format without changing the width you can pass a default column
 * width of #LXW_DEF_COL_WIDTH = 8.43:
 *
 * @code
 *     lxw_format *bold = workbook_add_format(workbook);
 *     format_set_bold(bold);
 *
 *     // Set the first column to bold.
 *     worksheet_set_column(worksheet, 0, 0, LXW_DEF_COL_WIDTH, bold);
 * @endcode
 *
 * The `format` parameter will be applied to any cells in the column that
 * don't have a format. For example:
 *
 * @code
 *     // Column 1 has format1.
 *     worksheet_set_column(worksheet, COLS("A:A"), 8.43, format1);
 *
 *     // Cell A1 in column 1 defaults to format1.
 *     worksheet_write_string(worksheet, 0, 0, "Hello", NULL);
 *
 *     // Cell A2 in column 1 keeps format2.
 *     worksheet_write_string(worksheet, 1, 0, "Hello", format2);
 * @endcode
 *
 * As in Excel a row format takes precedence over a default column format:
 *
 * @code
 *     // Row 1 has format1.
 *     worksheet_set_row(worksheet, 0, 15, format1);
 *
 *     // Col 1 has format2.
 *     worksheet_set_column(worksheet, COLS("A:A"), 8.43, format2);
 *
 *     // Cell A1 defaults to format1, the row format.
 *     worksheet_write_string(worksheet, 0, 0, "Hello", NULL);
 *
 *    // Cell A2 keeps format2, the column format.
 *     worksheet_write_string(worksheet, 1, 0, "Hello", NULL);
 * @endcode
 *)
function worksheet_set_column(worksheet: Plxw_worksheet; first_col: lxw_col_t; last_col: lxw_col_t; width: Double; format: Plxw_format): lxw_error; cdecl;
  external bj name _PU + 'worksheet_set_column';

(**
 * @brief Set the properties for one or more columns of cells with options.
 *
 * @param worksheet Pointer to a lxw_worksheet instance to be updated.
 * @param first_col The zero indexed first column.
 * @param last_col  The zero indexed last column.
 * @param width     The width of the column(s).
 * @param format    A pointer to a Format instance or NULL.
 * @param options   Optional row parameters: hidden, level, collapsed.
 *
 * @return A #lxw_error code.
 *
 * The `%worksheet_set_column_opt()` function  is the same as
 * `worksheet_set_column()` with an additional `options` parameter.
 *
 * The `options` parameter is a #lxw_row_col_options struct. It has the
 * following members:
 *
 * - `hidden`
 * - `level`
 * - `collapsed`
 *
 * The `"hidden"` option is used to hide a column. This can be used, for
 * example, to hide intermediary steps in a complicated calculation:
 *
 * @code
 *     lxw_row_col_options options1 = {.hidden = 1, .level = 0, .collapsed = 0};
 *
 *     worksheet_set_column_opt(worksheet, COLS("D:E"),  LXW_DEF_COL_WIDTH, NULL, &options1);
 * @endcode
 *
 * @image html hide_row_col3.png
 *
 * The `"hidden"`, `"level"`,  and `"collapsed"`, options can also be used to
 * create Outlines and Grouping. See @ref working_with_outlines.
 *
 * @code
 *     lxw_row_col_options options1 = {.hidden = 0, .level = 1, .collapsed = 0};
 *
 *     worksheet_set_column_opt(worksheet, COLS("B:G"),  5, NULL, &options1);
 * @endcode
 *
 * @image html outline8.png
 *)
function worksheet_set_column_opt(worksheet: Plxw_worksheet; first_col: lxw_col_t; last_col: lxw_col_t; width: Double; format: Plxw_format; options: Plxw_row_col_options): lxw_error; cdecl;
  external bj name _PU + 'worksheet_set_column_opt';

(**
 * @brief Set the properties for one or more columns of cells, with the width
 *        in pixels.
 *
 * @param worksheet Pointer to a lxw_worksheet instance to be updated.
 * @param first_col The zero indexed first column.
 * @param last_col  The zero indexed last column.
 * @param pixels    The width of the column(s) in pixels.
 * @param format    A pointer to a Format instance or NULL.
 *
 * @return A #lxw_error code.
 *
 * The `%worksheet_set_column_pixels()` function is the same as
 * `worksheet_set_column()` function except that the width can be set in
 * pixels:
 *
 * @code
 *     // Column width set to 75 pixels, the same as 10 character units.
 *     worksheet_set_column(worksheet, 5, 5, 75, NULL);
 * @endcode
 *
 * @image html set_column_pixels.png
 *
 * If you wish to set the format of a column without changing the width you can
 * pass the default column width in pixels: #LXW_DEF_COL_WIDTH_PIXELS.
 *)
function worksheet_set_column_pixels(worksheet: Plxw_worksheet; first_col: lxw_col_t; last_col: lxw_col_t; pixels: UInt32; format: Plxw_format): lxw_error; cdecl;
  external bj name _PU + 'worksheet_set_column_pixels';

(**
 * @brief Set the properties for one or more columns of cells with options,
 *        with the width in pixels.
 *
 * @param worksheet Pointer to a lxw_worksheet instance to be updated.
 * @param first_col The zero indexed first column.
 * @param last_col  The zero indexed last column.
 * @param pixels    The width of the column(s) in pixels.
 * @param format    A pointer to a Format instance or NULL.
 * @param options   Optional row parameters: hidden, level, collapsed.
 *
 * @return A #lxw_error code.
 *
 * The `%worksheet_set_column_pixels_opt()` function is the same as the
 * `worksheet_set_column_opt()` function except that the width can be set in
 * pixels.
 *
 *)
function worksheet_set_column_pixels_opt(worksheet: Plxw_worksheet; first_col: lxw_col_t; last_col: lxw_col_t; pixels: UInt32; format: Plxw_format; options: Plxw_row_col_options): lxw_error; cdecl;
  external bj name _PU + 'worksheet_set_column_pixels_opt';

(**
 * @brief Insert an image in a worksheet cell.
 *
 * @param worksheet Pointer to a lxw_worksheet instance to be updated.
 * @param row       The zero indexed row number.
 * @param col       The zero indexed column number.
 * @param filename  The image filename, with path if required.
 *
 * @return A #lxw_error code.
 *
 * This function can be used to insert a image into a worksheet. The image can
 * be in PNG, JPEG, GIF or BMP format:
 *
 * @code
 *     worksheet_insert_image(worksheet, 2, 1, "logo.png");
 * @endcode
 *
 * @image html insert_image.png
 *
 * The `worksheet_insert_image_opt()` function takes additional optional
 * parameters to position and scale the image, see below.
 *
 * **Note**:
 * The scaling of a image may be affected if is crosses a row that has its
 * default height changed due to a font that is larger than the default font
 * size or that has text wrapping turned on. To avoid this you should explicitly
 * set the height of the row using `worksheet_set_row()` if it crosses an
 * inserted image. See @ref working_with_object_positioning.
 *
 * **NOTE on SVG files**:
 * Excel doesn't directly support SVG files in the same way as other image file
 * formats. It allows SVG to be inserted into a worksheet but converts them to,
 * and displays them as, PNG files. It stores the original SVG image in the file
 * so the original format can be retrieved. This removes the file size and
 * resolution advantage of using SVG files. As such SVG files are not supported
 * by `libxlsxwriter` since a conversion to the PNG format would be required
 * and that format is already supported.
 *
 * BMP images are only supported for backward compatibility. In general it is
 * best to avoid BMP images since they aren't compressed. If used, BMP images
 * must be 24 bit, true color, bitmaps.
 *)
function worksheet_insert_image(worksheet: Plxw_worksheet; row: lxw_row_t; col: lxw_col_t; const filename: PUTF8Char): lxw_error; cdecl;
  external bj name _PU + 'worksheet_insert_image';

(**
 * @brief Insert an image in a worksheet cell, with options.
 *
 * @param worksheet Pointer to a lxw_worksheet instance to be updated.
 * @param row       The zero indexed row number.
 * @param col       The zero indexed column number.
 * @param filename  The image filename, with path if required.
 * @param options   Optional image parameters.
 *
 * @return A #lxw_error code.
 *
 * The `%worksheet_insert_image_opt()` function is like
 * `worksheet_insert_image()` function except that it takes an optional
 * #lxw_image_options struct with the following members/options:
 *
 * - `x_offset`: Offset from the left of the cell in pixels.
 * - `y_offset`: Offset from the top of the cell in pixels.
 * - `x_scale`: X scale of the image as a decimal.
 * - `y_scale`: Y scale of the image as a decimal.
 * - `object_position`: See @ref working_with_object_positioning.
 * - `description`: Optional description or "Alt text" for the image.
 * - `decorative`: Optional parameter to mark image as decorative.
 * - `url`: Add an optional hyperlink to the image.
 * - `tip`: Add an optional mouseover tip for a hyperlink to the image.
 *
 * For example, to scale and position the image:
 *
 * @code
 *     lxw_image_options options = {.x_offset = 30,  .y_offset = 10,
 *                                 .x_scale  = 0.5, .y_scale  = 0.5};
 *
 *     worksheet_insert_image_opt(worksheet, 2, 1, "logo.png", &options);
 *
 * @endcode
 *
 * @image html insert_image_opt.png
 *
 * The `url` field of lxw_image_options can be use to used to add a hyperlink
 * to an image:
 *
 * @code
 *     lxw_image_options options = {.url = "https://github.com/jmcnamara"};
 *
 *     worksheet_insert_image_opt(worksheet, 3, 1, "logo.png", &options);
 * @endcode
 *
 * The supported URL formats are the same as those supported by the
 * `worksheet_write_url()` method and the same rules/limits apply.
 *
 * The `tip` field of lxw_image_options can be use to used to add a mouseover
 * tip to the hyperlink:
 *
 * @code
 *      lxw_image_options options = {.url = "https://github.com/jmcnamara",
                                     .tip = "GitHub"};
 *
 *     worksheet_insert_image_opt(worksheet, 4, 1, "logo.png", &options);
 * @endcode
 *
 * @note See the notes about row scaling and BMP images in
 * `worksheet_insert_image()` above.
 *)
function worksheet_insert_image_opt(worksheet: Plxw_worksheet; row: lxw_row_t; col: lxw_col_t; const filename: PUTF8Char; options: Plxw_image_options): lxw_error; cdecl;
  external bj name _PU + 'worksheet_insert_image_opt';

(**
 * @brief Insert an image in a worksheet cell, from a memory buffer.
 *
 * @param worksheet    Pointer to a lxw_worksheet instance to be updated.
 * @param row          The zero indexed row number.
 * @param col          The zero indexed column number.
 * @param image_buffer Pointer to an array of bytes that holds the image data.
 * @param image_size   The size of the array of bytes.
 *
 * @return A #lxw_error code.
 *
 * This function can be used to insert a image into a worksheet from a memory
 * buffer:
 *
 * @code
 *     worksheet_insert_image_buffer(worksheet, CELL("B3"), image_buffer, image_size);
 * @endcode
 *
 * @image html image_buffer.png
 *
 * The buffer should be a pointer to an array of unsigned char data with a
 * specified size.
 *
 * See `worksheet_insert_image()` for details about the supported image
 * formats, and other image features.
 *)
function worksheet_insert_image_buffer(worksheet: Plxw_worksheet; row: lxw_row_t; col: lxw_col_t; const image_buffer: PByte; image_size: NativeUInt): lxw_error; cdecl;
  external bj name _PU + 'worksheet_insert_image_buffer';

(**
 * @brief Insert an image in a worksheet cell, from a memory buffer.
 *
 * @param worksheet    Pointer to a lxw_worksheet instance to be updated.
 * @param row          The zero indexed row number.
 * @param col          The zero indexed column number.
 * @param image_buffer Pointer to an array of bytes that holds the image data.
 * @param image_size   The size of the array of bytes.
 * @param options      Optional image parameters.
 *
 * @return A #lxw_error code.
 *
 * The `%worksheet_insert_image_buffer_opt()` function is like
 * `worksheet_insert_image_buffer()` function except that it takes an optional
 * #lxw_image_options struct with the following members/options:
 *
 * - `x_offset`: Offset from the left of the cell in pixels.
 * - `y_offset`: Offset from the top of the cell in pixels.
 * - `x_scale`: X scale of the image as a decimal.
 * - `y_scale`: Y scale of the image as a decimal.
 * - `object_position`: See @ref working_with_object_positioning.
 * - `description`: Optional description or "Alt text" for the image.
 * - `decorative`: Optional parameter to mark image as decorative.
 * - `url`: Add an optional hyperlink to the image.
 * - `tip`: Add an optional mouseover tip for a hyperlink to the image.
 *
 * For example, to scale and position the image:
 *
 * @code
 *     lxw_image_options options = {.x_offset = 32, .y_offset = 4,
 *                                  .x_scale  = 2,  .y_scale  = 1};
 *
 *     worksheet_insert_image_buffer_opt(worksheet, CELL("B3"), image_buffer, image_size, &options);
 * @endcode
 *
 * @image html image_buffer_opt.png
 *
 * The buffer should be a pointer to an array of unsigned char data with a
 * specified size.
 *
 * See `worksheet_insert_image_buffer_opt()` for details about the supported
 * image formats, and other image options.
 *)
function worksheet_insert_image_buffer_opt(worksheet: Plxw_worksheet; row: lxw_row_t; col: lxw_col_t; const image_buffer: PByte; image_size: NativeUInt; options: Plxw_image_options): lxw_error; cdecl;
  external bj name _PU + 'worksheet_insert_image_buffer_opt';

(**
 * @brief Embed an image in a worksheet cell.
 *
 * @param worksheet Pointer to a lxw_worksheet instance to be updated.
 * @param row       The zero indexed row number.
 * @param col       The zero indexed column number.
 * @param filename  The image filename, with path if required.
 *
 * @return A #lxw_error code.
 *
 * This function can be used to embed a image into a worksheet cell and have the
 * image automatically scale to the width and height of the cell. The X/Y
 * scaling of the image is preserved but the size of the image is adjusted to
 * fit the largest possible width or height depending on the cell dimensions.
 *
 * This is the equivalent of Excel's menu option to insert an image using the
 * option to "Place in Cell" which is only available in Excel 365 versions from
 * 2023 onwards. For older versions of Excel a `#VALUE!` error is displayed.
 *
 * @dontinclude embed_images.c
 * @skip Change
 * @until B6
 *
 * @image html embed_image.png
 *
 * The `worksheet_embed_image_opt()` function takes additional optional
 * parameters to add urls or format the cell background, see below.
 *
 *)
function worksheet_embed_image(worksheet: Plxw_worksheet; row: lxw_row_t; col: lxw_col_t; const filename: PUTF8Char): lxw_error; cdecl;
  external bj name _PU + 'worksheet_embed_image';

(**
 * @brief Embed an image in a worksheet cell, with options.
 *
 * @param worksheet Pointer to a lxw_worksheet instance to be updated.
 * @param row       The zero indexed row number.
 * @param col       The zero indexed column number.
 * @param filename  The image filename, with path if required.
 * @param options   Optional image parameters.
 *
 * @return A #lxw_error code.
 *
 * The `%worksheet_embed_image_opt()` function is like
 * `worksheet_embed_image()` function except that it takes an optional
 * #lxw_image_options struct with the following members/options:
 *
 * - `description`: Optional description or "Alt text" for the image.
 * - `decorative`: Optional parameter to mark image as decorative.
 * - `url`: Add an optional hyperlink to the image.
 * - `cell_format`: Add a format for the cell behind the embedded image.
 *
 *)
function worksheet_embed_image_opt(worksheet: Plxw_worksheet; row: lxw_row_t; col: lxw_col_t; const filename: PUTF8Char; options: Plxw_image_options): lxw_error; cdecl;
  external bj name _PU + 'worksheet_embed_image_opt';

(**
 * @brief Embed an image in a worksheet cell, from a memory buffer.
 *
 * @param worksheet    Pointer to a lxw_worksheet instance to be updated.
 * @param row          The zero indexed row number.
 * @param col          The zero indexed column number.
 * @param image_buffer Pointer to an array of bytes that holds the image data.
 * @param image_size   The size of the array of bytes.
 *
 * @return A #lxw_error code.
 *
 * This function can be used to embed a image into a worksheet from a memory
 * buffer:
 *
 * @dontinclude embed_image_buffer.c
 * @skip Embed
 * @until B3
 *
 * @image html embed_image_buffer.png
 *
 * The buffer should be a pointer to an array of unsigned char data with a
 * specified size.
 *
 * See `worksheet_embed_image()` for details about the supported image
 * formats, and other image features.
 *)
function worksheet_embed_image_buffer(worksheet: Plxw_worksheet; row: lxw_row_t; col: lxw_col_t; const image_buffer: PByte; image_size: NativeUInt): lxw_error; cdecl;
  external bj name _PU + 'worksheet_embed_image_buffer';

(**
 * @brief Embed an image in a worksheet cell, from a memory buffer.
 *
 * @param worksheet    Pointer to a lxw_worksheet instance to be updated.
 * @param row          The zero indexed row number.
 * @param col          The zero indexed column number.
 * @param image_buffer Pointer to an array of bytes that holds the image data.
 * @param image_size   The size of the array of bytes.
 * @param options      Optional image parameters.
 *
 * @return A #lxw_error code.
 *
 * The `%worksheet_embed_image_buffer_opt()` function is like
 * `worksheet_embed_image_buffer()` function except that it takes an optional
 * #lxw_image_options struct with the following members/options:
 *
 * - `description`: Optional description or "Alt text" for the image.
 * - `decorative`: Optional parameter to mark image as decorative.
 * - `url`: Add an optional hyperlink to the image.
 * - `cell_format`: Add a format for the cell behind the embedded image.
 *
 *)
function worksheet_embed_image_buffer_opt(worksheet: Plxw_worksheet; row: lxw_row_t; col: lxw_col_t; const image_buffer: PByte; image_size: NativeUInt; options: Plxw_image_options): lxw_error; cdecl;
  external bj name _PU + 'worksheet_embed_image_buffer_opt';

(**
 * @brief Set the background image for a worksheet.
 *
 * @param worksheet Pointer to a lxw_worksheet instance to be updated.
 * @param filename  The image filename, with path if required.
 *
 * @return A #lxw_error code.
 *
 * The `%worksheet_set_background()` function can be used to set the
 * background image for a worksheet:
 *
 * @code
 *      worksheet_set_background(worksheet, "logo.png");
 * @endcode
 *
 * @image html background.png
 *
 * The ``set_background()`` method supports all the image formats supported by
 * `worksheet_insert_image()`.
 *
 * Some people use this method to add a watermark background to their
 * document. However, Microsoft recommends using a header image [to set a
 * watermark][watermark]. The choice of method depends on whether you want the
 * watermark to be visible in normal viewing mode or just when the file is
 * printed. In libxlsxwriter you can get the header watermark effect using
 * `worksheet_set_header()`:
 *
 * @code
 *     lxw_header_footer_options header_options = {.image_center = "watermark.png"};
 *     worksheet_set_header_opt(worksheet, "&C&G", &header_options);
 * @endcode
 *
 * [watermark]:https://support.microsoft.com/en-us/office/add-a-watermark-in-excel-a372182a-d733-484e-825c-18ddf3edf009
 *
 *)
function worksheet_set_background(worksheet: Plxw_worksheet; const filename: PUTF8Char): lxw_error; cdecl;
  external bj name _PU + 'worksheet_set_background';

(**
 * @brief Set the background image for a worksheet, from a buffer.
 *
 * @param worksheet    Pointer to a lxw_worksheet instance to be updated.
 * @param image_buffer Pointer to an array of bytes that holds the image data.
 * @param image_size   The size of the array of bytes.
 *
 * @return A #lxw_error code.
 *
 * This function can be used to insert a background image into a worksheet
 * from a memory buffer:
 *
 * @code
 *     worksheet_set_background_buffer(worksheet, image_buffer, image_size);
 * @endcode
 *
 * The buffer should be a pointer to an array of unsigned char data with a
 * specified size.
 *
 * See `worksheet_set_background()` for more details.
 *
 *)
function worksheet_set_background_buffer(worksheet: Plxw_worksheet; const image_buffer: PByte; image_size: NativeUInt): lxw_error; cdecl;
  external bj name _PU + 'worksheet_set_background_buffer';

(**
 * @brief Insert a chart object into a worksheet.
 *
 * @param worksheet Pointer to a lxw_worksheet instance to be updated.
 * @param row       The zero indexed row number.
 * @param col       The zero indexed column number.
 * @param chart     A #lxw_chart object created via workbook_add_chart().
 *
 * @return A #lxw_error code.
 *
 * The `%worksheet_insert_chart()` function can be used to insert a chart into
 * a worksheet. The chart object must be created first using the
 * `workbook_add_chart()` function and configured using the @ref chart.h
 * functions.
 *
 * @code
 *     // Create a chart object.
 *     lxw_chart *chart = workbook_add_chart(workbook, LXW_CHART_LINE);
 *
 *     // Add a data series to the chart.
 *     chart_add_series(chart, NULL, "=Sheet1!$A$1:$A$6");
 *
 *     // Insert the chart into the worksheet.
 *     worksheet_insert_chart(worksheet, 0, 2, chart);
 * @endcode
 *
 * @image html chart_working.png
 *
 * **Note:**
 *
 * A chart may only be inserted into a worksheet once. If several similar
 * charts are required then each one must be created separately with
 * `%worksheet_insert_chart()`.
 *
 *)
function worksheet_insert_chart(worksheet: Plxw_worksheet; row: lxw_row_t; col: lxw_col_t; chart: Plxw_chart): lxw_error; cdecl;
  external bj name _PU + 'worksheet_insert_chart';

(**
 * @brief Insert a chart object into a worksheet, with options.
 *
 * @param worksheet    Pointer to a lxw_worksheet instance to be updated.
 * @param row          The zero indexed row number.
 * @param col          The zero indexed column number.
 * @param chart        A #lxw_chart object created via workbook_add_chart().
 * @param user_options Optional chart parameters.
 *
 * @return A #lxw_error code.
 *
 * The `%worksheet_insert_chart_opt()` function is like
 * `worksheet_insert_chart()` function except that it takes an optional
 * #lxw_chart_options struct to scale and position the chart:
 *
 * @code
 *    lxw_chart_options options = {.x_offset = 30,  .y_offset = 10,
 *                                 .x_scale  = 0.5, .y_scale  = 0.75};
 *
 *    worksheet_insert_chart_opt(worksheet, 0, 2, chart, &options);
 *
 * @endcode
 *
 * @image html chart_line_opt.png
 *
 *)
function worksheet_insert_chart_opt(worksheet: Plxw_worksheet; row: lxw_row_t; col: lxw_col_t; chart: Plxw_chart; user_options: Plxw_chart_options): lxw_error; cdecl;
  external bj name _PU + 'worksheet_insert_chart_opt';

(**
 * @brief Merge a range of cells.
 *
 * @param worksheet Pointer to a lxw_worksheet instance to be updated.
 * @param first_row The first row of the range. (All zero indexed.)
 * @param first_col The first column of the range.
 * @param last_row  The last row of the range.
 * @param last_col  The last col of the range.
 * @param string    String to write to the merged range.
 * @param format    A pointer to a Format instance or NULL.
 *
 * @return A #lxw_error code.
 *
 * The `%worksheet_merge_range()` function allows cells to be merged together
 * so that they act as a single area.
 *
 * Excel generally merges and centers cells at same time. To get similar
 * behavior with libxlsxwriter you need to apply a @ref format.h "Format"
 * object with the appropriate alignment:
 *
 * @code
 *     lxw_format *merge_format = workbook_add_format(workbook);
 *     format_set_align(merge_format, LXW_ALIGN_CENTER);
 *
 *     worksheet_merge_range(worksheet, 1, 1, 1, 3, "Merged Range", merge_format);
 *
 * @endcode
 *
 * It is possible to apply other formatting to the merged cells as well:
 *
 * @code
 *    format_set_align   (merge_format, LXW_ALIGN_CENTER);
 *    format_set_align   (merge_format, LXW_ALIGN_VERTICAL_CENTER);
 *    format_set_border  (merge_format, LXW_BORDER_DOUBLE);
 *    format_set_bold    (merge_format);
 *    format_set_bg_color(merge_format, 0xD7E4BC);
 *
 *    worksheet_merge_range(worksheet, 2, 1, 3, 3, "Merged Range", merge_format);
 *
 * @endcode
 *
 * @image html merge.png
 *
 * The `%worksheet_merge_range()` function writes a `char*` string using
 * `worksheet_write_string()`. In order to write other data types, such as a
 * number or a formula, you can overwrite the first cell with a call to one of
 * the other write functions. The same Format should be used as was used in
 * the merged range.
 *
 * @code
 *    // First write a range with a blank string.
 *    worksheet_merge_range (worksheet, 1, 1, 1, 3, "", format);
 *
 *    // Then overwrite the first cell with a number.
 *    worksheet_write_number(worksheet, 1, 1, 123, format);
 * @endcode
 *
 * @note Merged ranges generally don't work in libxlsxwriter when the Workbook
 * #lxw_workbook_options `constant_memory` mode is enabled.
 *)
function worksheet_merge_range(worksheet: Plxw_worksheet; first_row: lxw_row_t; first_col: lxw_col_t; last_row: lxw_row_t; last_col: lxw_col_t; const astring: PUTF8Char; format: Plxw_format): lxw_error; cdecl;
  external bj name _PU + 'worksheet_merge_range';

(**
 * @brief Set the autofilter area in the worksheet.
 *
 * @param worksheet Pointer to a lxw_worksheet instance to be updated.
 * @param first_row The first row of the range. (All zero indexed.)
 * @param first_col The first column of the range.
 * @param last_row  The last row of the range.
 * @param last_col  The last col of the range.
 *
 * @return A #lxw_error code.
 *
 * The `%worksheet_autofilter()` function allows an autofilter to be added to
 * a worksheet.
 *
 * An autofilter is a way of adding dropdown lists to the headers of a 2D
 * range of worksheet data. This allows users to filter the data based on
 * simple criteria so that some data is shown and some is hidden.
 *
 * @image html autofilter3.png
 *
 * To add an autofilter to a worksheet:
 *
 * @code
 *     worksheet_autofilter(worksheet, 0, 0, 50, 3);
 *
 *     // Same as above using the RANGE() macro.
 *     worksheet_autofilter(worksheet, RANGE("A1:D51"));
 * @endcode
 *
 * In order to apply a filter condition it is necessary to add filter rules to
 * the columns using either the `%worksheet_filter_column()`,
 * `%worksheet_filter_column2()` or `%worksheet_filter_list()` functions:
 *
 * - `worksheet_filter_column()`: filter on a single criterion such as "Column ==
 *   East". More complex conditions such as "<=" or ">=" can also be use.
 *
 * - `worksheet_filter_column2()`: filter on two criteria such as "Column == East
 *   or Column == West". Complex conditions can also be used.
 *
 * - `worksheet_filter_list()`: filter on a list of values such as "Column in (East, West,
 *   North)".
 *
 * These functions are explained below. It isn't sufficient to just specify
 * the filter condition. You must also hide any rows that don't match the
 * filter condition. See @ref ww_autofilters_data for more details.
 *
 *)
function worksheet_autofilter(worksheet: Plxw_worksheet; first_row: lxw_row_t; first_col: lxw_col_t; last_row: lxw_row_t; last_col: lxw_col_t): lxw_error; cdecl;
  external bj name _PU + 'worksheet_autofilter';

(**
 * @brief Write a filter rule to an autofilter column.
 *
 * @param worksheet Pointer to a lxw_worksheet instance to be updated.
 * @param col       The column in the autofilter that the rule applies to.
 * @param rule      The lxw_filter_rule autofilter rule.
 *
 * @return A #lxw_error code.
 *
 * The `worksheet_filter_column` function can be used to filter columns in a
 * autofilter range based on single rule conditions:
 *
 * @code
 *     lxw_filter_rule filter_rule = {.criteria     = LXW_FILTER_CRITERIA_EQUAL_TO,
 *                                    .value_string = "East"};
 *
 *    worksheet_filter_column(worksheet, 0, &filter_rule);
 *@endcode
 *
 * @image html autofilter4.png
 *
 * The rules and criteria are explained in more detail in @ref
 * ww_autofilters_criteria in @ref working_with_autofilters.
 *
 * The `col` parameter is a zero indexed column number and must refer to a
 * column in an existing autofilter created with `worksheet_autofilter()`.
 *
 * It isn't sufficient to just specify the filter condition. You must also
 * hide any rows that don't match the filter condition. See @ref
 * ww_autofilters_data for more details.
 *)
function worksheet_filter_column(worksheet: Plxw_worksheet; col: lxw_col_t; rule: Plxw_filter_rule): lxw_error; cdecl;
  external bj name _PU + 'worksheet_filter_column';

(**
 * @brief Write two filter rules to an autofilter column.
 *
 * @param worksheet Pointer to a lxw_worksheet instance to be updated.
 * @param col       The column in the autofilter that the rules applies to.
 * @param rule1     First lxw_filter_rule autofilter rule.
 * @param rule2     Second lxw_filter_rule autofilter rule.
 * @param and_or    A #lxw_filter_operator and/or operator.
 *
 * @return A #lxw_error code.
 *
 * The `worksheet_filter_column2` function can be used to filter columns in a autofilter
 * range based on two rule conditions:
 *
 * @code
 *     lxw_filter_rule filter_rule1 = {.criteria     = LXW_FILTER_CRITERIA_EQUAL_TO,
 *                                     .value_string = "East"};
 *
 *     lxw_filter_rule filter_rule2 = {.criteria     = LXW_FILTER_CRITERIA_EQUAL_TO,
 *                                     .value_string = "South"};
 *
 *     worksheet_filter_column2(worksheet, 0, &filter_rule1, &filter_rule2, LXW_FILTER_OR);
 * @endcode
 *
 * @image html autofilter5.png
 *
 * The rules and criteria are explained in more detail in @ref
 * ww_autofilters_criteria in @ref working_with_autofilters.
 *
 * The `col` parameter is a zero indexed column number and must refer to a
 * column in an existing autofilter created with `worksheet_autofilter()`.
 *
 * The `and_or` parameter is either "and (LXW_FILTER_AND)" or "or  (LXW_FILTER_OR)".
 *
 * It isn't sufficient to just specify the filter condition. You must also
 * hide any rows that don't match the filter condition. See @ref
 * ww_autofilters_data for more details.
 *)
function worksheet_filter_column2(worksheet: Plxw_worksheet; col: lxw_col_t; rule1: Plxw_filter_rule; rule2: Plxw_filter_rule; and_or: UInt8): lxw_error; cdecl;
  external bj name _PU + 'worksheet_filter_column2';

(**
 * @brief Write multiple string filters to an autofilter column.
 *
 * @param worksheet Pointer to a lxw_worksheet instance to be updated.
 * @param col       The column in the autofilter that the rules applies to.
 * @param list      A NULL terminated array of strings to filter on.
 *
 * @return A #lxw_error code.
 *
 * The `worksheet_filter_column_list()` function can be used specify multiple
 * string matching criteria. This is a newer type of filter introduced in
 * Excel 2007. Prior to that it was only possible to have either 1 or 2 filter
 * conditions, such as the ones used by `worksheet_filter_column()` and
 * `worksheet_filter_column2()`.
 *
 * As an example, consider a column that contains data for the months of the
 * year. The `%worksheet_filter_list()` function can be used to filter out
 * data rows for different months:
 *
 * @code
 *     char* list[] = {"March", "April", "May", NULL};
 *
 *     worksheet_filter_list(worksheet, 0, list);
 * @endcode
 *
 * @image html autofilter2.png
 *
 *
 * Note, the array must be NULL terminated to indicate the end of the array of
 * strings. To filter blanks as part of the list use `Blanks` as a list item:
 *
 * @code
 *     char* list[] = {"March", "April", "May", "Blanks", NULL};
 *
 *     worksheet_filter_list(worksheet, 0, list);
 * @endcode
 *
 * It isn't sufficient to just specify the filter condition. You must also
 * hide any rows that don't match the filter condition. See @ref
 * ww_autofilters_data for more details.
 *)
function worksheet_filter_list(worksheet: Plxw_worksheet; col: lxw_col_t; list: PPUTF8Char): lxw_error; cdecl;
  external bj name _PU + 'worksheet_filter_list';

(**
 * @brief Add a data validation to a cell.
 *
 * @param worksheet  Pointer to a lxw_worksheet instance to be updated.
 * @param row        The zero indexed row number.
 * @param col        The zero indexed column number.
 * @param validation A #lxw_data_validation object to control the validation.
 *
 * @return A #lxw_error code.
 *
 * The `%worksheet_data_validation_cell()` function is used to construct an
 * Excel data validation or to limit the user input to a dropdown list of
 * values:
 *
 * @code
 *
 *    lxw_data_validation *data_validation = calloc(1, sizeof(lxw_data_validation));
 *
 *    data_validation->validate       = LXW_VALIDATION_TYPE_INTEGER;
 *    data_validation->criteria       = LXW_VALIDATION_CRITERIA_BETWEEN;
 *    data_validation->minimum_number = 1;
 *    data_validation->maximum_number = 10;
 *
 *    worksheet_data_validation_cell(worksheet, 2, 1, data_validation);
 *
 *    // Same as above with the CELL() macro.
 *    worksheet_data_validation_cell(worksheet, CELL("B3"), data_validation);
 *
 * @endcode
 *
 * @image html data_validate4.png
 *
 * Data validation and the various options of #lxw_data_validation are
 * described in more detail in @ref working_with_data_validation.
 *)
function worksheet_data_validation_cell(worksheet: Plxw_worksheet; row: lxw_row_t; col: lxw_col_t; validation: Plxw_data_validation): lxw_error; cdecl;
  external bj name _PU + 'worksheet_data_validation_cell';

(**
 * @brief Add a data validation to a range.
 *
 * @param worksheet  Pointer to a lxw_worksheet instance to be updated.
 * @param first_row  The first row of the range. (All zero indexed.)
 * @param first_col  The first column of the range.
 * @param last_row   The last row of the range.
 * @param last_col   The last col of the range.
 * @param validation A #lxw_data_validation object to control the validation.
 *
 * @return A #lxw_error code.
 *
 * The `%worksheet_data_validation_range()` function is the same as the
 * `%worksheet_data_validation_cell()`, see above,  except the data validation
 * is applied to a range of cells:
 *
 * @code
 *
 *    lxw_data_validation *data_validation = calloc(1, sizeof(lxw_data_validation));
 *
 *    data_validation->validate       = LXW_VALIDATION_TYPE_INTEGER;
 *    data_validation->criteria       = LXW_VALIDATION_CRITERIA_BETWEEN;
 *    data_validation->minimum_number = 1;
 *    data_validation->maximum_number = 10;
 *
 *    worksheet_data_validation_range(worksheet, 2, 1, 4, 1, data_validation);
 *
 *    // Same as above with the RANGE() macro.
 *    worksheet_data_validation_range(worksheet, RANGE("B3:B5"), data_validation);
 *
 * @endcode
 *
 * Data validation and the various options of #lxw_data_validation are
 * described in more detail in @ref working_with_data_validation.
 *)
function worksheet_data_validation_range(worksheet: Plxw_worksheet; first_row: lxw_row_t; first_col: lxw_col_t; last_row: lxw_row_t; last_col: lxw_col_t; validation: Plxw_data_validation): lxw_error; cdecl;
  external bj name _PU + 'worksheet_data_validation_range';

(**
 * @brief Add a conditional format to a worksheet cell.
 *
 * @param worksheet           Pointer to a lxw_worksheet instance to be updated.
 * @param row                 The zero indexed row number.
 * @param col                 The zero indexed column number.
 * @param conditional_format  A #lxw_conditional_format object to control the
 *                            conditional format.
 *
 * @return A #lxw_error code.
 *
 * The `%worksheet_conditional_format_cell()` function is used to set a
 * conditional format for a cell in a worksheet:
 *
 * @code
 *     conditional_format->type     = LXW_CONDITIONAL_TYPE_CELL;
 *     conditional_format->criteria = LXW_CONDITIONAL_CRITERIA_GREATER_THAN_OR_EQUAL_TO;
 *     conditional_format->value    = 50;
 *     conditional_format->format   = format1;
 *     worksheet_conditional_format_cell(worksheet, CELL("A1"), conditional_format);
 * @endcode
 *
 * The conditional format parameters is specified in #lxw_conditional_format.
 *
 * See @ref working_with_conditional_formatting for full details.
 *)
function worksheet_conditional_format_cell(worksheet: Plxw_worksheet; row: lxw_row_t; col: lxw_col_t; conditional_format: Plxw_conditional_format): lxw_error; cdecl;
  external bj name _PU + 'worksheet_conditional_format_cell';

(**
 * @brief Add a conditional format to a worksheet range.
 *
 * @param worksheet  Pointer to a lxw_worksheet instance to be updated.
 * @param first_row  The first row of the range. (All zero indexed.)
 * @param first_col  The first column of the range.
 * @param last_row   The last row of the range.
 * @param last_col   The last col of the range.
 * @param conditional_format  A #lxw_conditional_format object to control the
 *                            conditional format.
 *
 * @return A #lxw_error code.
 *
 * The `%worksheet_conditional_format_cell()` function is used to set a
 * conditional format for a range of cells in a worksheet:
 *
 * @code
 *     conditional_format->type     = LXW_CONDITIONAL_TYPE_CELL;
 *     conditional_format->criteria = LXW_CONDITIONAL_CRITERIA_GREATER_THAN_OR_EQUAL_TO;
 *     conditional_format->value    = 50;
 *     conditional_format->format   = format1;
 *     worksheet_conditional_format_range(worksheet1, RANGE("B3:K12"), conditional_format);
 *
 *     conditional_format->type     = LXW_CONDITIONAL_TYPE_CELL;
 *     conditional_format->criteria = LXW_CONDITIONAL_CRITERIA_LESS_THAN;
 *     conditional_format->value    = 50;
 *     conditional_format->format   = format2;
 *     worksheet_conditional_format_range(worksheet1, RANGE("B3:K12"), conditional_format);
 * @endcode
 *
 * Output:
 *
 * @image html conditional_format1.png
 *
 *
 * The conditional format parameters is specified in #lxw_conditional_format.
 *
 * See @ref working_with_conditional_formatting for full details.
 *)
function worksheet_conditional_format_range(worksheet: Plxw_worksheet; first_row: lxw_row_t; first_col: lxw_col_t; last_row: lxw_row_t; last_col: lxw_col_t; conditional_format: Plxw_conditional_format): lxw_error; cdecl;
  external bj name _PU + 'worksheet_conditional_format_range';

(**
 * @brief Insert a button object into a worksheet.
 *
 * @param worksheet  Pointer to a lxw_worksheet instance to be updated.
 * @param row        The zero indexed row number.
 * @param col        The zero indexed column number.
 * @param options    A #lxw_button_options object to set the button properties.
 *
 * @return A #lxw_error code.
 *
 * The `%worksheet_insert_button()` function can be used to insert an Excel
 * form button into a worksheet. This function is generally only useful when
 * used in conjunction with the `workbook_add_vba_project()` function to tie
 * the button to a macro from an embedded VBA project:
 *
 * @code
 *     lxw_button_options options = {.caption = "Press Me",
 *                                   .macro   = "say_hello"};
 *
 *     worksheet_insert_button(worksheet, 2, 1, &options);
 * @endcode
 *
 * @image html macros.png
 *
 * The button properties are set using the lxw_button_options struct.
 *
 * See also @ref working_with_macros
 *)
function worksheet_insert_button(worksheet: Plxw_worksheet; row: lxw_row_t; col: lxw_col_t; options: Plxw_button_options): lxw_error; cdecl;
  external bj name _PU + 'worksheet_insert_button';

(**
 * @brief Add an Excel table to a worksheet.
 *
 * @param worksheet  Pointer to a lxw_worksheet instance to be updated.
 * @param first_row  The first row of the range. (All zero indexed.)
 * @param first_col  The first column of the range.
 * @param last_row   The last row of the range.
 * @param last_col   The last col of the range.
 * @param options    A #lxw_table_options struct to define the table options.
 *
 * @return A #lxw_error code.
 *
 * The `%worksheet_add_table()` function is used to add a table to a
 * worksheet. Tables in Excel are a way of grouping a range of cells into a
 * single entity that has common formatting or that can be referenced from
 * formulas. Tables can have column headers, autofilters, total rows, column
 * formulas and default formatting.
 *
 * @code
 *     worksheet_add_table(worksheet, 2, 1, 6, 5, NULL);
 * @endcode
 *
 * Output:
 *
 * @image html tables1.png
 *
 * See @ref working_with_tables for more detailed usage information and also
 * @ref tables.c.
 *
 *)
function worksheet_add_table(worksheet: Plxw_worksheet; first_row: lxw_row_t; first_col: lxw_col_t; last_row: lxw_row_t; last_col: lxw_col_t; options: Plxw_table_options): lxw_error; cdecl;
  external bj name _PU + 'worksheet_add_table';

(**
 * @brief Make a worksheet the active, i.e., visible worksheet.
 *
 * @param worksheet Pointer to a lxw_worksheet instance to be updated.
 *
 * The `%worksheet_activate()` function is used to specify which worksheet is
 * initially visible in a multi-sheet workbook:
 *
 * @code
 *     lxw_worksheet *worksheet1 = workbook_add_worksheet(workbook, NULL);
 *     lxw_worksheet *worksheet2 = workbook_add_worksheet(workbook, NULL);
 *     lxw_worksheet *worksheet3 = workbook_add_worksheet(workbook, NULL);
 *
 *     worksheet_activate(worksheet3);
 * @endcode
 *
 * @image html worksheet_activate.png
 *
 * More than one worksheet can be selected via the `worksheet_select()`
 * function, see below, however only one worksheet can be active.
 *
 * The default active worksheet is the first worksheet.
 *
 *)
procedure worksheet_activate(worksheet: Plxw_worksheet); cdecl;
  external bj name _PU + 'worksheet_activate';

(**
 * @brief Set a worksheet tab as selected.
 *
 * @param worksheet Pointer to a lxw_worksheet instance to be updated.
 *
 * The `%worksheet_select()` function is used to indicate that a worksheet is
 * selected in a multi-sheet workbook:
 *
 * @code
 *     worksheet_activate(worksheet1);
 *     worksheet_select(worksheet2);
 *     worksheet_select(worksheet3);
 *
 * @endcode
 *
 * A selected worksheet has its tab highlighted. Selecting worksheets is a
 * way of grouping them together so that, for example, several worksheets
 * could be printed in one go. A worksheet that has been activated via the
 * `worksheet_activate()` function will also appear as selected.
 *
 *)
procedure worksheet_select(worksheet: Plxw_worksheet); cdecl;
  external bj name _PU + 'worksheet_select';

(**
 * @brief Hide the current worksheet.
 *
 * @param worksheet Pointer to a lxw_worksheet instance to be updated.
 *
 * The `%worksheet_hide()` function is used to hide a worksheet:
 *
 * @code
 *     worksheet_hide(worksheet2);
 * @endcode
 *
 * You may wish to hide a worksheet in order to avoid confusing a user with
 * intermediate data or calculations.
 *
 * @image html hide_sheet.png
 *
 * A hidden worksheet can not be activated or selected so this function is
 * mutually exclusive with the `worksheet_activate()` and `worksheet_select()`
 * functions. In addition, since the first worksheet will default to being the
 * active worksheet, you cannot hide the first worksheet without activating
 * another sheet:
 *
 * @code
 *     worksheet_activate(worksheet2);
 *     worksheet_hide(worksheet1);
 * @endcode
 *)
procedure worksheet_hide(worksheet: Plxw_worksheet); cdecl;
  external bj name _PU + 'worksheet_hide';

(**
 * @brief Set current worksheet as the first visible sheet tab.
 *
 * @param worksheet Pointer to a lxw_worksheet instance to be updated.
 *
 * The `worksheet_activate()` function determines which worksheet is initially
 * selected.  However, if there are a large number of worksheets the selected
 * worksheet may not appear on the screen. To avoid this you can select the
 * leftmost visible worksheet tab using `%worksheet_set_first_sheet()`:
 *
 * @code
 *     worksheet_set_first_sheet(worksheet19); // First visible worksheet tab.
 *     worksheet_activate(worksheet20);        // First visible worksheet.
 * @endcode
 *
 * This function is not required very often. The default value is the first
 * worksheet.
 *)
procedure worksheet_set_first_sheet(worksheet: Plxw_worksheet); cdecl;
  external bj name _PU + 'worksheet_set_first_sheet';

(**
 * @brief Split and freeze a worksheet into panes.
 *
 * @param worksheet Pointer to a lxw_worksheet instance to be updated.
 * @param row       The cell row (zero indexed).
 * @param col       The cell column (zero indexed).
 *
 * The `%worksheet_freeze_panes()` function can be used to divide a worksheet
 * into horizontal or vertical regions known as panes and to "freeze" these
 * panes so that the splitter bars are not visible.
 *
 * The parameters `row` and `col` are used to specify the location of the
 * split. It should be noted that the split is specified at the top or left of
 * a cell and that the function uses zero based indexing. Therefore to freeze
 * the first row of a worksheet it is necessary to specify the split at row 2
 * (which is 1 as the zero-based index).
 *
 * You can set one of the `row` and `col` parameters as zero if you do not
 * want either a vertical or horizontal split.
 *
 * Examples:
 *
 * @code
 *     worksheet_freeze_panes(worksheet1, 1, 0); // Freeze the first row.
 *     worksheet_freeze_panes(worksheet2, 0, 1); // Freeze the first column.
 *     worksheet_freeze_panes(worksheet3, 1, 1); // Freeze first row/column.
 *
 * @endcode
 *
 *)
procedure worksheet_freeze_panes(worksheet: Plxw_worksheet; row: lxw_row_t; col: lxw_col_t); cdecl;
  external bj name _PU + 'worksheet_freeze_panes';

(**
 * @brief Split a worksheet into panes.
 *
 * @param worksheet  Pointer to a lxw_worksheet instance to be updated.
 * @param vertical   The position for the vertical split.
 * @param horizontal The position for the horizontal split.
 *
 * The `%worksheet_split_panes()` function can be used to divide a worksheet
 * into horizontal or vertical regions known as panes. This function is
 * different from the `worksheet_freeze_panes()` function in that the splits
 * between the panes will be visible to the user and each pane will have its
 * own scroll bars.
 *
 * The parameters `vertical` and `horizontal` are used to specify the vertical
 * and horizontal position of the split. The units for `vertical` and
 * `horizontal` are the same as those used by Excel to specify row height and
 * column width. However, the vertical and horizontal units are different from
 * each other. Therefore you must specify the `vertical` and `horizontal`
 * parameters in terms of the row heights and column widths that you have set
 * or the default values which are 15 for a row and 8.43 for a column.
 *
 * Examples:
 *
 * @code
 *     worksheet_split_panes(worksheet1, 15, 0);    // First row.
 *     worksheet_split_panes(worksheet2, 0,  8.43); // First column.
 *     worksheet_split_panes(worksheet3, 15, 8.43); // First row and column.
 *
 * @endcode
 *
 *)
procedure worksheet_split_panes(worksheet: Plxw_worksheet; vertical: Double; horizontal: Double); cdecl;
  external bj name _PU + 'worksheet_split_panes';

procedure worksheet_freeze_panes_opt(worksheet: Plxw_worksheet; first_row: lxw_row_t; first_col: lxw_col_t; top_row: lxw_row_t; left_col: lxw_col_t; atype: UInt8); cdecl;
  external bj name _PU + 'worksheet_freeze_panes_opt';

procedure worksheet_split_panes_opt(worksheet: Plxw_worksheet; vertical: Double; horizontal: Double; top_row: lxw_row_t; left_col: lxw_col_t); cdecl;
  external bj name _PU + 'worksheet_split_panes_opt';

(**
 * @brief Set the selected cell or cells in a worksheet:
 *
 * @param worksheet   A pointer to a lxw_worksheet instance to be updated.
 * @param first_row   The first row of the range. (All zero indexed.)
 * @param first_col   The first column of the range.
 * @param last_row    The last row of the range.
 * @param last_col    The last col of the range.
 *
 *
 * The `%worksheet_set_selection()` function can be used to specify which cell
 * or range of cells is selected in a worksheet: The most common requirement
 * is to select a single cell, in which case the `first_` and `last_`
 * parameters should be the same.
 *
 * The active cell within a selected range is determined by the order in which
 * `first_` and `last_` are specified.
 *
 * Examples:
 *
 * @code
 *     worksheet_set_selection(worksheet1, 3, 3, 3, 3);     // Cell D4.
 *     worksheet_set_selection(worksheet2, 3, 3, 6, 6);     // Cells D4 to G7.
 *     worksheet_set_selection(worksheet3, 6, 6, 3, 3);     // Cells G7 to D4.
 *     worksheet_set_selection(worksheet5, RANGE("D4:G7")); // Using the RANGE macro.
 *
 * @endcode
 *
 *)
function worksheet_set_selection(worksheet: Plxw_worksheet; first_row: lxw_row_t; first_col: lxw_col_t; last_row: lxw_row_t; last_col: lxw_col_t): lxw_error; cdecl;
  external bj name _PU + 'worksheet_set_selection';

(**
 * @brief Set the first visible cell at the top left of a worksheet.
 *
 * @param worksheet Pointer to a lxw_worksheet instance to be updated.
 * @param row       The cell row (zero indexed).
 * @param col       The cell column (zero indexed).
 *
 * The `%worksheet_set_top_left_cell()` function can be used to set the
 * top leftmost visible cell in the worksheet:
 *
 * @code
 *     worksheet_set_top_left_cell(worksheet, 31, 26);
 *     worksheet_set_top_left_cell(worksheet, CELL("AA32")); // Same as above.
 * @endcode
 *
 * @image html top_left_cell.png
 *
 *)
procedure worksheet_set_top_left_cell(worksheet: Plxw_worksheet; row: lxw_row_t; col: lxw_col_t); cdecl;
  external bj name _PU + 'worksheet_set_top_left_cell';

(**
 * @brief Set the page orientation as landscape.
 *
 * @param worksheet Pointer to a lxw_worksheet instance to be updated.
 *
 * This function is used to set the orientation of a worksheet's printed page
 * to landscape:
 *
 * @code
 *     worksheet_set_landscape(worksheet);
 * @endcode
 *)
procedure worksheet_set_landscape(worksheet: Plxw_worksheet); cdecl;
  external bj name _PU + 'worksheet_set_landscape';

(**
 * @brief Set the page orientation as portrait.
 *
 * @param worksheet Pointer to a lxw_worksheet instance to be updated.
 *
 * This function is used to set the orientation of a worksheet's printed page
 * to portrait. The default worksheet orientation is portrait, so this
 * function isn't generally required:
 *
 * @code
 *     worksheet_set_portrait(worksheet);
 * @endcode
 *)
procedure worksheet_set_portrait(worksheet: Plxw_worksheet); cdecl;
  external bj name _PU + 'worksheet_set_portrait';

(**
 * @brief Set the page layout to page view mode.
 *
 * @param worksheet Pointer to a lxw_worksheet instance to be updated.
 *
 * This function is used to display the worksheet in "Page View/Layout" mode:
 *
 * @code
 *     worksheet_set_page_view(worksheet);
 * @endcode
 *)
procedure worksheet_set_page_view(worksheet: Plxw_worksheet); cdecl;
  external bj name _PU + 'worksheet_set_page_view';

(**
 * @brief Set the paper type for printing.
 *
 * @param worksheet Pointer to a lxw_worksheet instance to be updated.
 * @param paper_type The Excel paper format type.
 *
 * This function is used to set the paper format for the printed output of a
 * worksheet. The following paper styles are available:
 *
 *
 *   Index    | Paper format            | Paper size
 *   :------- | :---------------------- | :-------------------
 *   0        | Printer default         | Printer default
 *   1        | Letter                  | 8 1/2 x 11 in
 *   2        | Letter Small            | 8 1/2 x 11 in
 *   3        | Tabloid                 | 11 x 17 in
 *   4        | Ledger                  | 17 x 11 in
 *   5        | Legal                   | 8 1/2 x 14 in
 *   6        | Statement               | 5 1/2 x 8 1/2 in
 *   7        | Executive               | 7 1/4 x 10 1/2 in
 *   8        | A3                      | 297 x 420 mm
 *   9        | A4                      | 210 x 297 mm
 *   10       | A4 Small                | 210 x 297 mm
 *   11       | A5                      | 148 x 210 mm
 *   12       | B4                      | 250 x 354 mm
 *   13       | B5                      | 182 x 257 mm
 *   14       | Folio                   | 8 1/2 x 13 in
 *   15       | Quarto                  | 215 x 275 mm
 *   16       | ---                     | 10x14 in
 *   17       | ---                     | 11x17 in
 *   18       | Note                    | 8 1/2 x 11 in
 *   19       | Envelope 9              | 3 7/8 x 8 7/8
 *   20       | Envelope 10             | 4 1/8 x 9 1/2
 *   21       | Envelope 11             | 4 1/2 x 10 3/8
 *   22       | Envelope 12             | 4 3/4 x 11
 *   23       | Envelope 14             | 5 x 11 1/2
 *   24       | C size sheet            | ---
 *   25       | D size sheet            | ---
 *   26       | E size sheet            | ---
 *   27       | Envelope DL             | 110 x 220 mm
 *   28       | Envelope C3             | 324 x 458 mm
 *   29       | Envelope C4             | 229 x 324 mm
 *   30       | Envelope C5             | 162 x 229 mm
 *   31       | Envelope C6             | 114 x 162 mm
 *   32       | Envelope C65            | 114 x 229 mm
 *   33       | Envelope B4             | 250 x 353 mm
 *   34       | Envelope B5             | 176 x 250 mm
 *   35       | Envelope B6             | 176 x 125 mm
 *   36       | Envelope                | 110 x 230 mm
 *   37       | Monarch                 | 3.875 x 7.5 in
 *   38       | Envelope                | 3 5/8 x 6 1/2 in
 *   39       | Fanfold                 | 14 7/8 x 11 in
 *   40       | German Std Fanfold      | 8 1/2 x 12 in
 *   41       | German Legal Fanfold    | 8 1/2 x 13 in
 *
 * Note, it is likely that not all of these paper types will be available to
 * the end user since it will depend on the paper formats that the user's
 * printer supports. Therefore, it is best to stick to standard paper types:
 *
 * @code
 *     worksheet_set_paper(worksheet1, 1);  // US Letter
 *     worksheet_set_paper(worksheet2, 9);  // A4
 * @endcode
 *
 * If you do not specify a paper type the worksheet will print using the
 * printer's default paper style.
 *)
procedure worksheet_set_paper(worksheet: Plxw_worksheet; paper_type: UInt8); cdecl;
  external bj name _PU + 'worksheet_set_paper';

(**
 * @brief Set the worksheet margins for the printed page.
 *
 * @param worksheet Pointer to a lxw_worksheet instance to be updated.
 * @param left    Left margin in inches.   Excel default is 0.7.
 * @param right   Right margin in inches.  Excel default is 0.7.
 * @param top     Top margin in inches.    Excel default is 0.75.
 * @param bottom  Bottom margin in inches. Excel default is 0.75.
 *
 * The `%worksheet_set_margins()` function is used to set the margins of the
 * worksheet when it is printed. The units are in inches. Specifying `-1` for
 * any parameter will give the default Excel value as shown above.
 *
 * @code
 *    worksheet_set_margins(worksheet, 1.3, 1.2, -1, -1);
 * @endcode
 *
 *)
procedure worksheet_set_margins(worksheet: Plxw_worksheet; left: Double; right: Double; top: Double; bottom: Double); cdecl;
  external bj name _PU + 'worksheet_set_margins';

(**
 * @brief Set the printed page header caption.
 *
 * @param worksheet Pointer to a lxw_worksheet instance to be updated.
 * @param string    The header string.
 *
 * @return A #lxw_error code.
 *
 * Headers and footers are generated using a string which is a combination of
 * plain text and control characters.
 *
 * The available control character are:
 *
 *
 *   | Control         | Category      | Description           |
 *   | --------------- | ------------- | --------------------- |
 *   | `&L`            | Justification | Left                  |
 *   | `&C`            |               | Center                |
 *   | `&R`            |               | Right                 |
 *   | `&P`            | Information   | Page number           |
 *   | `&N`            |               | Total number of pages |
 *   | `&D`            |               | Date                  |
 *   | `&T`            |               | Time                  |
 *   | `&F`            |               | File name             |
 *   | `&A`            |               | Worksheet name        |
 *   | `&Z`            |               | Workbook path         |
 *   | `&fontsize`     | Font          | Font size             |
 *   | `&"font,style"` |               | Font name and style   |
 *   | `&U`            |               | Single underline      |
 *   | `&E`            |               | Double underline      |
 *   | `&S`            |               | Strikethrough         |
 *   | `&X`            |               | Superscript           |
 *   | `&Y`            |               | Subscript             |
 *   | `&[Picture]`    | Images        | Image placeholder     |
 *   | `&G`            |               | Same as `&[Picture]`  |
 *   | `&&`            | Miscellaneous | Literal ampersand &   |
 *
 * Note: inserting images requires the `worksheet_set_header_opt()` function.
 *
 * Text in headers and footers can be justified (aligned) to the left, center
 * and right by prefixing the text with the control characters `&L`, `&C` and
 * `&R`.
 *
 * For example (with ASCII art representation of the results):
 *
 * @code
 *     worksheet_set_header(worksheet, "&LHello");
 *
 *     //     ---------------------------------------------------------------
 *     //    |                                                               |
 *     //    | Hello                                                         |
 *     //    |                                                               |
 *
 *
 *     worksheet_set_header(worksheet, "&CHello");
 *
 *     //     ---------------------------------------------------------------
 *     //    |                                                               |
 *     //    |                          Hello                                |
 *     //    |                                                               |
 *
 *
 *     worksheet_set_header(worksheet, "&RHello");
 *
 *     //     ---------------------------------------------------------------
 *     //    |                                                               |
 *     //    |                                                         Hello |
 *     //    |                                                               |
 *
 *
 * @endcode
 *
 * For simple text, if you do not specify any justification the text will be
 * centered. However, you must prefix the text with `&C` if you specify a font
 * name or any other formatting:
 *
 * @code
 *     worksheet_set_header(worksheet, "Hello");
 *
 *     //     ---------------------------------------------------------------
 *     //    |                                                               |
 *     //    |                          Hello                                |
 *     //    |                                                               |
 *
 * @endcode
 *
 * You can have text in each of the justification regions:
 *
 * @code
 *     worksheet_set_header(worksheet, "&LCiao&CBello&RCielo");
 *
 *     //     ---------------------------------------------------------------
 *     //    |                                                               |
 *     //    | Ciao                     Bello                          Cielo |
 *     //    |                                                               |
 *
 * @endcode
 *
 * The information control characters act as variables that Excel will update
 * as the workbook or worksheet changes. Times and dates are in the users
 * default format:
 *
 * @code
 *     worksheet_set_header(worksheet, "&CPage &P of &N");
 *
 *     //     ---------------------------------------------------------------
 *     //    |                                                               |
 *     //    |                        Page 1 of 6                            |
 *     //    |                                                               |
 *
 *     worksheet_set_header(worksheet, "&CUpdated at &T");
 *
 *     //     ---------------------------------------------------------------
 *     //    |                                                               |
 *     //    |                    Updated at 12:30 PM                        |
 *     //    |                                                               |
 *
 * @endcode
 *
 * You can specify the font size of a section of the text by prefixing it with
 * the control character `&n` where `n` is the font size:
 *
 * @code
 *     worksheet_set_header(worksheet1, "&C&30Hello Big");
 *     worksheet_set_header(worksheet2, "&C&10Hello Small");
 *
 * @endcode
 *
 * You can specify the font of a section of the text by prefixing it with the
 * control sequence `&"font,style"` where `fontname` is a font name such as
 * Windows font descriptions: "Regular", "Italic", "Bold" or "Bold Italic":
 * "Courier New" or "Times New Roman" and `style` is one of the standard
 *
 * @code
 *     worksheet_set_header(worksheet1, "&C&\"Courier New,Italic\"Hello");
 *     worksheet_set_header(worksheet2, "&C&\"Courier New,Bold Italic\"Hello");
 *     worksheet_set_header(worksheet3, "&C&\"Times New Roman,Regular\"Hello");
 *
 * @endcode
 *
 * It is possible to combine all of these features together to create
 * sophisticated headers and footers. As an aid to setting up complicated
 * headers and footers you can record a page set-up as a macro in Excel and
 * look at the format strings that VBA produces. Remember however that VBA
 * uses two double quotes `""` to indicate a single double quote. For the last
 * example above the equivalent VBA code looks like this:
 *
 * @code
 *     .LeftHeader = ""
 *     .CenterHeader = "&""Times New Roman,Regular""Hello"
 *     .RightHeader = ""
 *
 * @endcode
 *
 * Alternatively you can inspect the header and footer strings in an Excel
 * file by unzipping it and grepping the XML sub-files. The following shows
 * how to do that using libxml's xmllint to format the XML for clarity:
 *
 * @code
 *
 *    $ unzip myfile.xlsm -d myfile
 *    $ xmllint --format `find myfile -name "*.xml" | xargs` | egrep "Header|Footer" | sed 's/&amp;/\&/g'
 *
 *      <headerFooter scaleWithDoc="0">
 *        <oddHeader>&L&P</oddHeader>
 *      </headerFooter>
 *
 * @endcode
 *
 * To include a single literal ampersand `&` in a header or footer you should
 * use a double ampersand `&&`:
 *
 * @code
 *     worksheet_set_header(worksheet, "&CCuriouser && Curiouser - Attorneys at Law");
 * @endcode
 *
 * @note
 * Excel requires that the header or footer string cannot be longer than 255
 * characters, including the control characters. Strings longer than this will
 * not be written.
 *
 *)
function worksheet_set_header(worksheet: Plxw_worksheet; const astring: PUTF8Char): lxw_error; cdecl;
  external bj name _PU + 'worksheet_set_header';

(**
 * @brief Set the printed page footer caption.
 *
 * @param worksheet Pointer to a lxw_worksheet instance to be updated.
 * @param string    The footer string.
 *
 * @return A #lxw_error code.
 *
 * The syntax of this function is the same as worksheet_set_header().
 *
 *)
function worksheet_set_footer(worksheet: Plxw_worksheet; const astring: PUTF8Char): lxw_error; cdecl;
  external bj name _PU + 'worksheet_set_footer';

(**
 * @brief Set the printed page header caption with additional options.
 *
 * @param worksheet Pointer to a lxw_worksheet instance to be updated.
 * @param string    The header string.
 * @param options   Header options.
 *
 * @return A #lxw_error code.
 *
 * The syntax of this function is the same as `worksheet_set_header()` with an
 * additional parameter to specify options for the header.
 *
 * The #lxw_header_footer_options options are:
 *
 * - `margin`: Header or footer margin in inches. The value must by larger
 *   than 0.0. The Excel default is 0.3.
 *
 * - `image_left`: The left header image filename, with path if required. This
 *   should have a corresponding `&G/&[Picture]` placeholder in the `&L`
 *   section of the header/footer string.
 *
 * - `image_center`: The center header image filename, with path if
 *   required. This should have a corresponding `&G/&[Picture]` placeholder in
 *   the `&C` section of the header/footer string.
 *
 * - `image_right`: The right header image filename, with path if
 *   required. This should have a corresponding `&G/&[Picture]` placeholder in
 *   the `&R` section of the header/footer string.
 *
 * @code
 *     lxw_header_footer_options header_options = { .margin = 0.2 };
 *
 *     worksheet_set_header_opt(worksheet, "Some text", &header_options);
 * @endcode
 *
 * Images can be inserted in the header by specifying the `&[Picture]`
 * placeholder and a filename/path to the image:
 *
 * @code
 *     lxw_header_footer_options header_options = {.image_left = "logo.png"};
 *
 *    worksheet_set_header_opt(worksheet, "&L&[Picture]", &header_options);
 * @endcode
 *
 * @image html headers_footers.png
 *
 *)
function worksheet_set_header_opt(worksheet: Plxw_worksheet; const astring: PUTF8Char; options: Plxw_header_footer_options): lxw_error; cdecl;
  external bj name _PU + 'worksheet_set_header_opt';

(**
 * @brief Set the printed page footer caption with additional options.
 *
 * @param worksheet Pointer to a lxw_worksheet instance to be updated.
 * @param string    The footer string.
 * @param options   Footer options.
 *
 * @return A #lxw_error code.
 *
 * The syntax of this function is the same as `worksheet_set_header_opt()`.
 *
 *)
function worksheet_set_footer_opt(worksheet: Plxw_worksheet; const astring: PUTF8Char; options: Plxw_header_footer_options): lxw_error; cdecl;
  external bj name _PU + 'worksheet_set_footer_opt';

(**
 * @brief Set the horizontal page breaks on a worksheet.
 *
 * @param worksheet Pointer to a lxw_worksheet instance to be updated.
 * @param breaks    Array of page breaks.
 *
 * @return A #lxw_error code.
 *
 * The `%worksheet_set_h_pagebreaks()` function adds horizontal page breaks to
 * a worksheet. A page break causes all the data that follows it to be printed
 * on the next page. Horizontal page breaks act between rows.
 *
 * The function takes an array of one or more page breaks. The type of the
 * array data is @ref lxw_row_t and the last element of the array must be 0:
 *
 * @code
 *    lxw_row_t breaks1[] = {20, 0}; // 1 page break. Zero indicates the end.
 *    lxw_row_t breaks2[] = {20, 40, 60, 80, 0};
 *
 *    worksheet_set_h_pagebreaks(worksheet1, breaks1);
 *    worksheet_set_h_pagebreaks(worksheet2, breaks2);
 * @endcode
 *
 * To create a page break between rows 20 and 21 you must specify the break at
 * row 21. However in zero index notation this is actually row 20:
 *
 * @code
 *    // Break between row 20 and 21.
 *    lxw_row_t breaks[] = {20, 0};
 *
 *    worksheet_set_h_pagebreaks(worksheet, breaks);
 * @endcode
 *
 * There is an Excel limitation of 1023 horizontal page breaks per worksheet.
 *
 * Note: If you specify the "fit to page" option via the
 * `worksheet_fit_to_pages()` function it will override all manual page
 * breaks.
 *
 *)
function worksheet_set_h_pagebreaks(worksheet: Plxw_worksheet; breaks: Plxw_row_t): lxw_error; cdecl;
  external bj name _PU + 'worksheet_set_h_pagebreaks';

(**
 * @brief Set the vertical page breaks on a worksheet.
 *
 * @param worksheet Pointer to a lxw_worksheet instance to be updated.
 * @param breaks    Array of page breaks.
 *
 * @return A #lxw_error code.
 *
 * The `%worksheet_set_v_pagebreaks()` function adds vertical page breaks to a
 * worksheet. A page break causes all the data that follows it to be printed
 * on the next page. Vertical page breaks act between columns.
 *
 * The function takes an array of one or more page breaks. The type of the
 * array data is @ref lxw_col_t and the last element of the array must be 0:
 *
 * @code
 *    lxw_col_t breaks1[] = {20, 0}; // 1 page break. Zero indicates the end.
 *    lxw_col_t breaks2[] = {20, 40, 60, 80, 0};
 *
 *    worksheet_set_v_pagebreaks(worksheet1, breaks1);
 *    worksheet_set_v_pagebreaks(worksheet2, breaks2);
 * @endcode
 *
 * To create a page break between columns 20 and 21 you must specify the break
 * at column 21. However in zero index notation this is actually column 20:
 *
 * @code
 *    // Break between column 20 and 21.
 *    lxw_col_t breaks[] = {20, 0};
 *
 *    worksheet_set_v_pagebreaks(worksheet, breaks);
 * @endcode
 *
 * There is an Excel limitation of 1023 vertical page breaks per worksheet.
 *
 * Note: If you specify the "fit to page" option via the
 * `worksheet_fit_to_pages()` function it will override all manual page
 * breaks.
 *
 *)
function worksheet_set_v_pagebreaks(worksheet: Plxw_worksheet; breaks: Plxw_col_t): lxw_error; cdecl;
  external bj name _PU + 'worksheet_set_v_pagebreaks';

(**
 * @brief Set the order in which pages are printed.
 *
 * @param worksheet Pointer to a lxw_worksheet instance to be updated.
 *
 * The `%worksheet_print_across()` function is used to change the default
 * print direction. This is referred to by Excel as the sheet "page order":
 *
 * @code
 *     worksheet_print_across(worksheet);
 * @endcode
 *
 * The default page order is shown below for a worksheet that extends over 4
 * pages. The order is called "down then across":
 *
 *     [1] [3]
 *     [2] [4]
 *
 * However, by using the `print_across` function the print order will be
 * changed to "across then down":
 *
 *     [1] [2]
 *     [3] [4]
 *
 *)
procedure worksheet_print_across(worksheet: Plxw_worksheet); cdecl;
  external bj name _PU + 'worksheet_print_across';

(**
 * @brief Set the worksheet zoom factor.
 *
 * @param worksheet Pointer to a lxw_worksheet instance to be updated.
 * @param scale     Worksheet zoom factor.
 *
 * Set the worksheet zoom factor in the range `10 <= zoom <= 400`:
 *
 * @code
 *     worksheet_set_zoom(worksheet1, 50);
 *     worksheet_set_zoom(worksheet2, 75);
 *     worksheet_set_zoom(worksheet3, 300);
 *     worksheet_set_zoom(worksheet4, 400);
 * @endcode
 *
 * The default zoom factor is 100. It isn't possible to set the zoom to
 * "Selection" because it is calculated by Excel at run-time.
 *
 * Note, `%worksheet_zoom()` does not affect the scale of the printed
 * page. For that you should use `worksheet_set_print_scale()`.
 *)
procedure worksheet_set_zoom(worksheet: Plxw_worksheet; scale: UInt16); cdecl;
  external bj name _PU + 'worksheet_set_zoom';

(**
 * @brief Set the option to display or hide gridlines on the screen and
 *        the printed page.
 *
 * @param worksheet Pointer to a lxw_worksheet instance to be updated.
 * @param option    Gridline option.
 *
 * Display or hide screen and print gridlines using one of the values of
 * @ref lxw_gridlines.
 *
 * @code
 *    worksheet_gridlines(worksheet1, LXW_HIDE_ALL_GRIDLINES);
 *
 *    worksheet_gridlines(worksheet2, LXW_SHOW_PRINT_GRIDLINES);
 * @endcode
 *
 * The Excel default is that the screen gridlines are on  and the printed
 * worksheet is off.
 *
 *)
procedure worksheet_gridlines(worksheet: Plxw_worksheet; option: UInt8); cdecl;
  external bj name _PU + 'worksheet_gridlines';

(**
 * @brief Center the printed page horizontally.
 *
 * @param worksheet Pointer to a lxw_worksheet instance to be updated.
 *
 * Center the worksheet data horizontally between the margins on the printed
 * page:
 *
 * @code
 *     worksheet_center_horizontally(worksheet);
 * @endcode
 *
 *)
procedure worksheet_center_horizontally(worksheet: Plxw_worksheet); cdecl;
  external bj name _PU + 'worksheet_center_horizontally';

(**
 * @brief Center the printed page vertically.
 *
 * @param worksheet Pointer to a lxw_worksheet instance to be updated.
 *
 * Center the worksheet data vertically between the margins on the printed
 * page:
 *
 * @code
 *     worksheet_center_vertically(worksheet);
 * @endcode
 *
 *)
procedure worksheet_center_vertically(worksheet: Plxw_worksheet); cdecl;
  external bj name _PU + 'worksheet_center_vertically';

(**
 * @brief Set the option to print the row and column headers on the printed
 *        page.
 *
 * @param worksheet Pointer to a lxw_worksheet instance to be updated.
 *
 * When printing a worksheet from Excel the row and column headers (the row
 * numbers on the left and the column letters at the top) aren't printed by
 * default.
 *
 * This function sets the printer option to print these headers:
 *
 * @code
 *    worksheet_print_row_col_headers(worksheet);
 * @endcode
 *
 *)
procedure worksheet_print_row_col_headers(worksheet: Plxw_worksheet); cdecl;
  external bj name _PU + 'worksheet_print_row_col_headers';

(**
 * @brief Set the number of rows to repeat at the top of each printed page.
 *
 * @param worksheet Pointer to a lxw_worksheet instance to be updated.
 * @param first_row First row of repeat range.
 * @param last_row  Last row of repeat range.
 *
 * @return A #lxw_error code.
 *
 * For large Excel documents it is often desirable to have the first row or
 * rows of the worksheet print out at the top of each page.
 *
 * This can be achieved by using this function. The parameters `first_row`
 * and `last_row` are zero based:
 *
 * @code
 *     worksheet_repeat_rows(worksheet, 0, 0); // Repeat the first row.
 *     worksheet_repeat_rows(worksheet, 0, 1); // Repeat the first two rows.
 * @endcode
 *)
function worksheet_repeat_rows(worksheet: Plxw_worksheet; first_row: lxw_row_t; last_row: lxw_row_t): lxw_error; cdecl;
  external bj name _PU + 'worksheet_repeat_rows';

(**
 * @brief Set the number of columns to repeat at the top of each printed page.
 *
 * @param worksheet Pointer to a lxw_worksheet instance to be updated.
 * @param first_col First column of repeat range.
 * @param last_col  Last column of repeat range.
 *
 * @return A #lxw_error code.
 *
 * For large Excel documents it is often desirable to have the first column or
 * columns of the worksheet print out at the left of each page.
 *
 * This can be achieved by using this function. The parameters `first_col`
 * and `last_col` are zero based:
 *
 * @code
 *     worksheet_repeat_columns(worksheet, 0, 0); // Repeat the first col.
 *     worksheet_repeat_columns(worksheet, 0, 1); // Repeat the first two cols.
 * @endcode
 *)
function worksheet_repeat_columns(worksheet: Plxw_worksheet; first_col: lxw_col_t; last_col: lxw_col_t): lxw_error; cdecl;
  external bj name _PU + 'worksheet_repeat_columns';

(**
 * @brief Set the print area for a worksheet.
 *
 * @param worksheet Pointer to a lxw_worksheet instance to be updated.
 * @param first_row The first row of the range. (All zero indexed.)
 * @param first_col The first column of the range.
 * @param last_row  The last row of the range.
 * @param last_col  The last col of the range.
 *
 * @return A #lxw_error code.
 *
 * This function is used to specify the area of the worksheet that will be
 * printed. The RANGE() macro is often convenient for this.
 *
 * @code
 *     worksheet_print_area(worksheet, 0, 0, 41, 10); // A1:K42.
 *
 *     // Same as:
 *     worksheet_print_area(worksheet, RANGE("A1:K42"));
 * @endcode
 *
 * In order to set a row or column range you must specify the entire range:
 *
 * @code
 *     worksheet_print_area(worksheet, RANGE("A1:H1048576")); // Same as A:H.
 * @endcode
 *)
function worksheet_print_area(worksheet: Plxw_worksheet; first_row: lxw_row_t; first_col: lxw_col_t; last_row: lxw_row_t; last_col: lxw_col_t): lxw_error; cdecl;
  external bj name _PU + 'worksheet_print_area';

(**
 * @brief Fit the printed area to a specific number of pages both vertically
 *        and horizontally.
 *
 * @param worksheet Pointer to a lxw_worksheet instance to be updated.
 * @param width     Number of pages horizontally.
 * @param height    Number of pages vertically.
 *
 * The `%worksheet_fit_to_pages()` function is used to fit the printed area to
 * a specific number of pages both vertically and horizontally. If the printed
 * area exceeds the specified number of pages it will be scaled down to
 * fit. This ensures that the printed area will always appear on the specified
 * number of pages even if the page size or margins change:
 *
 * @code
 *     worksheet_fit_to_pages(worksheet1, 1, 1); // Fit to 1x1 pages.
 *     worksheet_fit_to_pages(worksheet2, 2, 1); // Fit to 2x1 pages.
 *     worksheet_fit_to_pages(worksheet3, 1, 2); // Fit to 1x2 pages.
 * @endcode
 *
 * The print area can be defined using the `worksheet_print_area()` function
 * as described above.
 *
 * A common requirement is to fit the printed output to `n` pages wide but
 * have the height be as long as necessary. To achieve this set the `height`
 * to zero:
 *
 * @code
 *     // 1 page wide and as long as necessary.
 *     worksheet_fit_to_pages(worksheet, 1, 0);
 * @endcode
 *
 * **Note**:
 *
 * - Although it is valid to use both `%worksheet_fit_to_pages()` and
 *   `worksheet_set_print_scale()` on the same worksheet Excel only allows one
 *   of these options to be active at a time. The last function call made will
 *   set the active option.
 *
 * - The `%worksheet_fit_to_pages()` function will override any manual page
 *   breaks that are defined in the worksheet.
 *
 * - When using `%worksheet_fit_to_pages()` it may also be required to set the
 *   printer paper size using `worksheet_set_paper()` or else Excel will
 *   default to "US Letter".
 *
 *)
procedure worksheet_fit_to_pages(worksheet: Plxw_worksheet; width: UInt16; height: UInt16); cdecl;
  external bj name _PU + 'worksheet_fit_to_pages';

(**
 * @brief Set the start/first page number when printing.
 *
 * @param worksheet  Pointer to a lxw_worksheet instance to be updated.
 * @param start_page Page number of the starting page when printing.
 *
 * The `%worksheet_set_start_page()` function is used to set the number number
 * of the first page when the worksheet is printed out. It is the same as the
 * "First Page Number" option in Excel:
 *
 * @code
 *     // Start print from page 2.
 *     worksheet_set_start_page(worksheet, 2);
 * @endcode
 *)
procedure worksheet_set_start_page(worksheet: Plxw_worksheet; start_page: UInt16); cdecl;
  external bj name _PU + 'worksheet_set_start_page';

(**
 * @brief Set the scale factor for the printed page.
 *
 * @param worksheet Pointer to a lxw_worksheet instance to be updated.
 * @param scale     Print scale of worksheet to be printed.
 *
 * This function sets the scale factor of the printed page. The Scale factor
 * must be in the range `10 <= scale <= 400`:
 *
 * @code
 *     worksheet_set_print_scale(worksheet1, 75);
 *     worksheet_set_print_scale(worksheet2, 400);
 * @endcode
 *
 * The default scale factor is 100. Note, `%worksheet_set_print_scale()` does
 * not affect the scale of the visible page in Excel. For that you should use
 * `worksheet_set_zoom()`.
 *
 * Note that although it is valid to use both `worksheet_fit_to_pages()` and
 * `%worksheet_set_print_scale()` on the same worksheet Excel only allows one
 * of these options to be active at a time. The last function call made will
 * set the active option.
 *
 *)
procedure worksheet_set_print_scale(worksheet: Plxw_worksheet; scale: UInt16); cdecl;
  external bj name _PU + 'worksheet_set_print_scale';

(**
 * @brief Set the worksheet to print in black and white
 *
 * @param worksheet Pointer to a lxw_worksheet instance to be updated.
 *
 * Set the option to print the worksheet in black and white:
 * @code
 *     worksheet_print_black_and_white(worksheet);
 * @endcode
 *)
procedure worksheet_print_black_and_white(worksheet: Plxw_worksheet); cdecl;
  external bj name _PU + 'worksheet_print_black_and_white';

(**
 * @brief Display the worksheet cells from right to left for some versions of
 *        Excel.
 *
 * @param worksheet Pointer to a lxw_worksheet instance to be updated.
 *
 * The `%worksheet_right_to_left()` function is used to change the default
 * direction of the worksheet from left-to-right, with the `A1` cell in the
 * top left, to right-to-left, with the `A1` cell in the top right.
 *
 * @code
 *     worksheet_right_to_left(worksheet1);
 * @endcode
 *
 * This is useful when creating Arabic, Hebrew or other near or far eastern
 * worksheets that use right-to-left as the default direction.
 *)
procedure worksheet_right_to_left(worksheet: Plxw_worksheet); cdecl;
  external bj name _PU + 'worksheet_right_to_left';

(**
 * @brief Hide zero values in worksheet cells.
 *
 * @param worksheet Pointer to a lxw_worksheet instance to be updated.
 *
 * The `%worksheet_hide_zero()` function is used to hide any zero values that
 * appear in cells:
 *
 * @code
 *     worksheet_hide_zero(worksheet1);
 * @endcode
 *)
procedure worksheet_hide_zero(worksheet: Plxw_worksheet); cdecl;
  external bj name _PU + 'worksheet_hide_zero';

(**
 * @brief Set the color of the worksheet tab.
 *
 * @param worksheet Pointer to a lxw_worksheet instance to be updated.
 * @param color     The tab color.
 *
 * The `%worksheet_set_tab_color()` function is used to change the color of
 * the worksheet tab:
 *
 * @code
 *      worksheet_set_tab_color(worksheet1, LXW_COLOR_RED);
 *      worksheet_set_tab_color(worksheet2, LXW_COLOR_GREEN);
 *      worksheet_set_tab_color(worksheet3, 0xFF9900); // Orange.
 * @endcode
 *
 * The color should be an RGB integer value, see @ref working_with_colors.
 *)
procedure worksheet_set_tab_color(worksheet: Plxw_worksheet; color: lxw_color_t); cdecl;
  external bj name _PU + 'worksheet_set_tab_color';

(**
 * @brief Protect elements of a worksheet from modification.
 *
 * @param worksheet Pointer to a lxw_worksheet instance to be updated.
 * @param password  A worksheet password.
 * @param options   Worksheet elements to protect.
 *
 * The `%worksheet_protect()` function protects worksheet elements from modification:
 *
 * @code
 *     worksheet_protect(worksheet, "Some Password", options);
 * @endcode
 *
 * The `password` and lxw_protection pointer are both optional:
 *
 * @code
 *     worksheet_protect(worksheet1, NULL,       NULL);
 *     worksheet_protect(worksheet2, NULL,       my_options);
 *     worksheet_protect(worksheet3, "password", NULL);
 *     worksheet_protect(worksheet4, "password", my_options);
 * @endcode
 *
 * Passing a `NULL` password is the same as turning on protection without a
 * password. Passing a `NULL` password and `NULL` options, or any other
 * combination has the effect of enabling a cell's `locked` and `hidden`
 * properties if they have been set.
 *
 * A *locked* cell cannot be edited and this property is on by default for all
 * cells. A *hidden* cell will display the results of a formula but not the
 * formula itself. These properties can be set using the format_set_unlocked()
 * and format_set_hidden() format functions.
 *
 * You can specify which worksheet elements you wish to protect by passing a
 * lxw_protection pointer in the `options` argument with any or all of the
 * following members set:
 *
 *     no_select_locked_cells
 *     no_select_unlocked_cells
 *     format_cells
 *     format_columns
 *     format_rows
 *     insert_columns
 *     insert_rows
 *     insert_hyperlinks
 *     delete_columns
 *     delete_rows
 *     sort
 *     autofilter
 *     pivot_tables
 *     scenarios
 *     objects
 *
 * All parameters are off by default. Individual elements can be protected as
 * follows:
 *
 * @code
 *     lxw_protection options = {
 *         .format_cells             = 1,
 *         .insert_hyperlinks        = 1,
 *         .insert_rows              = 1,
 *         .delete_rows              = 1,
 *         .insert_columns           = 1,
 *         .delete_columns           = 1,
 *     };
 *
 *     worksheet_protect(worksheet, NULL, &options);
 *
 * @endcode
 *
 * See also the format_set_unlocked() and format_set_hidden() format functions.
 *
 * **Note:** Sheet level passwords in Excel offer **very** weak
 * protection. They don't encrypt your data and are very easy to
 * deactivate. Full workbook encryption is not supported by `libxlsxwriter`
 * since it requires a completely different file format.
 *)
procedure worksheet_protect(worksheet: Plxw_worksheet; const password: PUTF8Char; options: Plxw_protection); cdecl;
  external bj name _PU + 'worksheet_protect';

(**
 * @brief Set the Outline and Grouping display properties.
 *
 * @param worksheet      Pointer to a lxw_worksheet instance to be updated.
 * @param visible        Outlines are visible. Optional, defaults to True.
 * @param symbols_below  Show row outline symbols below the outline bar.
 * @param symbols_right  Show column outline symbols to the right of outline.
 * @param auto_style     Use Automatic outline style.
 *
 * The `%worksheet_outline_settings()` method is used to control the
 * appearance of outlines in Excel. Outlines are described the section on
 * @ref working_with_outlines.
 *
 * The `visible` parameter is used to control whether or not outlines are
 * visible. Setting this parameter to False will cause all outlines on the
 * worksheet to be hidden. They can be un-hidden in Excel by means of the
 * "Show Outline Symbols" command button. The default Excel setting is True
 * for visible outlines.
 *
 * The `symbols_below` parameter is used to control whether the row outline
 * symbol will appear above or below the outline level bar. The default Excel
 * setting is True for symbols to appear below the outline level bar.
 *
 * The `symbols_right` parameter is used to control whether the column outline
 * symbol will appear to the left or the right of the outline level bar. The
 * default Excel setting is True for symbols to appear to the right of the
 * outline level bar.
 *
 * The `auto_style` parameter is used to control whether the automatic outline
 * generator in Excel uses automatic styles when creating an outline. This has
 * no effect on a file generated by XlsxWriter but it does have an effect on
 * how the worksheet behaves after it is created. The default Excel setting is
 * False for "Automatic Styles" to be turned off.
 *
 * The default settings for all of these parameters in libxlsxwriter
 * correspond to Excel's default parameters and are shown below:
 *
 * @code
 *     worksheet_outline_settings(worksheet1, LXW_TRUE, LXW_TRUE, LXW_TRUE, LXW_FALSE);
 * @endcode
 *
 * The worksheet parameters controlled by `worksheet_outline_settings()` are
 * rarely used.
 *)
procedure worksheet_outline_settings(worksheet: Plxw_worksheet; visible: UInt8; symbols_below: UInt8; symbols_right: UInt8; auto_style: UInt8); cdecl;
  external bj name _PU + 'worksheet_outline_settings';

(**
 * @brief Set the default row properties.
 *
 * @param worksheet        Pointer to a lxw_worksheet instance to be updated.
 * @param height           Default row height.
 * @param hide_unused_rows Hide unused cells.
 *
 * The `%worksheet_set_default_row()` function is used to set Excel default
 * row properties such as the default height and the option to hide unused
 * rows. These parameters are an optimization used by Excel to set row
 * properties without generating a very large file with an entry for each row.
 *
 * To set the default row height:
 *
 * @code
 *     worksheet_set_default_row(worksheet, 24, LXW_FALSE);
 *
 * @endcode
 *
 * To hide unused rows:
 *
 * @code
 *     worksheet_set_default_row(worksheet, 15, LXW_TRUE);
 * @endcode
 *
 * Note, in the previous case we use the default height #LXW_DEF_ROW_HEIGHT =
 * 15 so the the height remains unchanged.
 *)
procedure worksheet_set_default_row(worksheet: Plxw_worksheet; height: Double; hide_unused_rows: UInt8); cdecl;
  external bj name _PU + 'worksheet_set_default_row';

(**
 * @brief Set the VBA name for the worksheet.
 *
 * @param worksheet Pointer to a lxw_worksheet instance.
 * @param name      Name of the worksheet used by VBA.
 *
 * @return A #lxw_error.
 *
 * The `worksheet_set_vba_name()` function can be used to set the VBA name for
 * the worksheet. This is sometimes required when a vbaProject macro included
 * via `workbook_add_vba_project()` refers to the worksheet by a name other
 * than the worksheet name:
 *
 * @code
 *     workbook_set_vba_name (workbook,  "MyWorkbook");
 *     worksheet_set_vba_name(worksheet, "MySheet1");
 * @endcode
 *
 * In general Excel uses the worksheet name such as "Sheet1" as the VBA name.
 * However, this can be changed in the VBA environment or if the the macro was
 * extracted from a foreign language version of Excel.
 *
 * See also @ref working_with_macros
 *)
function worksheet_set_vba_name(worksheet: Plxw_worksheet; const name: PUTF8Char): lxw_error; cdecl;
  external bj name _PU + 'worksheet_set_vba_name';

(**
 * @brief Make all comments in the worksheet visible.
 *
 * @param worksheet Pointer to a lxw_worksheet instance.
 *
 * This `%worksheet_show_comments()` function is used to make all cell
 * comments visible when a worksheet is opened:
 *
 * @code
 *     worksheet_show_comments(worksheet);
 * @endcode
 *
 * Individual comments can be made visible or hidden using the `visible`
 * option of the #lxw_comment_options struct and the `worksheet_write_comment_opt()`
 * function (see above and @ref ww_comments_visible).
 *)
procedure worksheet_show_comments(worksheet: Plxw_worksheet); cdecl;
  external bj name _PU + 'worksheet_show_comments';

(**
 * @brief Set the default author of the cell comments.
 *
 * @param worksheet Pointer to a lxw_worksheet instance.
 * @param author    The name of the comment author.
 *
 * This `%worksheet_set_comments_author()` function is used to set the
 * default author of all cell comments:
 *
 * @code
 *     worksheet_set_comments_author(worksheet, "Jane Gloriana Villanueva")
 * @endcode
 *
 * Individual authors can be set using the `author` option of the
 * #lxw_comment_options struct and the `worksheet_write_comment_opt()`
 * function (see above and @ref ww_comments_author).
 *)
procedure worksheet_set_comments_author(worksheet: Plxw_worksheet; const author: PUTF8Char); cdecl;
  external bj name _PU + 'worksheet_set_comments_author';

(**
 * @brief Ignore various Excel errors/warnings in a worksheet for user
 *        defined ranges.
 *
 * @param worksheet Pointer to a lxw_worksheet instance.
 * @param type      The type of error/warning to ignore. See #lxw_ignore_errors.
 * @param range     The range(s) for which the error/warning should be ignored.
 *
 * @return A #lxw_error.
 *
 *
 * The `%worksheet_ignore_errors()` function can be used to ignore various
 * worksheet cell errors/warnings. For example the following code writes a string
 * that looks like a number:
 *
 * @code
 *     worksheet_write_string(worksheet, CELL("D2"), "123", NULL);
 * @endcode
 *
 * This causes Excel to display a small green triangle in the top left hand
 * corner of the cell to indicate an error/warning:
 *
 * @image html ignore_errors1.png
 *
 * Sometimes these warnings are useful indicators that there is an issue in
 * the spreadsheet but sometimes it is preferable to turn them off. Warnings
 * can be turned off at the Excel level for all workbooks and worksheets by
 * using the using "Excel options -> Formulas -> Error checking
 * rules". Alternatively you can turn them off for individual cells in a
 * worksheet, or ranges of cells, using the `%worksheet_ignore_errors()`
 * function with different #lxw_ignore_errors options and ranges like this:
 *
 * @code
 *     worksheet_ignore_errors(worksheet, LXW_IGNORE_NUMBER_STORED_AS_TEXT, "C3");
 *     worksheet_ignore_errors(worksheet, LXW_IGNORE_EVAL_ERROR,            "C6");
 * @endcode
 *
 * The range can be a single cell, a range of cells, or multiple cells and ranges
 * separated by spaces:
 *
 * @code
 *     // Single cell.
 *     worksheet_ignore_errors(worksheet, LXW_IGNORE_NUMBER_STORED_AS_TEXT, "C6");
 *
 *     // Or a single range:
 *     worksheet_ignore_errors(worksheet, LXW_IGNORE_NUMBER_STORED_AS_TEXT, "C6:G8");
 *
 *     // Or multiple cells and ranges:
 *     worksheet_ignore_errors(worksheet, LXW_IGNORE_NUMBER_STORED_AS_TEXT, "C6 E6 G1:G20 J2:J6");
 * @endcode
 *
 * @note Calling `%worksheet_ignore_errors()` more than once for the same
 * #lxw_ignore_errors type will overwrite the previous range.
 *
 * You can turn off warnings for an entire column by specifying the range from
 * the first cell in the column to the last cell in the column:
 *
 * @code
 *     worksheet_ignore_errors(worksheet, LXW_IGNORE_NUMBER_STORED_AS_TEXT, "A1:A1048576");
 * @endcode
 *
 * Or for the entire worksheet by specifying the range from the first cell in
 * the worksheet to the last cell in the worksheet:
 *
 * @code
 *     worksheet_ignore_errors(worksheet, LXW_IGNORE_NUMBER_STORED_AS_TEXT, "A1:XFD1048576");
 * @endcode
 *
 * The worksheet errors/warnings that can be ignored are:
 *
 * - #LXW_IGNORE_NUMBER_STORED_AS_TEXT: Turn off errors/warnings for numbers
 *    stores as text.
 *
 * - #LXW_IGNORE_EVAL_ERROR: Turn off errors/warnings for formula errors (such
 *    as divide by zero).
 *
 * - #LXW_IGNORE_FORMULA_DIFFERS: Turn off errors/warnings for formulas that
 *    differ from surrounding formulas.
 *
 * - #LXW_IGNORE_FORMULA_RANGE: Turn off errors/warnings for formulas that
 *    omit cells in a range.
 *
 * - #LXW_IGNORE_FORMULA_UNLOCKED: Turn off errors/warnings for unlocked cells
 *    that contain formulas.
 *
 * - #LXW_IGNORE_EMPTY_CELL_REFERENCE: Turn off errors/warnings for formulas
 *    that refer to empty cells.
 *
 * - #LXW_IGNORE_LIST_DATA_VALIDATION: Turn off errors/warnings for cells in a
 *    table that do not comply with applicable data validation rules.
 *
 * - #LXW_IGNORE_CALCULATED_COLUMN: Turn off errors/warnings for cell formulas
 *    that differ from the column formula.
 *
 * - #LXW_IGNORE_TWO_DIGIT_TEXT_YEAR: Turn off errors/warnings for formulas
 *    that contain a two digit text representation of a year.
 *
 *)
function worksheet_ignore_errors(worksheet: Plxw_worksheet; atype: UInt8; const range: PUTF8Char): lxw_error; cdecl;
  external bj name _PU + 'worksheet_ignore_errors';

function lxw_worksheet_new(init_data: Plxw_worksheet_init_data): Plxw_worksheet; cdecl;
  external bj name _PU + 'lxw_worksheet_new';

procedure lxw_worksheet_free(worksheet: Plxw_worksheet); cdecl;
  external bj name _PU + 'lxw_worksheet_free';

procedure lxw_worksheet_assemble_xml_file(worksheet: Plxw_worksheet); cdecl;
  external bj name _PU + 'lxw_worksheet_assemble_xml_file';

procedure lxw_worksheet_write_single_row(worksheet: Plxw_worksheet); cdecl;
  external bj name _PU + 'lxw_worksheet_write_single_row';

procedure lxw_worksheet_prepare_image(worksheet: Plxw_worksheet; image_ref_id: UInt32; drawing_id: UInt32; object_props: Plxw_object_properties); cdecl;
  external bj name _PU + 'lxw_worksheet_prepare_image';

procedure lxw_worksheet_prepare_header_image(worksheet: Plxw_worksheet; image_ref_id: UInt32; object_props: Plxw_object_properties); cdecl;
  external bj name _PU + 'lxw_worksheet_prepare_header_image';

procedure lxw_worksheet_prepare_background(worksheet: Plxw_worksheet; image_ref_id: UInt32; object_props: Plxw_object_properties); cdecl;
  external bj name _PU + 'lxw_worksheet_prepare_background';

procedure lxw_worksheet_prepare_chart(worksheet: Plxw_worksheet; chart_ref_id: UInt32; drawing_id: UInt32; object_props: Plxw_object_properties; is_chartsheet: UInt8); cdecl;
  external bj name _PU + 'lxw_worksheet_prepare_chart';

function lxw_worksheet_prepare_vml_objects(worksheet: Plxw_worksheet; vml_data_id: UInt32; vml_shape_id: UInt32; vml_drawing_id: UInt32; comment_id: UInt32): UInt32; cdecl;
  external bj name _PU + 'lxw_worksheet_prepare_vml_objects';

procedure lxw_worksheet_prepare_header_vml_objects(worksheet: Plxw_worksheet; vml_header_id: UInt32; vml_drawing_id: UInt32); cdecl;
  external bj name _PU + 'lxw_worksheet_prepare_header_vml_objects';

procedure lxw_worksheet_prepare_tables(worksheet: Plxw_worksheet; table_id: UInt32); cdecl;
  external bj name _PU + 'lxw_worksheet_prepare_tables';

function lxw_worksheet_find_row(worksheet: Plxw_worksheet; row_num: lxw_row_t): Plxw_row; cdecl;
  external bj name _PU + 'lxw_worksheet_find_row';

function lxw_worksheet_find_cell_in_row(row: Plxw_row; col_num: lxw_col_t): Plxw_cell; cdecl;
  external bj name _PU + 'lxw_worksheet_find_cell_in_row';

procedure lxw_worksheet_write_sheet_views(worksheet: Plxw_worksheet); cdecl;
  external bj name _PU + 'lxw_worksheet_write_sheet_views';

procedure lxw_worksheet_write_page_margins(worksheet: Plxw_worksheet); cdecl;
  external bj name _PU + 'lxw_worksheet_write_page_margins';

procedure lxw_worksheet_write_drawings(worksheet: Plxw_worksheet); cdecl;
  external bj name _PU + 'lxw_worksheet_write_drawings';

procedure lxw_worksheet_write_sheet_protection(worksheet: Plxw_worksheet; protect: Plxw_protection_obj); cdecl;
  external bj name _PU + 'lxw_worksheet_write_sheet_protection';

procedure lxw_worksheet_write_sheet_pr(worksheet: Plxw_worksheet); cdecl;
  external bj name _PU + 'lxw_worksheet_write_sheet_pr';

procedure lxw_worksheet_write_page_setup(worksheet: Plxw_worksheet); cdecl;
  external bj name _PU + 'lxw_worksheet_write_page_setup';

procedure lxw_worksheet_write_header_footer(worksheet: Plxw_worksheet); cdecl;
  external bj name _PU + 'lxw_worksheet_write_header_footer';

procedure worksheet_set_error_cell(worksheet: Plxw_worksheet; object_props: Plxw_object_properties; ref_id: UInt32); cdecl;
  external bj name _PU + 'worksheet_set_error_cell';

(**
 * @brief Insert a chart object into a chartsheet.
 *
 * @param chartsheet   Pointer to a lxw_chartsheet instance to be updated.
 * @param chart        A #lxw_chart object created via workbook_add_chart().
 *
 * @return A #lxw_error code.
 *
 * The `%chartsheet_set_chart()` function can be used to insert a chart into a
 * chartsheet. The chart object must be created first using the
 * `workbook_add_chart()` function and configured using the @ref chart.h
 * functions.
 *
 * @code
 *     // Create the chartsheet.
 *     lxw_chartsheet *chartsheet = workbook_add_chartsheet(workbook, NULL);
 *
 *     // Create a chart object.
 *     lxw_chart *chart = workbook_add_chart(workbook, LXW_CHART_LINE);
 *
 *     // Add a data series to the chart.
 *     chart_add_series(chart, NULL, "=Sheet1!$A$1:$A$6");
 *
 *     // Insert the chart into the chartsheet.
 *     chartsheet_set_chart(chartsheet, chart);
 * @endcode
 *
 * @image html chartsheet2.png
 *
 * **Note:**
 *
 * A chart may only be inserted once into a chartsheet or a worksheet. If
 * several similar charts are required then each one must be created
 * separately.
 *
 *)
function chartsheet_set_chart(chartsheet: Plxw_chartsheet; chart: Plxw_chart): lxw_error; cdecl;
  external bj name _PU + 'chartsheet_set_chart';

function chartsheet_set_chart_opt(chartsheet: Plxw_chartsheet; chart: Plxw_chart; user_options: Plxw_chart_options): lxw_error; cdecl;
  external bj name _PU + 'chartsheet_set_chart_opt';

(**
 * @brief Make a chartsheet the active, i.e., visible chartsheet.
 *
 * @param chartsheet Pointer to a lxw_chartsheet instance to be updated.
 *
 * The `%chartsheet_activate()` function is used to specify which chartsheet
 * is initially visible in a multi-sheet workbook:
 *
 * @code
 *     lxw_worksheet  *worksheet1  = workbook_add_worksheet(workbook, NULL);
 *     lxw_chartsheet *chartsheet1 = workbook_add_chartsheet(workbook, NULL);
 *     lxw_chartsheet *chartsheet2 = workbook_add_chartsheet(workbook, NULL);
 *     lxw_chartsheet *chartsheet3 = workbook_add_chartsheet(workbook, NULL);
 *
 *     chartsheet_activate(chartsheet3);
 * @endcode
 *
 * @image html chartsheet_activate.png
 *
 * More than one chartsheet can be selected via the `chartsheet_select()`
 * function, see below, however only one chartsheet can be active.
 *
 * The default active chartsheet is the first chartsheet.
 *
 * See also `worksheet_activate()`.
 *
 *)
procedure chartsheet_activate(chartsheet: Plxw_chartsheet); cdecl;
  external bj name _PU + 'chartsheet_activate';

(**
 * @brief Set a chartsheet tab as selected.
 *
 * @param chartsheet Pointer to a lxw_chartsheet instance to be updated.
 *
 * The `%chartsheet_select()` function is used to indicate that a chartsheet
 * is selected in a multi-sheet workbook:
 *
 * @code
 *     chartsheet_activate(chartsheet1);
 *     chartsheet_select(chartsheet2);
 *     chartsheet_select(chartsheet3);
 *
 * @endcode
 *
 * A selected chartsheet has its tab highlighted. Selecting chartsheets is a
 * way of grouping them together so that, for example, several chartsheets
 * could be printed in one go. A chartsheet that has been activated via the
 * `chartsheet_activate()` function will also appear as selected.
 *
 * See also `worksheet_select()`.
 *
 *)
procedure chartsheet_select(chartsheet: Plxw_chartsheet); cdecl;
  external bj name _PU + 'chartsheet_select';

(**
 * @brief Hide the current chartsheet.
 *
 * @param chartsheet Pointer to a lxw_chartsheet instance to be updated.
 *
 * The `%chartsheet_hide()` function is used to hide a chartsheet:
 *
 * @code
 *     chartsheet_hide(chartsheet2);
 * @endcode
 *
 * You may wish to hide a chartsheet in order to avoid confusing a user with
 * intermediate data or calculations.
 *
 * @image html hide_sheet.png
 *
 * A hidden chartsheet can not be activated or selected so this function is
 * mutually exclusive with the `chartsheet_activate()` and
 * `chartsheet_select()` functions. In addition, since the first chartsheet
 * will default to being the active chartsheet, you cannot hide the first
 * chartsheet without activating another sheet:
 *
 * @code
 *     chartsheet_activate(chartsheet2);
 *     chartsheet_hide(chartsheet1);
 * @endcode
 *
 * See also `worksheet_hide()`.
 *
 *)
procedure chartsheet_hide(chartsheet: Plxw_chartsheet); cdecl;
  external bj name _PU + 'chartsheet_hide';

(**
 * @brief Set current chartsheet as the first visible sheet tab.
 *
 * @param chartsheet Pointer to a lxw_chartsheet instance to be updated.
 *
 * The `chartsheet_activate()` function determines which chartsheet is
 * initially selected.  However, if there are a large number of chartsheets the
 * selected chartsheet may not appear on the screen. To avoid this you can
 * select the leftmost visible chartsheet tab using
 * `%chartsheet_set_first_sheet()`:
 *
 * @code
 *     chartsheet_set_first_sheet(chartsheet19); // First visible chartsheet tab.
 *     chartsheet_activate(chartsheet20);        // First visible chartsheet.
 * @endcode
 *
 * This function is not required very often. The default value is the first
 * chartsheet.
 *
 * See also `worksheet_set_first_sheet()`.
 *
 *)
procedure chartsheet_set_first_sheet(chartsheet: Plxw_chartsheet); cdecl;
  external bj name _PU + 'chartsheet_set_first_sheet';

(**
 * @brief Set the color of the chartsheet tab.
 *
 * @param chartsheet Pointer to a lxw_chartsheet instance to be updated.
 * @param color      The tab color.
 *
 * The `%chartsheet_set_tab_color()` function is used to change the color of
 * the chartsheet tab:
 *
 * @code
 *      chartsheet_set_tab_color(chartsheet1, LXW_COLOR_RED);
 *      chartsheet_set_tab_color(chartsheet2, LXW_COLOR_GREEN);
 *      chartsheet_set_tab_color(chartsheet3, 0xFF9900); // Orange.
 * @endcode
 *
 * The color should be an RGB integer value, see @ref working_with_colors.
 *
 * See also `worksheet_set_tab_color()`.
 *)
procedure chartsheet_set_tab_color(chartsheet: Plxw_chartsheet; color: lxw_color_t); cdecl;
  external bj name _PU + 'chartsheet_set_tab_color';

(**
 * @brief Protect elements of a chartsheet from modification.
 *
 * @param chartsheet Pointer to a lxw_chartsheet instance to be updated.
 * @param password   A chartsheet password.
 * @param options    Chartsheet elements to protect.
 *
 * The `%chartsheet_protect()` function protects chartsheet elements from
 * modification:
 *
 * @code
 *     chartsheet_protect(chartsheet, "Some Password", options);
 * @endcode
 *
 * The `password` and lxw_protection pointer are both optional:
 *
 * @code
 *     chartsheet_protect(chartsheet2, NULL,       my_options);
 *     chartsheet_protect(chartsheet3, "password", NULL);
 *     chartsheet_protect(chartsheet4, "password", my_options);
 * @endcode
 *
 * Passing a `NULL` password is the same as turning on protection without a
 * password. Passing a `NULL` password and `NULL` options had no effect on
 * chartsheets.
 *
 * You can specify which chartsheet elements you wish to protect by passing a
 * lxw_protection pointer in the `options` argument. In Excel chartsheets only
 * have two protection options:
 *
 *     no_content
 *     no_objects
 *
 * All parameters are off by default. Individual elements can be protected as
 * follows:
 *
 * @code
 *     lxw_protection options = {
 *         .no_content  = 1,
 *         .no_objects  = 1,
 *     };
 *
 *     chartsheet_protect(chartsheet, NULL, &options);
 *
 * @endcode
 *
 * See also worksheet_protect().
 *
 * **Note:** Sheet level passwords in Excel offer **very** weak
 * protection. They don't encrypt your data and are very easy to
 * deactivate. Full workbook encryption is not supported by `libxlsxwriter`
 * since it requires a completely different file format.
 *)
procedure chartsheet_protect(chartsheet: Plxw_chartsheet; const password: PUTF8Char; options: Plxw_protection); cdecl;
  external bj name _PU + 'chartsheet_protect';

(**
 * @brief Set the chartsheet zoom factor.
 *
 * @param chartsheet Pointer to a lxw_chartsheet instance to be updated.
 * @param scale      Chartsheet zoom factor.
 *
 * Set the chartsheet zoom factor in the range `10 <= zoom <= 400`:
 *
 * @code
 *     chartsheet_set_zoom(chartsheet, 75);
 * @endcode
 *
 * The default zoom factor is 100. It isn't possible to set the zoom to
 * "Selection" because it is calculated by Excel at run-time.
 *
 * See also `worksheet_set_zoom()`.
 *)
procedure chartsheet_set_zoom(chartsheet: Plxw_chartsheet; scale: UInt16); cdecl;
  external bj name _PU + 'chartsheet_set_zoom';

(**
 * @brief Set the page orientation as landscape.
 *
 * @param chartsheet Pointer to a lxw_chartsheet instance to be updated.
 *
 * This function is used to set the orientation of a chartsheet's printed page
 * to landscape. The default chartsheet orientation is landscape, so this
 * function isn't generally required:
 *
 * @code
 *     chartsheet_set_landscape(chartsheet);
 * @endcode
 *)
procedure chartsheet_set_landscape(chartsheet: Plxw_chartsheet); cdecl;
  external bj name _PU + 'chartsheet_set_landscape';

(**
 * @brief Set the page orientation as portrait.
 *
 * @param chartsheet Pointer to a lxw_chartsheet instance to be updated.
 *
 * This function is used to set the orientation of a chartsheet's printed page
 * to portrait:
 *
 * @code
 *     chartsheet_set_portrait(chartsheet);
 * @endcode
 *)
procedure chartsheet_set_portrait(chartsheet: Plxw_chartsheet); cdecl;
  external bj name _PU + 'chartsheet_set_portrait';

(**
 * @brief Set the paper type for printing.
 *
 * @param chartsheet Pointer to a lxw_chartsheet instance to be updated.
 * @param paper_type The Excel paper format type.
 *
 * This function is used to set the paper format for the printed output of a
 * chartsheet:
 *
 * @code
 *     chartsheet_set_paper(chartsheet1, 1);  // US Letter
 *     chartsheet_set_paper(chartsheet2, 9);  // A4
 * @endcode
 *
 * If you do not specify a paper type the chartsheet will print using the
 * printer's default paper style.
 *
 * See `worksheet_set_paper()` for a full list of available paper sizes.
 *)
procedure chartsheet_set_paper(chartsheet: Plxw_chartsheet; paper_type: UInt8); cdecl;
  external bj name _PU + 'chartsheet_set_paper';

(**
 * @brief Set the chartsheet margins for the printed page.
 *
 * @param chartsheet Pointer to a lxw_chartsheet instance to be updated.
 * @param left       Left margin in inches.   Excel default is 0.7.
 * @param right      Right margin in inches.  Excel default is 0.7.
 * @param top        Top margin in inches.    Excel default is 0.75.
 * @param bottom     Bottom margin in inches. Excel default is 0.75.
 *
 * The `%chartsheet_set_margins()` function is used to set the margins of the
 * chartsheet when it is printed. The units are in inches. Specifying `-1` for
 * any parameter will give the default Excel value as shown above.
 *
 * @code
 *    chartsheet_set_margins(chartsheet, 1.3, 1.2, -1, -1);
 * @endcode
 *
 *)
procedure chartsheet_set_margins(chartsheet: Plxw_chartsheet; left: Double; right: Double; top: Double; bottom: Double); cdecl;
  external bj name _PU + 'chartsheet_set_margins';

(**
 * @brief Set the printed page header caption.
 *
 * @param chartsheet Pointer to a lxw_chartsheet instance to be updated.
 * @param string     The header string.
 *
 * @return A #lxw_error code.
 *
 * Headers and footers are generated using a string which is a combination of
 * plain text and control characters
 *
 * @code
 *     chartsheet_set_header(chartsheet, "&LHello");
 *
 *     //     ---------------------------------------------------------------
 *     //    |                                                               |
 *     //    | Hello                                                         |
 *     //    |                                                               |
 *
 *
 *     chartsheet_set_header(chartsheet, "&CHello");
 *
 *     //     ---------------------------------------------------------------
 *     //    |                                                               |
 *     //    |                          Hello                                |
 *     //    |                                                               |
 *
 *
 *     chartsheet_set_header(chartsheet, "&RHello");
 *
 *     //     ---------------------------------------------------------------
 *     //    |                                                               |
 *     //    |                                                         Hello |
 *     //    |                                                               |
 *
 *
 * @endcode
 *
 * See `worksheet_set_header()` for a full explanation of the syntax of
 * Excel's header formatting and control characters.
 *
 *)
function chartsheet_set_header(chartsheet: Plxw_chartsheet; const astring: PUTF8Char): lxw_error; cdecl;
  external bj name _PU + 'chartsheet_set_header';

(**
 * @brief Set the printed page footer caption.
 *
 * @param chartsheet Pointer to a lxw_chartsheet instance to be updated.
 * @param string     The footer string.
 *
 * @return A #lxw_error code.
 *
 * The syntax of this function is the same as chartsheet_set_header().
 *
 *)
function chartsheet_set_footer(chartsheet: Plxw_chartsheet; const astring: PUTF8Char): lxw_error; cdecl;
  external bj name _PU + 'chartsheet_set_footer';

(**
 * @brief Set the printed page header caption with additional options.
 *
 * @param chartsheet Pointer to a lxw_chartsheet instance to be updated.
 * @param string     The header string.
 * @param options    Header options.
 *
 * @return A #lxw_error code.
 *
 * The syntax of this function is the same as chartsheet_set_header() with an
 * additional parameter to specify options for the header.
 *
 * Currently, the only available option is the header margin:
 *
 * @code
 *
 *    lxw_header_footer_options header_options = { 0.2 };
 *
 *    chartsheet_set_header_opt(chartsheet, "Some text", &header_options);
 *
 * @endcode
 *
 *)
function chartsheet_set_header_opt(chartsheet: Plxw_chartsheet; const astring: PUTF8Char; options: Plxw_header_footer_options): lxw_error; cdecl;
  external bj name _PU + 'chartsheet_set_header_opt';

(**
 * @brief Set the printed page footer caption with additional options.
 *
 * @param chartsheet Pointer to a lxw_chartsheet instance to be updated.
 * @param string     The footer string.
 * @param options    Footer options.
 *
 * @return A #lxw_error code.
 *
 * The syntax of this function is the same as chartsheet_set_header_opt().
 *
 *)
function chartsheet_set_footer_opt(chartsheet: Plxw_chartsheet; const astring: PUTF8Char; options: Plxw_header_footer_options): lxw_error; cdecl;
  external bj name _PU + 'chartsheet_set_footer_opt';

function lxw_chartsheet_new(init_data: Plxw_worksheet_init_data): Plxw_chartsheet; cdecl;
  external bj name _PU + 'lxw_chartsheet_new';

procedure lxw_chartsheet_free(chartsheet: Plxw_chartsheet); cdecl;
  external bj name _PU + 'lxw_chartsheet_free';

procedure lxw_chartsheet_assemble_xml_file(chartsheet: Plxw_chartsheet); cdecl;
  external bj name _PU + 'lxw_chartsheet_assemble_xml_file';

(**
 * @brief Create a new workbook object.
 *
 * @param filename The name of the new Excel file to create.
 *
 * @return A lxw_workbook instance.
 *
 * The `%workbook_new()` constructor is used to create a new Excel workbook
 * with a given filename:
 *
 * @code
 *     lxw_workbook *workbook  = workbook_new("filename.xlsx");
 * @endcode
 *
 * When specifying a filename it is recommended that you use an `.xlsx`
 * extension or Excel will generate a warning when opening the file.
 *
 *)
function workbook_new(const filename: PUTF8Char): Plxw_workbook; cdecl;
  external bj name _PU + 'workbook_new';

(**
 * @brief Create a new workbook object, and set the workbook options.
 *
 * @param filename The name of the new Excel file to create.
 * @param options  Workbook options.
 *
 * @return A lxw_workbook instance.
 *
 * This function is the same as the `workbook_new()` constructor but allows
 * additional options to be set.
 *
 * @code
 *    lxw_workbook_options options = {.constant_memory = LXW_TRUE,
 *                                    .tmpdir = "C:\\Temp",
 *                                    .use_zip64 = LXW_FALSE,
 *                                    .output_buffer = NULL,
 *                                    .output_buffer_size = NULL};
 *
 *    lxw_workbook  *workbook  = workbook_new_opt("filename.xlsx", &options);
 * @endcode
 *
 * The options that can be set via #lxw_workbook_options are:
 *
 * - `constant_memory`: This option reduces the amount of data stored in
 *   memory so that large files can be written efficiently. This option is off
 *   by default. See the note below for limitations when this mode is on.
 *
 * - `tmpdir`: libxlsxwriter stores workbook data in temporary files prior to
 *   assembling the final XLSX file. The temporary files are created in the
 *   system's temp directory. If the default temporary directory isn't
 *   accessible to your application, or doesn't contain enough space, you can
 *   specify an alternative location using the `tmpdir` option.
 *
 * - `use_zip64`: Make the zip library use ZIP64 extensions when writing very
 *   large xlsx files to allow the zip container, or individual XML files
 *   within it, to be greater than 4 GB. See [ZIP64 on Wikipedia][zip64_wiki]
 *   for more information. This option is off by default.
 *
 *   [zip64_wiki]: https://en.wikipedia.org/wiki/Zip_(file_format)#ZIP64
 *
 * - `output_buffer`: Output to a memory buffer instead of a file. The buffer
 *   must be freed manually by calling `free()`. This option can only be used if
 *   filename is NULL.
 *
 * - `output_buffer_size`: Used with output_buffer to get the size of the
 *   created buffer. This option can only be used if filename is `NULL`.
 *
 * @note In `constant_memory` mode each row of in-memory data is written to
 * disk and then freed when a new row is started via one of the
 * `worksheet_write_*()` functions. Therefore, once this option is active data
 * should be written in sequential row by row order. For this reason
 * `worksheet_merge_range()` and some other row based functionality doesn't
 * work in this mode. See @ref ww_mem_constant for more details.
 *
 * @note Also, in `constant_memory` mode the library uses temp file storage
 * for worksheet data. This can lead to an issue on OSes that map the `/tmp`
 * directory into memory since it is possible to consume the "system" memory
 * even though the "process" memory remains constant. In these cases you
 * should use an alternative temp file location by using the `tmpdir` option
 * shown above. See @ref ww_mem_temp for more details.
 *)
function workbook_new_opt(const filename: PUTF8Char; options: Plxw_workbook_options): Plxw_workbook; cdecl;
  external bj name _PU + 'workbook_new_opt';

(**
 * @brief Add a new worksheet to a workbook.
 *
 * @param workbook  Pointer to a lxw_workbook instance.
 * @param sheetname Optional worksheet name, defaults to Sheet1, etc.
 *
 * @return A lxw_worksheet object.
 *
 * The `%workbook_add_worksheet()` function adds a new worksheet to a workbook.
 *
 * At least one worksheet should be added to a new workbook: The @ref
 * worksheet.h "Worksheet" object is used to write data and configure a
 * worksheet in the workbook.
 *
 * The `sheetname` parameter is optional. If it is `NULL` the default
 * Excel convention will be followed, i.e. Sheet1, Sheet2, etc.:
 *
 * @code
 *     worksheet = workbook_add_worksheet(workbook, NULL  );     // Sheet1
 *     worksheet = workbook_add_worksheet(workbook, "Foglio2");  // Foglio2
 *     worksheet = workbook_add_worksheet(workbook, "Data");     // Data
 *     worksheet = workbook_add_worksheet(workbook, NULL  );     // Sheet4
 *
 * @endcode
 *
 * @image html workbook02.png
 *
 * The worksheet name must be a valid Excel worksheet name, i.e:
 *
 * - The name cannot be blank.
 * - The name is less than or equal to 31 UTF-8 characters.
 * - The name doesn't contain any of the characters: ` [ ] : * ? / \ `
 * - The name doesn't start or end with an apostrophe.
 * - The name isn't already in use. (Case insensitive).
 *
 * If any of these errors are encountered the function will return NULL.
 * You can check for valid name using the `workbook_validate_sheet_name()`
 * function.
 *
 * @note You should also avoid using the worksheet name "History" (case
 * insensitive) which is reserved in English language versions of
 * Excel. Non-English versions may have restrictions on the equivalent word.
 *)
function workbook_add_worksheet(workbook: Plxw_workbook; const sheetname: PUTF8Char): Plxw_worksheet; cdecl;
  external bj name _PU + 'workbook_add_worksheet';

(**
 * @brief Add a new chartsheet to a workbook.
 *
 * @param workbook  Pointer to a lxw_workbook instance.
 * @param sheetname Optional chartsheet name, defaults to Chart1, etc.
 *
 * @return A lxw_chartsheet object.
 *
 * The `%workbook_add_chartsheet()` function adds a new chartsheet to a
 * workbook. The @ref chartsheet.h "Chartsheet" object is like a worksheet
 * except it displays a chart instead of cell data.
 *
 * @image html chartsheet.png
 *
 * The `sheetname` parameter is optional. If it is `NULL` the default
 * Excel convention will be followed, i.e. Chart1, Chart2, etc.:
 *
 * @code
 *     chartsheet = workbook_add_chartsheet(workbook, NULL  );     // Chart1
 *     chartsheet = workbook_add_chartsheet(workbook, "My Chart"); // My Chart
 *     chartsheet = workbook_add_chartsheet(workbook, NULL  );     // Chart3
 *
 * @endcode
 *
 * The chartsheet name must be a valid Excel worksheet name, i.e.:
 *
 * - The name cannot be blank.
 * - The name is less than or equal to 31 UTF-8 characters.
 * - The name doesn't contain any of the characters: ` [ ] : * ? / \ `
 * - The name doesn't start or end with an apostrophe.
 * - The name isn't already in use. (Case insensitive).
 *
 * If any of these errors are encountered the function will return NULL.
 * You can check for valid name using the `workbook_validate_sheet_name()`
 * function.
 *
 * @note You should also avoid using the worksheet name "History" (case
 * insensitive) which is reserved in English language versions of
 * Excel. Non-English versions may have restrictions on the equivalent word.
 *
 * At least one worksheet should be added to a new workbook when creating a
 * chartsheet in order to provide data for the chart. The @ref worksheet.h
 * "Worksheet" object is used to write data and configure a worksheet in the
 * workbook.
 *)
function workbook_add_chartsheet(workbook: Plxw_workbook; const sheetname: PUTF8Char): Plxw_chartsheet; cdecl;
  external bj name _PU + 'workbook_add_chartsheet';

(**
 * @brief Create a new @ref format.h "Format" object to formats cells in
 *        worksheets.
 *
 * @param workbook Pointer to a lxw_workbook instance.
 *
 * @return A lxw_format instance.
 *
 * The `workbook_add_format()` function can be used to create new @ref
 * format.h "Format" objects which are used to apply formatting to a cell.
 *
 * @code
 *    // Create the Format.
 *    lxw_format *format = workbook_add_format(workbook);
 *
 *    // Set some of the format properties.
 *    format_set_bold(format);
 *    format_set_font_color(format, LXW_COLOR_RED);
 *
 *    // Use the format to change the text format in a cell.
 *    worksheet_write_string(worksheet, 0, 0, "Hello", format);
 * @endcode
 *
 * See @ref format.h "the Format object" and @ref working_with_formats
 * sections for more details about Format properties and how to set them.
 *
 *)
function workbook_add_format(workbook: Plxw_workbook): Plxw_format; cdecl;
  external bj name _PU + 'workbook_add_format';

(**
 * @brief Create a new chart to be added to a worksheet:
 *
 * @param workbook   Pointer to a lxw_workbook instance.
 * @param chart_type The type of chart to be created. See #lxw_chart_type.
 *
 * @return A lxw_chart object.
 *
 * The `%workbook_add_chart()` function creates a new chart object that can
 * be added to a worksheet:
 *
 * @code
 *     // Create a chart object.
 *     lxw_chart *chart = workbook_add_chart(workbook, LXW_CHART_COLUMN);
 *
 *     // Add data series to the chart.
 *     chart_add_series(chart, NULL, "Sheet1!$A$1:$A$5");
 *     chart_add_series(chart, NULL, "Sheet1!$B$1:$B$5");
 *     chart_add_series(chart, NULL, "Sheet1!$C$1:$C$5");
 *
 *     // Insert the chart into the worksheet
 *     worksheet_insert_chart(worksheet, CELL("B7"), chart);
 * @endcode
 *
 * The available chart types are defined in #lxw_chart_type. The types of
 * charts that are supported are:
 *
 * | Chart type                               | Description                            |
 * | :--------------------------------------- | :------------------------------------  |
 * | #LXW_CHART_AREA                          | Area chart.                            |
 * | #LXW_CHART_AREA_STACKED                  | Area chart - stacked.                  |
 * | #LXW_CHART_AREA_STACKED_PERCENT          | Area chart - percentage stacked.       |
 * | #LXW_CHART_BAR                           | Bar chart.                             |
 * | #LXW_CHART_BAR_STACKED                   | Bar chart - stacked.                   |
 * | #LXW_CHART_BAR_STACKED_PERCENT           | Bar chart - percentage stacked.        |
 * | #LXW_CHART_COLUMN                        | Column chart.                          |
 * | #LXW_CHART_COLUMN_STACKED                | Column chart - stacked.                |
 * | #LXW_CHART_COLUMN_STACKED_PERCENT        | Column chart - percentage stacked.     |
 * | #LXW_CHART_DOUGHNUT                      | Doughnut chart.                        |
 * | #LXW_CHART_LINE                          | Line chart.                            |
 * | #LXW_CHART_LINE_STACKED                  | Line chart - stacked.                  |
 * | #LXW_CHART_LINE_STACKED_PERCENT          | Line chart - percentage stacked.       |
 * | #LXW_CHART_PIE                           | Pie chart.                             |
 * | #LXW_CHART_SCATTER                       | Scatter chart.                         |
 * | #LXW_CHART_SCATTER_STRAIGHT              | Scatter chart - straight.              |
 * | #LXW_CHART_SCATTER_STRAIGHT_WITH_MARKERS | Scatter chart - straight with markers. |
 * | #LXW_CHART_SCATTER_SMOOTH                | Scatter chart - smooth.                |
 * | #LXW_CHART_SCATTER_SMOOTH_WITH_MARKERS   | Scatter chart - smooth with markers.   |
 * | #LXW_CHART_RADAR                         | Radar chart.                           |
 * | #LXW_CHART_RADAR_WITH_MARKERS            | Radar chart - with markers.            |
 * | #LXW_CHART_RADAR_FILLED                  | Radar chart - filled.                  |
 *
 *
 *
 * See @ref chart.h for details.
 *)
function workbook_add_chart(workbook: Plxw_workbook; chart_type: UInt8): Plxw_chart; cdecl;
  external bj name _PU + 'workbook_add_chart';

(**
 * @brief Close the Workbook object and write the XLSX file.
 *
 * @param workbook Pointer to a lxw_workbook instance.
 *
 * @return A #lxw_error.
 *
 * The `%workbook_close()` function closes a Workbook object, writes the Excel
 * file to disk, frees any memory allocated internally to the Workbook and
 * frees the object itself.
 *
 * @code
 *     workbook_close(workbook);
 * @endcode
 *
 * The `%workbook_close()` function returns any #lxw_error error codes
 * encountered when creating the Excel file. The error code can be returned
 * from the program main or the calling function:
 *
 * @code
 *     return workbook_close(workbook);
 * @endcode
 *
 *)
function workbook_close(workbook: Plxw_workbook): lxw_error; cdecl;
  external bj name _PU + 'workbook_close';

(**
 * @brief Set the document properties such as Title, Author etc.
 *
 * @param workbook   Pointer to a lxw_workbook instance.
 * @param properties Document properties to set.
 *
 * @return A #lxw_error.
 *
 * The `%workbook_set_properties` function can be used to set the document
 * properties of the Excel file created by `libxlsxwriter`. These properties
 * are visible when you use the `Office Button -> Prepare -> Properties`
 * option in Excel and are also available to external applications that read
 * or index windows files.
 *
 * The properties that can be set are:
 *
 * - `title`
 * - `subject`
 * - `author`
 * - `manager`
 * - `company`
 * - `category`
 * - `keywords`
 * - `comments`
 * - `hyperlink_base`
 * - `created`
 *
 * The properties are specified via a `lxw_doc_properties` struct. All the
 * fields are all optional. An example of how to create and pass the
 * properties is:
 *
 * @code
 *     // Create a properties structure and set some of the fields.
 *     lxw_doc_properties properties = {
 *         .title    = "This is an example spreadsheet",
 *         .subject  = "With document properties",
 *         .author   = "John McNamara",
 *         .manager  = "Dr. Heinz Doofenshmirtz",
 *         .company  = "of Wolves",
 *         .category = "Example spreadsheets",
 *         .keywords = "Sample, Example, Properties",
 *         .comments = "Created with libxlsxwriter",
 *         .status   = "Quo",
 *     };
 *
 *     // Set the properties in the workbook.
 *     workbook_set_properties(workbook, &properties);
 * @endcode
 *
 * @image html doc_properties.png
 *
 * The `created` parameter sets the file creation date/time shown in
 * Excel. This defaults to the current time and date if set to 0. If you wish
 * to create files that are binary equivalent (for the same input data) then
 * you should set this creation date/time to a known value using a `time_t`
 * value.
 *
 *)
function workbook_set_properties(workbook: Plxw_workbook; properties: Plxw_doc_properties): lxw_error; cdecl;
  external bj name _PU + 'workbook_set_properties';

(**
 * @brief Set a custom document text property.
 *
 * @param workbook Pointer to a lxw_workbook instance.
 * @param name     The name of the custom property.
 * @param value    The value of the custom property.
 *
 * @return A #lxw_error.
 *
 * The `%workbook_set_custom_property_string()` function can be used to set one
 * or more custom document text properties not covered by the standard
 * properties in the `workbook_set_properties()` function above.
 *
 *  For example:
 *
 * @code
 *     workbook_set_custom_property_string(workbook, "Checked by", "Eve");
 * @endcode
 *
 * @image html custom_properties.png
 *
 * There are 4 `workbook_set_custom_property_string_*()` functions for each
 * of the custom property types supported by Excel:
 *
 * - text/string: `workbook_set_custom_property_string()`
 * - number:      `workbook_set_custom_property_number()`
 * - datetime:    `workbook_set_custom_property_datetime()`
 * - boolean:     `workbook_set_custom_property_boolean()`
 *
 * **Note**: the name and value parameters are limited to 255 characters
 * by Excel.
 *
 *)
function workbook_set_custom_property_string(workbook: Plxw_workbook; const name: PUTF8Char; const value: PUTF8Char): lxw_error; cdecl;
  external bj name _PU + 'workbook_set_custom_property_string';

(**
 * @brief Set a custom document number property.
 *
 * @param workbook Pointer to a lxw_workbook instance.
 * @param name     The name of the custom property.
 * @param value    The value of the custom property.
 *
 * @return A #lxw_error.
 *
 * Set a custom document number property.
 * See `workbook_set_custom_property_string()` above for details.
 *
 * @code
 *     workbook_set_custom_property_number(workbook, "Document number", 12345);
 * @endcode
 *)
function workbook_set_custom_property_number(workbook: Plxw_workbook; const name: PUTF8Char; value: Double): lxw_error; cdecl;
  external bj name _PU + 'workbook_set_custom_property_number';

function workbook_set_custom_property_integer(workbook: Plxw_workbook; const name: PUTF8Char; value: Int32): lxw_error; cdecl;
  external bj name _PU + 'workbook_set_custom_property_integer';

(**
 * @brief Set a custom document boolean property.
 *
 * @param workbook Pointer to a lxw_workbook instance.
 * @param name     The name of the custom property.
 * @param value    The value of the custom property.
 *
 * @return A #lxw_error.
 *
 * Set a custom document boolean property.
 * See `workbook_set_custom_property_string()` above for details.
 *
 * @code
 *     workbook_set_custom_property_boolean(workbook, "Has Review", 1);
 * @endcode
 *)
function workbook_set_custom_property_boolean(workbook: Plxw_workbook; const name: PUTF8Char; value: UInt8): lxw_error; cdecl;
  external bj name _PU + 'workbook_set_custom_property_boolean';

(**
 * @brief Set a custom document date or time property.
 *
 * @param workbook Pointer to a lxw_workbook instance.
 * @param name     The name of the custom property.
 * @param datetime The value of the custom property.
 *
 * @return A #lxw_error.
 *
 * Set a custom date or time number property.
 * See `workbook_set_custom_property_string()` above for details.
 *
 * @code
 *     lxw_datetime datetime  = {2016, 12, 1,  11, 55, 0.0};
 *
 *     workbook_set_custom_property_datetime(workbook, "Date completed", &datetime);
 * @endcode
 *)
function workbook_set_custom_property_datetime(workbook: Plxw_workbook; const name: PUTF8Char; datetime: Plxw_datetime): lxw_error; cdecl;
  external bj name _PU + 'workbook_set_custom_property_datetime';

(**
 * @brief Create a defined name in the workbook to use as a variable.
 *
 * @param workbook Pointer to a lxw_workbook instance.
 * @param name     The defined name.
 * @param formula  The cell or range that the defined name refers to.
 *
 * @return A #lxw_error.
 *
 * This function is used to defined a name that can be used to represent a
 * value, a single cell or a range of cells in a workbook: These defined names
 * can then be used in formulas:
 *
 * @code
 *     workbook_define_name(workbook, "Exchange_rate", "=0.96");
 *     worksheet_write_formula(worksheet, 2, 1, "=Exchange_rate", NULL);
 *
 * @endcode
 *
 * @image html defined_name.png
 *
 * As in Excel a name defined like this is "global" to the workbook and can be
 * referred to from any worksheet:
 *
 * @code
 *     // Global workbook name.
 *     workbook_define_name(workbook, "Sales", "=Sheet1!$G$1:$H$10");
 * @endcode
 *
 * It is also possible to define a local/worksheet name by prefixing it with
 * the sheet name using the syntax `'sheetname!definedname'`:
 *
 * @code
 *     // Local worksheet name.
 *     workbook_define_name(workbook, "Sheet2!Sales", "=Sheet2!$G$1:$G$10");
 * @endcode
 *
 * If the sheet name contains spaces or special characters you must follow the
 * Excel convention and enclose it in single quotes:
 *
 * @code
 *     workbook_define_name(workbook, "'New Data'!Sales", "=Sheet2!$G$1:$G$10");
 * @endcode
 *
 * The rules for names in Excel are explained in the
 * [Microsoft Office documentation](http://office.microsoft.com/en-001/excel-help/define-and-use-names-in-formulas-HA010147120.aspx).
 *
 *)
function workbook_define_name(workbook: Plxw_workbook; const name: PUTF8Char; const formula: PUTF8Char): lxw_error; cdecl;
  external bj name _PU + 'workbook_define_name';

(**
 * @brief Get the default URL format used with `worksheet_write_url()`.
 *
 * @param  workbook Pointer to a lxw_workbook instance.
 * @return A lxw_format instance that has hyperlink properties set.
 *
 * This function returns a lxw_format instance that is used for the default
 * blue underline hyperlink in the `worksheet_write_url()` function when a
 * format isn't specified:
 *
 * @code
 *     lxw_format *url_format = workbook_get_default_url_format(workbook);
 * @endcode
 *
 * The format is the hyperlink style defined by Excel for the default theme.
 * This format is only ever required when overwriting a string URL with
 * data of a different type. See the example below.
 *)
function workbook_get_default_url_format(workbook: Plxw_workbook): Plxw_format; cdecl;
  external bj name _PU + 'workbook_get_default_url_format';

(**
 * @brief Get a worksheet object from its name.
 *
 * @param workbook Pointer to a lxw_workbook instance.
 * @param name     Worksheet name.
 *
 * @return A lxw_worksheet object.
 *
 * This function returns a lxw_worksheet object reference based on its name:
 *
 * @code
 *     worksheet = workbook_get_worksheet_by_name(workbook, "Sheet1");
 * @endcode
 *
 *)
function workbook_get_worksheet_by_name(workbook: Plxw_workbook; const name: PUTF8Char): Plxw_worksheet; cdecl;
  external bj name _PU + 'workbook_get_worksheet_by_name';

(**
 * @brief Get a chartsheet object from its name.
 *
 * @param workbook Pointer to a lxw_workbook instance.
 * @param name     chartsheet name.
 *
 * @return A lxw_chartsheet object.
 *
 * This function returns a lxw_chartsheet object reference based on its name:
 *
 * @code
 *     chartsheet = workbook_get_chartsheet_by_name(workbook, "Chart1");
 * @endcode
 *
 *)
function workbook_get_chartsheet_by_name(workbook: Plxw_workbook; const name: PUTF8Char): Plxw_chartsheet; cdecl;
  external bj name _PU + 'workbook_get_chartsheet_by_name';

(**
 * @brief Validate a worksheet or chartsheet name.
 *
 * @param workbook  Pointer to a lxw_workbook instance.
 * @param sheetname Sheet name to validate.
 *
 * @return A #lxw_error.
 *
 * This function is used to validate a worksheet or chartsheet name according
 * to the rules used by Excel:
 *
 * - The name cannot be blank.
 * - The name is less than or equal to 31 UTF-8 characters.
 * - The name doesn't contain any of the characters: ` [ ] : * ? / \ `
 * - The name doesn't start or end with an apostrophe.
 * - The name isn't already in use. (Case insensitive, see the note below).
 *
 * @code
 *     lxw_error err = workbook_validate_sheet_name(workbook, "Foglio");
 * @endcode
 *
 * This function is called by `workbook_add_worksheet()` and
 * `workbook_add_chartsheet()` but it can be explicitly called by the user
 * beforehand to ensure that the sheet name is valid.
 *
 * @note You should also avoid using the worksheet name "History" (case
 * insensitive) which is reserved in English language versions of
 * Excel. Non-English versions may have restrictions on the equivalent word.
 *
 * @note This function does an ASCII lowercase string comparison to determine
 * if the sheet name is already in use. It doesn't take UTF-8 characters into
 * account. Thus it would flag "Caf" and "caf" as a duplicate (just like
 * Excel) but it wouldn't catch "CAF". If you need a full UTF-8 case
 * insensitive check you should use a third party library to implement it.
 *
 *)
function workbook_validate_sheet_name(workbook: Plxw_workbook; const sheetname: PUTF8Char): lxw_error; cdecl;
  external bj name _PU + 'workbook_validate_sheet_name';

(**
 * @brief Add a vbaProject binary to the Excel workbook.
 *
 * @param workbook Pointer to a lxw_workbook instance.
 * @param filename The path/filename of the vbaProject.bin file.
 *
 * The `%workbook_add_vba_project()` function can be used to add macros or
 * functions to a workbook using a binary VBA project file that has been
 * extracted from an existing Excel xlsm file:
 *
 * @code
 *     workbook_add_vba_project(workbook, "vbaProject.bin");
 * @endcode
 *
 * Only one `vbaProject.bin` file can be added per workbook. The name doesn't
 * have to be `vbaProject.bin`. Any suitable path/name for an existing VBA bin
 * file will do.
 *
 * Once you add a VBA project had been add to an libxlsxwriter workbook you
 * should ensure that the file extension is `.xlsm` to prevent Excel from
 * giving a warning when it opens the file:
 *
 * @code
 *     lxw_workbook *workbook = new_workbook("macro.xlsm");
 * @endcode
 *
 * See also @ref working_with_macros
 *
 * @return A #lxw_error.
 *)
function workbook_add_vba_project(workbook: Plxw_workbook; const filename: PUTF8Char): lxw_error; cdecl;
  external bj name _PU + 'workbook_add_vba_project';

(**
 * @brief Add a vbaProject binary and a vbaProjectSignature binary to the Excel
 * workbook.
 *
 * @param workbook    Pointer to a lxw_workbook instance.
 * @param vba_project The path/filename of the vbaProject.bin file.
 * @param signature   The path/filename of the vbaProjectSignature.bin file.
 *
 * The `%workbook_add_signed_vba_project()` function can be used to add digitally
 * signed macros or functions to a workbook. The function adds a binary VBA project
 * file and a binary VBA project signature file that have been extracted from an
 * existing Excel xlsm file with digitally signed macros:
 *
 * @code
 *     workbook_add_signed_vba_project(workbook, "vbaProject.bin", "vbaProjectSignature.bin");
 * @endcode
 *
 * Only one `vbaProject.bin` file can be added per workbook. The name doesn't
 * have to be `vbaProject.bin`. Any suitable path/name for an existing VBA bin
 * file will do. The same applies for `vbaProjectSignature.bin`.
 *
 * See also @ref working_with_macros
 *
 * @return A #lxw_error.
 *)
function workbook_add_signed_vba_project(workbook: Plxw_workbook; const vba_project: PUTF8Char; const signature: PUTF8Char): lxw_error; cdecl;
  external bj name _PU + 'workbook_add_signed_vba_project';

(**
 * @brief Set the VBA name for the workbook.
 *
 * @param workbook Pointer to a lxw_workbook instance.
 * @param name     Name of the workbook used by VBA.
 *
 * The `workbook_set_vba_name()` function can be used to set the VBA name for
 * the workbook. This is sometimes required when a vbaProject macro included
 * via `workbook_add_vba_project()` refers to the workbook by a name other
 * than `ThisWorkbook`.
 *
 * @code
 *     workbook_set_vba_name(workbook, "MyWorkbook");
 * @endcode
 *
 * If an Excel VBA name for the workbook isn't specified then libxlsxwriter
 * will use `ThisWorkbook`.
 *
 * See also @ref working_with_macros
 *
 * @return A #lxw_error.
 *)
function workbook_set_vba_name(workbook: Plxw_workbook; const name: PUTF8Char): lxw_error; cdecl;
  external bj name _PU + 'workbook_set_vba_name';

(**
 * @brief Add a recommendation to open the file in "read-only" mode.
 *
 * @param workbook Pointer to a lxw_workbook instance.
 *
 * This function can be used to set the Excel "Read-only Recommended" option
 * that is available when saving a file. This presents the user of the file
 * with an option to open it in "read-only" mode. This means that any changes
 * to the file can't be saved back to the same file and must be saved to a new
 * file. It can be set as follows:
 *
 * @code
 *     workbook_read_only_recommended(workbook);
 * @endcode
 *
 * Which will raise a dialog like the following when opening the file:
 *
 * @image html read_only.png
 *)
procedure workbook_read_only_recommended(workbook: Plxw_workbook); cdecl;
  external bj name _PU + 'workbook_read_only_recommended';

(**
 * @brief Set the workbook to use the 1904 epoch.
 *
 * @param workbook Pointer to a lxw_workbook instance.
 *
 * The `%workbook_use_1904_epoch()` function can be used to set the workbook to
 * use the 1904 epoch instead of the default 1900 epoch.
 *
 * Excel supports two date epochs. The first based on 1900-01-01 is the default
 * for all Windows versions of Excel and for recent versions of Excel for macOS.
 * Older versions of Excel for macOS used a 1904-01-01 epoch. The 1904 epoch can
 * be set for compatibility with older versions of Excel or to work around the
 * Excel limitation of not being able to handle negative times.
 *
 * This function should be called before `worksheet_add_worksheet()`.
 *
 * @code
 *     workbook_use_1904_epoch(workbook);
 * @endcode
 *
 *)
procedure workbook_use_1904_epoch(workbook: Plxw_workbook); cdecl;
  external bj name _PU + 'workbook_use_1904_epoch';
(**
 * @brief Set the size of a workbook window.
 *
 * @param workbook Pointer to a lxw_workbook instance.
 * @param width    Width of the window in pixels.
 * @param height   Height of the window in pixels.
 *
 * Set the size of a workbook window. This is generally only useful on macOS
 * since Microsoft Windows uses the window size from the last time an Excel file
 * was opened/saved. The default size is 1073 x 644 pixels.
 *
 * The resulting pixel sizes may not exactly match the target screen and
 * resolution since it is based on the original Excel for Windows sizes. Some
 * trial and error may be required to get an exact size.
 *)
procedure workbook_set_size(workbook: Plxw_workbook; width: UInt16; height: UInt16); cdecl;
  external bj name _PU + 'workbook_set_size';
procedure lxw_workbook_free(workbook: Plxw_workbook); cdecl;
  external bj name _PU + 'lxw_workbook_free';

procedure lxw_workbook_assemble_xml_file(workbook: Plxw_workbook); cdecl;
  external bj name _PU + 'lxw_workbook_assemble_xml_file';

procedure lxw_workbook_set_default_xf_indices(workbook: Plxw_workbook); cdecl;
  external bj name _PU + 'lxw_workbook_set_default_xf_indices';

procedure workbook_unset_default_url_format(workbook: Plxw_workbook); cdecl;
  external bj name _PU + 'workbook_unset_default_url_format';

procedure decodecell(const aCell: PUTF8Char; out aRow, aCol: DWord);
procedure decodecols(const aCell: PUTF8Char; out aColBegin, aColEnd: DWord);
procedure decoderange(const aRange: PUTF8Char; out arowBegin, acolBegin, aRowEnd, aColEnd: DWord);

procedure chart_font_init(var aFont: lxw_chart_font);
procedure table_column_init(var aCol: lxw_table_column);cdecl;
procedure table_options_init(var aOpt: lxw_table_options);cdecl;
procedure chart_data_label_init(var aLbl: lxw_chart_data_label);

implementation

procedure decodecell(const aCell: PUTF8Char; out aRow, aCol: DWord);
begin
  aCol := lxw_name_to_col(acell);
  aRow := lxw_name_to_row(acell);
end;

procedure decodecols(const aCell: PUTF8Char; out aColBegin, aColEnd: DWord);
begin
  aColBegin := lxw_name_to_col(acell);
  aColEnd := lxw_name_to_col_2(acell);
end;

procedure decoderange(const aRange: PUTF8Char; out arowBegin, acolBegin, aRowEnd, aColEnd: DWord);
begin
  aRowBegin := lxw_name_to_row(aRange);
  aColBegin := lxw_name_to_col(aRange);
  aRowEnd   := lxw_name_to_row_2(aRange);
  aColEnd   := lxw_name_to_col_2(aRange);
end;

procedure chart_font_init(var aFont: lxw_chart_font);
begin
{
  aFont.name := 'Calibri';
  aFont.size := $B;
}
  aFont.name := nil;
  aFont.size := $0;
  aFont.bold := $0;
  aFont.italic := $0;
  aFont.underline := $0;
  aFont.rotation := $0;
  aFont.color := $0;
  aFont.pitch_family := $0;
  aFont.charset := $0;
  aFont.baseline := $0;
end;

procedure table_column_init(var aCol: lxw_table_column);
begin
    aCol.header := nil;
    aCol.formula := nil;
    aCol.total_string := nil;
    aCol.total_function := 0;
    aCol.header_format := nil;
    aCol.format := nil;
    aCol.total_value := $0;
end;

procedure table_options_init(var aOpt: lxw_table_options);
begin
  aOpt.name := nil;
  aOpt.no_header_row := $0;
  aOpt.no_autofilter := $0;
  aOpt.no_banded_rows :=  $0;
  aOpt.banded_columns := $0;
  aOpt.first_column := $0;
  aOpt.last_column := 0;
  aOpt.style_type := $0;
  aOpt.style_type_number := $0;
  aOpt.total_row :=  $0;
  aOpt.columns := nil;
end;

procedure chart_data_label_init(var aLbl: lxw_chart_data_label);
begin
  aLbl.value := nil;
  aLbl.hide := $0;
  aLbl.font := nil;
  aLbl.line := nil;
  aLbl.fill := nil;
  aLbl.pattern := nil;
end;


end.
